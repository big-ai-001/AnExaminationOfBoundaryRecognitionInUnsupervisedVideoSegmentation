1
00:00:00,659 --> 00:00:04,310
Hello, and welcome to this Free Code Camp
course on algorithmic trading and Python.

2
00:00:04,310 --> 00:00:08,010
My name is Nick McCollum, I'm going to be
your instructor for this course. And in this

3
00:00:08,010 --> 00:00:12,400
course, we're going to focus on building three
large quantitative finance projects. In the

4
00:00:12,400 --> 00:00:17,540
first project, we are going to build an equal
weight version of the popular s&p 500 index

5
00:00:17,540 --> 00:00:21,430
fund. In the second project, we are going
to build a quantitative momentum strategy

6
00:00:21,430 --> 00:00:26,769
that selects the best stocks based on a variety
of momentum, investing metrics. And in the

7
00:00:26,769 --> 00:00:32,080
third project, we're going to build a quantitative
value screener that select stocks that are

8
00:00:32,080 --> 00:00:37,820
attractive based on a number of value metrics.
So that's a quick summary of the three projects

9
00:00:37,820 --> 00:00:41,730
that we are going to build in this course.
Before we move into learning more about the

10
00:00:41,730 --> 00:00:45,350
course and those projects, I have a couple
of housekeeping items that have to go over

11
00:00:45,350 --> 00:00:49,059
first, to start this Free Code Camp course
on algorithmic trading. And Python is made

12
00:00:49,059 --> 00:00:53,350
possible through a grant from IE x cloud.
If you've ever read the book, flash boys by

13
00:00:53,350 --> 00:00:57,399
Michael Lewis, you may have heard of it. In
this course, we're gonna be using some other

14
00:00:57,399 --> 00:01:02,219
tools and API's to populate some of the data
that we will need for these algorithmic trading

15
00:01:02,219 --> 00:01:05,890
strategies. The other quick thing that you're
going to notice starting now is a little message

16
00:01:05,890 --> 00:01:10,320
at the bottom of your screen that's going
to stay there for the rest of the video. And

17
00:01:10,320 --> 00:01:14,220
what that message intends to represent is
that this course is for educational purposes

18
00:01:14,220 --> 00:01:18,930
only, I'm going to be providing some high
level finance concepts, but nothing in this

19
00:01:18,930 --> 00:01:24,100
course or in this video should be construed
as investment advice. So just to reiterate,

20
00:01:24,100 --> 00:01:27,830
this course, is for educational purposes only.
And none of this should be considered investment

21
00:01:27,830 --> 00:01:31,180
advice. So with all of that out of the way,
let's dig into a little bit more about what

22
00:01:31,180 --> 00:01:36,700
this course is going to teach you. So let's
start by just going over a quick course overview.

23
00:01:36,700 --> 00:01:40,380
The first thing that we're going to discuss
is some basics of the field of algorithmic

24
00:01:40,380 --> 00:01:45,300
trading. Then we're going to discuss some
API basics, and kind of just quickly go over

25
00:01:45,300 --> 00:01:49,560
how the course is configured and laid out.
The next thing we're going to discuss is the

26
00:01:49,560 --> 00:01:54,110
first project of this course, which is an
equal way version of the popular s&p 500 index

27
00:01:54,110 --> 00:01:58,420
fund. And then we're going to talk about our
second project, which, as I mentioned earlier,

28
00:01:58,420 --> 00:02:02,980
is a quantitative momentum strategy. And then
we're going to discuss briefly our third project,

29
00:02:02,980 --> 00:02:08,280
which is a quantitative value strategy. So
that's kind of a 30,000 foot view of what

30
00:02:08,280 --> 00:02:11,890
you're going to be learning in this course.
Let's zoom in a little bit and talk about

31
00:02:11,890 --> 00:02:18,140
some algorithmic trading basics. So for anyone
who's completely unfamiliar with algorithmic

32
00:02:18,140 --> 00:02:22,520
trading, it basically means using computers
to make investment decisions. So in the past,

33
00:02:22,520 --> 00:02:27,250
where you may have had a team of financial
analysts or investment researchers to kind

34
00:02:27,250 --> 00:02:32,090
of consider stocks and decide what to buy.
Many of the popular investing strategies that

35
00:02:32,090 --> 00:02:36,140
are implemented today actually use more computers
than they do humans. So algorithmic trading

36
00:02:36,140 --> 00:02:40,340
just means using computers to make investment
decisions. Now, there are many different types

37
00:02:40,340 --> 00:02:44,200
of algorithmic trading, on the one hand, you
have, you know, your super high frequency

38
00:02:44,200 --> 00:02:49,650
trading Big Brain, really, really sophisticated
complex strategies. And then at the other

39
00:02:49,650 --> 00:02:53,900
end of the spectrum, you can kind of basically
map any type of fundamental strategy that

40
00:02:53,900 --> 00:02:57,340
humans have have led in the past, and just
make it a little more efficient by providing

41
00:02:57,340 --> 00:03:01,750
some computer software in there. So as you
know, this slide kind of alludes to the main

42
00:03:01,750 --> 00:03:05,680
difference between the many different types
of algorithmic trading is generally the speed

43
00:03:05,680 --> 00:03:12,170
at which those trades are executed. Now, before
we actually dig into more about the world

44
00:03:12,170 --> 00:03:15,840
of algorithmic trading, it's kind of helpful
to have a high level understanding of who

45
00:03:15,840 --> 00:03:20,180
the main players are in this space. And one
of the reasons I wanted to kind of provide

46
00:03:20,180 --> 00:03:23,790
this information at the start of this course
is so that you can see that the field of algorithmic

47
00:03:23,790 --> 00:03:28,160
trading is very big. And if you do want to
make a career that there are lots of employers

48
00:03:28,160 --> 00:03:32,630
lots of opportunities and lots of jobs in
this space. So right now, I'm just going to

49
00:03:32,630 --> 00:03:35,511
briefly discuss a few of the largest players
in the algorithmic trading landscape. The

50
00:03:35,511 --> 00:03:39,510
first one, which is kind of the 50,000 pound
gorilla in the room is Renaissance technologies.

51
00:03:39,510 --> 00:03:45,180
I believe they're based in Long Island, and
they have $165 billion in assets under management.

52
00:03:45,180 --> 00:03:49,500
Now, Renaissance technologies is mostly famous
for their Medallion Fund, which is only open

53
00:03:49,500 --> 00:03:54,130
to employees at this point, which I think
has returned something insane, like 50%, a

54
00:03:54,130 --> 00:03:57,990
year for 20 years or something like that.
Now, none of us can access that fund because

55
00:03:57,990 --> 00:04:02,959
it's for employees only. But Renaissance technologies
probably has one of the best performing investment

56
00:04:02,959 --> 00:04:07,740
funds in the history of finance, and perhaps
most interestingly, is that Renaissance technologies

57
00:04:07,740 --> 00:04:14,500
was not founded by a finance major or a investment
analyst to start. The person who actually

58
00:04:14,500 --> 00:04:19,919
started Renaissance technologies was a math
PhD from, I believe, a California University.

59
00:04:19,919 --> 00:04:24,130
His name's Jim Simons, and many people would
kind of consider him to be one of the forefathers

60
00:04:24,130 --> 00:04:26,780
of quantitative finance. So that's kind of
the largest player in this space. Another

61
00:04:26,780 --> 00:04:31,740
popular one is AQR Capital Management, which
was founded by Cliff Asness and a few other

62
00:04:31,740 --> 00:04:37,240
managing partners and they have $61 billion
in assets under management. Now, unlike Renaissance

63
00:04:37,240 --> 00:04:41,830
technologies, AQR Capital Management actually
has strategy and you're not gonna invest it

64
00:04:41,830 --> 00:04:45,300
through mutual funds and other types of strategies.
And one last interesting thing about that

65
00:04:45,300 --> 00:04:50,370
firm is that their name is kind of the IBM
of investment firms where IBM is International

66
00:04:50,370 --> 00:04:55,320
Business Machines a very bland name, AQR Capital
Management, the AQR component of that name

67
00:04:55,320 --> 00:04:59,950
actually stands for Applied quantitative research.
So if you've ever curious what that stands

68
00:04:59,950 --> 00:05:03,700
for, That's what it is. The last one is Citadel
securities, which has $32 billion in assets

69
00:05:03,700 --> 00:05:07,820
under management. And they're a much more
high frequency trading firm. And the first

70
00:05:07,820 --> 00:05:12,300
two that I mentioned, kind of famous for their
role in the market making space. So they were

71
00:05:12,300 --> 00:05:16,919
founded by Ken Griffin. And that kind of summarizes
three of the large players, you can tell by

72
00:05:16,919 --> 00:05:21,090
just the assets under management of these
three firms alone, more than 200 billion,

73
00:05:21,090 --> 00:05:25,220
that there are lots of opportunities and jobs.
And this is a very large space. So definitely

74
00:05:25,220 --> 00:05:30,889
something worth learning a bit about. Now,
in this course, as you probably have can tell

75
00:05:30,889 --> 00:05:34,760
by the title, we are going to be using Python
for these algorithmic trading strategies.

76
00:05:34,760 --> 00:05:38,611
Now, before we begin actually how to use Python
and how to write the code for it, there's

77
00:05:38,611 --> 00:05:43,060
a few high level things you should understand.
The first one is that Python is probably the

78
00:05:43,060 --> 00:05:47,240
most popular programming language for algorithmic
trading. And the reason why is just because

79
00:05:47,240 --> 00:05:51,730
it has a lot of libraries. But the downside
to using Python is that it's a fairly slow

80
00:05:51,730 --> 00:05:56,600
programming language. So if you want to execute
high performance code, Python is typically

81
00:05:56,600 --> 00:06:00,870
not your best bet. Now, the solution that
many practitioners have found for this is

82
00:06:00,870 --> 00:06:04,960
that Python is often used as a glue language
to trigger code that actually runs in other

83
00:06:04,960 --> 00:06:10,260
languages. A common example of this is the
NumPy library for Python. And that's actually

84
00:06:10,260 --> 00:06:15,360
a library that we'll be using in this course.
Now, NumPy is the most popular Python library

85
00:06:15,360 --> 00:06:20,120
for performing numerical computing. And it's
perhaps most popular for its data structure

86
00:06:20,120 --> 00:06:25,490
called the NumPy array, which easily allows
you to store and manipulate one or two dimensional

87
00:06:25,490 --> 00:06:31,510
data structures in Python. Now, although NumPy
is actually a Python library, and it is called

88
00:06:31,510 --> 00:06:35,330
and manipulated using the Python programming
language, the core underlying functionality

89
00:06:35,330 --> 00:06:39,979
is written in C, which is a much faster language
and provide lots of performance enhancements

90
00:06:39,979 --> 00:06:45,920
to Python users who use the NumPy library
in their code. So just to quickly summarize,

91
00:06:45,920 --> 00:06:50,740
the main idea of this section is that Python
is the most popular programming language for

92
00:06:50,740 --> 00:06:55,169
quantitative finance. But it's also a slow
language. So a lot of times you will use Python

93
00:06:55,169 --> 00:06:59,850
to trigger functionality that actually runs
in other programming languages that are faster.

94
00:06:59,850 --> 00:07:05,430
So now let's quickly talk about the algorithmic
trading process can kind of be broken down

95
00:07:05,430 --> 00:07:09,490
into the following steps, the first step is
to collect data, the second step is to develop

96
00:07:09,490 --> 00:07:14,800
a hypothesis for a strategy. The third step
step is to back test that strategy. Now, back

97
00:07:14,800 --> 00:07:19,070
testing just means formulating your strategy,
and then seeing how it would have performed

98
00:07:19,070 --> 00:07:23,110
historically over time. And generally, there's
kind of two ways you want to do that you want

99
00:07:23,110 --> 00:07:28,020
to take the strategy back as far back in time
as you can, and across as many markets as

100
00:07:28,020 --> 00:07:32,960
you can. So to provide a quick example, let's
say that you have a hypothesis that the largest

101
00:07:32,960 --> 00:07:36,740
firms outperform, you would probably want
to test that here in the United States, and

102
00:07:36,740 --> 00:07:40,280
go back as far back in time as you can. And
then you would also want to test the performance

103
00:07:40,280 --> 00:07:45,590
of the largest firms in Canada, Europe, Japan,
China, India, all the other international

104
00:07:45,590 --> 00:07:50,020
markets as well. And if that strategy performs
well in all of those markets, then you can

105
00:07:50,020 --> 00:07:53,639
be sure that you're probably on to something.
Now, the fourth strategy would be to implement

106
00:07:53,639 --> 00:07:57,260
that we're sorry, the fourth step rather,
would be to implement that strategy in production.

107
00:07:57,260 --> 00:08:02,310
So you've collected data, you develop a hypothesis,
you've back testing strategy, and now you're

108
00:08:02,310 --> 00:08:07,310
going to start actually trading that strategy
with real money. In real accounts moving forward

109
00:08:07,310 --> 00:08:11,140
and seeing how it does with real money in
the strategy. Now you have a high level understanding

110
00:08:11,140 --> 00:08:15,860
of the algorithmic trading process, there's
a few ways that this course will be different

111
00:08:15,860 --> 00:08:19,660
from a real algorithmic trading strategy.
And I just want to highlight those quickly

112
00:08:19,660 --> 00:08:24,810
right now before we dive into some information
about the three projects we'll be building.

113
00:08:24,810 --> 00:08:28,479
Now, just to quickly summarize the three major
ways that this course will be different. The

114
00:08:28,479 --> 00:08:31,870
first is that we'll be using random data,
the data provider that we're using for this

115
00:08:31,870 --> 00:08:36,004
course, which is is cloud is a paid API. So
if you want to use real data, you can follow

116
00:08:36,004 --> 00:08:41,649
the steps in this course, but actually pay
for an account and use a real API token. What

117
00:08:41,649 --> 00:08:47,259
we'll be using instead is we will be using
a sandbox API token which provides random

118
00:08:47,259 --> 00:08:53,899
data, but it's also free. So what that means
is you can you can do all the normal things

119
00:08:53,899 --> 00:08:58,209
that you can with the IRS code API, but the
data will be randomly generated. So we may

120
00:08:58,209 --> 00:09:02,970
see some interesting results because of that.
The second thing that is different is that

121
00:09:02,970 --> 00:09:06,860
we will not actually be executing trades in
this course. Now, the reason why that is,

122
00:09:06,860 --> 00:09:09,720
is because many of the people who take this
course will be using different custodians

123
00:09:09,720 --> 00:09:14,009
to execute their trades. And each one of those
custodians will have a different API infrastructure.

124
00:09:14,009 --> 00:09:17,709
So I wanted to make this course as widely
applicable as possible. So what we're going

125
00:09:17,709 --> 00:09:23,499
to be doing instead is we're going to be imagining
that we work at a firm where our traders expect

126
00:09:23,499 --> 00:09:27,980
us to generate Excel documents and send them
to them to execute trades. So the output of

127
00:09:27,980 --> 00:09:32,990
each of these three strategies will be an
Excel document that has the the name of each

128
00:09:32,990 --> 00:09:36,290
companies that need to be purchased and the
number of shares of each one of those companies

129
00:09:36,290 --> 00:09:40,179
that the trader needs to purchase. So we won't
be executing trades, but instead, we'll we'll

130
00:09:40,179 --> 00:09:46,300
be generating order sheets to send to our
imaginary traders further down the line. And

131
00:09:46,300 --> 00:09:48,470
just to reiterate that second point, we're
gonna be saving these recommended tricks to

132
00:09:48,470 --> 00:09:54,519
Excel files, which could then be sent to the
traders afterwards. Alright, so now that we

133
00:09:54,519 --> 00:09:59,180
have a bit of a high level understanding of
the algorithmic trading landscape, it's time

134
00:09:59,180 --> 00:10:05,079
to talk about API basics. configuration. So,
to start, let's discuss what is an API. API

135
00:10:05,079 --> 00:10:10,050
is an application programming interface. And
you probably aren't familiar with that if

136
00:10:10,050 --> 00:10:12,819
you've ever heard the term API before, but
that doesn't actually tell you what it does.

137
00:10:12,819 --> 00:10:17,850
I think the easiest way to understand what
an API is, is, it's a way for your software

138
00:10:17,850 --> 00:10:22,450
to interact with and potentially control someone
else's software. So in this case, we're gonna

139
00:10:22,450 --> 00:10:28,100
be using the IE x cloud API. And what we're
going to do is use their API to access their

140
00:10:28,100 --> 00:10:33,430
database of financial data and import it into
our Python script. So like I say, API's allow

141
00:10:33,430 --> 00:10:38,019
you to interact with someone else's software
using your own code. And in this course, we're

142
00:10:38,019 --> 00:10:43,009
going to use the IRS code API to gather stock
market data to make investment decisions.

143
00:10:43,009 --> 00:10:47,149
And to provide you a quick example of what
that looks like. Here's a code snippet. So

144
00:10:47,149 --> 00:10:51,050
this is a cell from a Jupyter Notebook that
has four lines, you can see on the first line

145
00:10:51,050 --> 00:10:56,309
that we declare a symbol AAPL, and that is
the stock symbol for Apple on the NASDAQ exchange.

146
00:10:56,309 --> 00:11:01,739
On the second line, we're creating a string
called API URL that has some interpolated

147
00:11:01,739 --> 00:11:08,600
values that interpolate in the symbol and
our AI x cloud API token token. And on the

148
00:11:08,600 --> 00:11:13,279
third line, we're using the requests library
of Python to provide a GET requests to that

149
00:11:13,279 --> 00:11:18,939
API URL. And then, on the last line, we're
just printing the data that gets returned.

150
00:11:18,939 --> 00:11:22,309
Now, this is kind of a lot. And if you don't
fully understand this, not to worry, you will

151
00:11:22,309 --> 00:11:26,209
see this in a lot more detail when we actually
build the projects for this course. So that's

152
00:11:26,209 --> 00:11:31,360
kind of what an API call looks like. And,
broadly speaking, in this course, we're only

153
00:11:31,360 --> 00:11:36,309
going to be using GET requests to gather data
from the IRS code API. Now, if you've never

154
00:11:36,309 --> 00:11:40,350
used an API before, there's many different
ways you can interact with them. But there's

155
00:11:40,350 --> 00:11:46,069
four major ones. And I'm going to show you
briefly some of the other ways to interact

156
00:11:46,069 --> 00:11:50,589
with an API right now before we proceed through
this course. So get requests allow you to

157
00:11:50,589 --> 00:11:54,499
get data from the API. And that's what we'll
be using in this course. An alternative is

158
00:11:54,499 --> 00:11:59,279
a POST request. And that is a method for adding
data to the database that's exposed by the

159
00:11:59,279 --> 00:12:03,189
API. So it gives a request allows you to get
data from the API and a POST request allows

160
00:12:03,189 --> 00:12:07,560
you to push data to the API. a pull request
allows you to add and overwrite data in the

161
00:12:07,560 --> 00:12:15,069
database that's exposed by the API. Now you
can think of a POST request as a create only

162
00:12:15,069 --> 00:12:19,480
request. And you can think of a put request
as a create or replace request. So there's

163
00:12:19,480 --> 00:12:23,010
a slight difference there. And but even though
it's a small difference, it's an important

164
00:12:23,010 --> 00:12:24,010
difference, because that's kind of a common
source of bugs for software developers. And

165
00:12:24,010 --> 00:12:30,589
the fourth kind of important type of API call
is a delete, which, as it name implies, it

166
00:12:30,589 --> 00:12:38,029
deletes data from the API's database. So to
provide a quick summary of this section, we're

167
00:12:38,029 --> 00:12:43,699
going to be using exclusively GET requests
in our course. But there's three main types

168
00:12:43,699 --> 00:12:47,519
of requests that you should understand those
are post, put, and delete. Now, like most

169
00:12:47,519 --> 00:12:51,860
software concepts, API's are best learned
through rigorous practice. Because of that,

170
00:12:51,860 --> 00:12:56,440
here is a URL that you can use to get a long
list of public API's that are great practice

171
00:12:56,440 --> 00:13:00,059
for you to interact with API's. Now, I would
probably recommend if you've never used an

172
00:13:00,059 --> 00:13:04,739
API before to proceed through this course,
that will give you a base fundamental understanding

173
00:13:04,739 --> 00:13:08,149
of how to work with API's. And then once that
course is done, you can go to this public

174
00:13:08,149 --> 00:13:12,759
URL and practice with some other API's that
are of interest to you personally. So this

175
00:13:12,759 --> 00:13:16,060
is not something for you to look at right
now. But it's a good resource for you to head

176
00:13:16,060 --> 00:13:20,600
later on. Alright, so now that you have a
high level understanding of the course configuration

177
00:13:20,600 --> 00:13:27,980
and some API basics, let's move on to talking
about our equal way s&p 500 fund. So if you've

178
00:13:27,980 --> 00:13:32,799
never heard of it before, the s&p 500 is the
world's most popular stock market index. And

179
00:13:32,799 --> 00:13:36,749
many investment funds are benchmarked to the
s&p 500. That means that they seek to replicate

180
00:13:36,749 --> 00:13:40,250
the performance of this index by owning all
of the stocks that are held in the index.

181
00:13:40,250 --> 00:13:44,660
Now, if you've never really researched how
stocks are added to the s&p 500, there's a

182
00:13:44,660 --> 00:13:49,189
bit of a there's a committee process and some
some sophistication there. But the easiest

183
00:13:49,189 --> 00:13:54,970
way to understand it is that the s&p 500 broadly
covers the 500 largest companies in the United

184
00:13:54,970 --> 00:14:01,009
States. So if you own the s&p 500 index fund,
you basically own the 500 largest companies

185
00:14:01,009 --> 00:14:04,999
in the US. Now aside from the fact that it
owns the 500 largest companies, one of the

186
00:14:04,999 --> 00:14:09,329
other most important characteristics of the
s&p 500 is that it is market capitalization

187
00:14:09,329 --> 00:14:15,239
weighted. Now, market capitalization is just
a finance term, that means basically size.

188
00:14:15,239 --> 00:14:19,619
So coming up with a large market capitalization
just means that it's a large company. And

189
00:14:19,619 --> 00:14:23,929
what this means is that larger companies get
a correspondingly larger weight in the s&p

190
00:14:23,929 --> 00:14:28,300
500 index. For the first product of this course,
we're going to build an alternative version

191
00:14:28,300 --> 00:14:34,129
of the s&p 500 index fund that provide that,
that assigns the same way to each company

192
00:14:34,129 --> 00:14:39,119
in the index. So instead of Apple having a
very big way and best by having a small way,

193
00:14:39,119 --> 00:14:42,249
every company will have the same weight. So
that's going to be the first project of this

194
00:14:42,249 --> 00:14:46,699
course. And the second project we are going
to build a quantitative momentum screener.

195
00:14:46,699 --> 00:14:51,339
Now, momentum investing means investing in
assets that have increased in price the most.

196
00:14:51,339 --> 00:14:56,069
To help you understand let's kind of go through
a quick example. Imagine that you have the

197
00:14:56,069 --> 00:14:59,859
choice between investing in two stocks that
have had the following returns over the last

198
00:14:59,859 --> 00:15:06,790
year. Apple has stock has gone up 35% and
Microsoft stock has gone up 20%. A momentum

199
00:15:06,790 --> 00:15:10,250
investing strategy would suggest investing
in Apple because of its higher recent price

200
00:15:10,250 --> 00:15:14,809
return. There are many other nuances to momentum
strategies, including the concept of high

201
00:15:14,809 --> 00:15:18,751
quality momentum. And that basically means
all else being equal, you would want a stock

202
00:15:18,751 --> 00:15:22,529
that has steadily increasing price rather
than no price change for a while, and then

203
00:15:22,529 --> 00:15:26,819
a large jump at the end. But we'll explore
those when we actually build our quantitative

204
00:15:26,819 --> 00:15:32,559
momentum strategy later in this course. The
third project we're going to build is a quantitative

205
00:15:32,559 --> 00:15:37,410
value screener. Now, value investing just
means investing in stocks that are trading

206
00:15:37,410 --> 00:15:42,189
below their perceived intrinsic value. So
if you kind of want to make a very simple

207
00:15:42,189 --> 00:15:46,399
analogy, value investing is kind of the idea
of buying $1 for 75 cents, and hoping that

208
00:15:46,399 --> 00:15:51,480
you can sell it again for $1 later. So value
investing is a very popular investing strategy

209
00:15:51,480 --> 00:15:55,540
because many of the world's best historical
investors like Warren Buffett, Seth Klarman,

210
00:15:55,540 --> 00:16:00,139
and Benjamin Graham have employed the strategy.
Creating algorithmic trading investing strategies

211
00:16:00,139 --> 00:16:07,199
relies on a concept called multiples and multiples
are simply a way that investors use to estimate

212
00:16:07,199 --> 00:16:13,290
how valuable a company is. So to be more specific
multiples are calculated by dividing a company's

213
00:16:13,290 --> 00:16:18,660
stock price by some measures of the company's
worth, like earnings or assets. So three examples

214
00:16:18,660 --> 00:16:22,130
of multiples that are used in value investing
are the price to earnings ratio, the price

215
00:16:22,130 --> 00:16:26,850
to book ratio, and the price to free cash
flow ratio. Now, as the name implies, the

216
00:16:26,850 --> 00:16:31,279
price to earnings ratio is calculated by dividing
a company's stock price bytes earnings per

217
00:16:31,279 --> 00:16:36,040
share, the price to book value ratio is calculated
by dividing a company's stock price by its

218
00:16:36,040 --> 00:16:40,180
book value per share. And the price to free
cash flow ratio is calculated by dividing

219
00:16:40,180 --> 00:16:46,189
a company's stock price by its free cash flow
per share. So lots of different ways you can

220
00:16:46,189 --> 00:16:50,629
calculate multiples, but those are kind of
three, three of the most important ones Anyway,

221
00:16:50,629 --> 00:16:55,429
now, each of the individual multiples to us
by value investors has its pros and cons.

222
00:16:55,429 --> 00:16:59,329
One way to minimize the impact of any specific
multiple is by using what's called a composite.

223
00:16:59,329 --> 00:17:05,050
Now, a composite is just a average of many
different valuation strategies. So in our

224
00:17:05,050 --> 00:17:08,699
strategy that we build in this course, we're
going to actually be using a composite of

225
00:17:08,699 --> 00:17:13,589
five different value investing metrics. Now,
with all that out of the way, you have a solid

226
00:17:13,589 --> 00:17:16,271
understanding of what we're going to be doing
in this course. And it's time for us to dig

227
00:17:16,271 --> 00:17:21,160
into the first project. So without further
ado, let's do just that. Alright, so it's

228
00:17:21,160 --> 00:17:25,390
now time for us to start tackling our first
project. If you've skipped ahead to this section

229
00:17:25,390 --> 00:17:28,940
of this course, there's a couple of things
that you should do before proceeding. So the

230
00:17:28,940 --> 00:17:33,990
first is to rewind back to the last section
and install all of your dependencies. If you're

231
00:17:33,990 --> 00:17:38,690
a pretty experienced Python developer, the
main dependencies for this course are NumPy,

232
00:17:38,690 --> 00:17:42,340
pandas and XLS x writer. So if you already
have those on your machine, that's fine. If

233
00:17:42,340 --> 00:17:47,410
you've already been following throughout this
video so far, I'm in our algorithmic trading

234
00:17:47,410 --> 00:17:52,220
Python folder that we cloned our local computer,
I have my virtual environment activated. And

235
00:17:52,220 --> 00:17:56,780
what I'm going to do now is launch the Jupyter
Notebook for our first project. So to do that

236
00:17:56,780 --> 00:18:03,880
the command is Python dash M and then notebook.
So this should open up a browser window. And

237
00:18:03,880 --> 00:18:09,490
what we want to do is navigate into the starter
Files folder of the algorithmic trading repository,

238
00:18:09,490 --> 00:18:15,010
and then open up the equal wait s&p 500 dot
i py MB notebook, it should look like this.

239
00:18:15,010 --> 00:18:18,360
So basically, this is what we're going to
be working through in this video. It has some

240
00:18:18,360 --> 00:18:22,580
instructions written in markdown and some
blank code cells. And that's what we're going

241
00:18:22,580 --> 00:18:28,160
to complete as we work through this section.
So let's start with just some background information.

242
00:18:28,160 --> 00:18:32,670
What we're going to do in this project is
to build an equal weight version of the s&p

243
00:18:32,670 --> 00:18:39,000
500 index fund. The s&p 500 is an equal way
or not an equal weight, market weight, market

244
00:18:39,000 --> 00:18:43,680
cap weighted basket of the 500 largest companies
in the United States. Interestingly enough,

245
00:18:43,680 --> 00:18:49,230
it actually has more than 500 stocks in it
because five or so of the largest companies

246
00:18:49,230 --> 00:18:54,230
in the US actually have multiple share classes.
So an example of that is Google it has a Class

247
00:18:54,230 --> 00:18:59,150
A and A Class C share that trade on the stock
exchange. So since alphabet, the company is

248
00:18:59,150 --> 00:19:03,480
included in the s&p 500, both of its stocks
are and because of that, there's usually around

249
00:19:03,480 --> 00:19:09,660
505 stocks in the s&p 500, despite the index
only representing 500 companies. So anyways,

250
00:19:09,660 --> 00:19:15,190
to move on, what we're going to do now is
create a different version of the s&p 500

251
00:19:15,190 --> 00:19:20,080
index fund that doesn't weight the stocks
in the index by market capitalization, but

252
00:19:20,080 --> 00:19:25,060
instead equal weights them so what this means
is that the larger companies in the index

253
00:19:25,060 --> 00:19:29,220
will have less weight than the traditional
version. And the smaller companies in the

254
00:19:29,220 --> 00:19:34,020
index will have a larger way than the traditional
version. So there's some backup information

255
00:19:34,020 --> 00:19:37,660
here just says that the largest one that's
benchmarked to this index is the spdr s&p

256
00:19:37,660 --> 00:19:43,390
500 ETF trust that's commonly known as the
ticker spy spy, which is the ticker that it

257
00:19:43,390 --> 00:19:48,060
trades on on the stock exchange. And that
ETF has more than $250 billion dollars of

258
00:19:48,060 --> 00:19:52,020
assets under management, which is pretty crazy.
Most asset management firms don't have that

259
00:19:52,020 --> 00:19:56,870
much. Hmm. So a really big fun to be sure.
And it says here The goal of this section

260
00:19:56,870 --> 00:19:59,831
of the course is to create a Python script
that will accept the value of your money.

261
00:19:59,831 --> 00:20:04,790
portfolio and tell you how many shares of
each s&p 500 constituent that you need to

262
00:20:04,790 --> 00:20:08,980
purchase to get an equal wave version of the
index funds. So the first thing we need to

263
00:20:08,980 --> 00:20:13,390
do is, you know, like most Python scripts,
this project will rely on a number of open

264
00:20:13,390 --> 00:20:17,670
source software libraries. So we're going
to import those first, we install them to

265
00:20:17,670 --> 00:20:21,731
our local computer in the dependency section
of this course. And now we just need to import

266
00:20:21,731 --> 00:20:26,040
them. And we're going to go through them one
by one here, and I'll briefly explain what

267
00:20:26,040 --> 00:20:32,050
each of these libraries does in case you haven't
haven't worked with them in the past. Alright,

268
00:20:32,050 --> 00:20:35,250
so the first library we're going to import
is NumPy. And the command to do that is important

269
00:20:35,250 --> 00:20:44,260
NumPy. Now NumPy as NP now, NumPy is a numerical
computing library. And it's known for its

270
00:20:44,260 --> 00:20:49,140
fast actually execution speed. And the reason
why NumPy is so fast is because it's actually

271
00:20:49,140 --> 00:20:56,600
a C, or maybe c++ module. So when you call
a Python function in NumPy, it actually executes

272
00:20:56,600 --> 00:20:59,690
the code in a different programming language.
And that programming language is kind of faster

273
00:20:59,690 --> 00:21:05,300
by design. So a NumPy is often used in finance
and other applications to speed up, you know,

274
00:21:05,300 --> 00:21:09,290
basic functions like summing or multiplication,
because it has modules running in a different

275
00:21:09,290 --> 00:21:15,100
programming language that is naturally faster.
So that's NumPy. We're also going to import

276
00:21:15,100 --> 00:21:22,300
pandas, as PD. And pandas is a portmanteau
for panel data, or panel data is I guess,

277
00:21:22,300 --> 00:21:26,300
because it has an S on it. And what pandas
does is it makes it very easy to work with

278
00:21:26,300 --> 00:21:31,091
tabular data in Python. So tabular data is
anything that has rows and columns, you can

279
00:21:31,091 --> 00:21:36,940
think of an Excel spreadsheet as perhaps one
of the most commonly known versions of tabular

280
00:21:36,940 --> 00:21:42,730
data. And pandas is most widely use for its
data structure called the panda's data frame.

281
00:21:42,730 --> 00:21:47,510
And a data frame is just a data structure
that holds tabular data. So pandas allows

282
00:21:47,510 --> 00:21:52,260
you to store data in a data frame, and then
use many different built in pandas functions

283
00:21:52,260 --> 00:21:56,400
and methods to manipulate the data within
that data frame. You'll see lots of examples

284
00:21:56,400 --> 00:22:00,120
about this as you work through this or this
course. And if you're interested in learning

285
00:22:00,120 --> 00:22:04,620
more about pandas Free Code Camp has an excellent
YouTube video on the topic that I would highly

286
00:22:04,620 --> 00:22:09,330
recommend. So that's pandas. And then there's
a couple others we need as well. So actually,

287
00:22:09,330 --> 00:22:14,800
before we move on, one thing that's worth
talking about is these aliases, so we didn't

288
00:22:14,800 --> 00:22:20,230
just import NumPy, we imported NumPy as NP.
And we didn't just import pandas, but we imported

289
00:22:20,230 --> 00:22:24,980
pandas as PD. So why do we do that? This just
save us a bit of typing because we're going

290
00:22:24,980 --> 00:22:31,370
to be often calling functions from these libraries.
So an example would be, let's just run this.

291
00:22:31,370 --> 00:22:35,630
So those imports run and then create a new
code. So if we wanted to create a panda's

292
00:22:35,630 --> 00:22:40,160
data frame that, you know, will just create
an empty one. For an example, if we had just

293
00:22:40,160 --> 00:22:46,600
imported pandas without importing it as PD,
we would have to write panda's dot data frame.

294
00:22:46,600 --> 00:22:52,490
And this call is the class that instantiates
A panda's data frame object. Now, because

295
00:22:52,490 --> 00:22:56,430
we imported it under the alias PD, we can
just do PD dot data frame and it's a little

296
00:22:56,430 --> 00:23:00,830
bit more readable and faster to type. So it's
not necessary to import the under aliases.

297
00:23:00,830 --> 00:23:06,230
I know a few developers who just run pandas
DataFrame. But importing pandas under the

298
00:23:06,230 --> 00:23:11,820
alias PD and NumPy under the alias NP is pretty
common and kind of widely considered to be

299
00:23:11,820 --> 00:23:14,620
a best practice. So that's what we're going
to follow in this course. Alright, let's move

300
00:23:14,620 --> 00:23:20,580
on to importing the other libraries we need.
So the next one is requests. And requests

301
00:23:20,580 --> 00:23:25,070
is a very popular Python library that it's
kind of considered the gold standard for making

302
00:23:25,070 --> 00:23:29,640
HTTP requests. Now, an HTTP request is just
basically an internet request that you can

303
00:23:29,640 --> 00:23:34,070
send to an API to get back some data. And
in this course, we're going to be using the

304
00:23:34,070 --> 00:23:41,170
requests library to execute our API calls
to the IE x cloud API to I guess, receive

305
00:23:41,170 --> 00:23:46,870
our stock market data that we need to calculate
the weightings for s&p 500 index funds, so

306
00:23:46,870 --> 00:23:50,670
the request libraries for HTTP requests. And
that's basically all you need to know about

307
00:23:50,670 --> 00:23:55,940
it for now. The next thing we need to import
is XLS. s writer, this is a library that makes

308
00:23:55,940 --> 00:24:03,090
it very easy to save well formatted documents,
Excel documents from a Python script. So that's

309
00:24:03,090 --> 00:24:09,240
XLS x writer. And the last library we need
is math. So math is just a basic Python library

310
00:24:09,240 --> 00:24:15,710
that provides many of the basic mathematical
functions that you need to, I guess, execute

311
00:24:15,710 --> 00:24:20,210
operations within Python scripts. Alright,
so once you run that code, all of your libraries

312
00:24:20,210 --> 00:24:25,320
will be imported. And the next thing that
we need to do is to import our list of stocks.

313
00:24:25,320 --> 00:24:29,351
Now, like I said, this is going to be a list
of about 500 stocks, maybe a little more if

314
00:24:29,351 --> 00:24:35,190
there's any stocks that are dual listed in
the s&p 501 thing to note about this project

315
00:24:35,190 --> 00:24:40,410
is that since these constituents change over
time, in an ideal world, you'd actually connect

316
00:24:40,410 --> 00:24:47,720
right to an Index Provider or an API, financial
data Data API or something like that. So that

317
00:24:47,720 --> 00:24:54,200
if a stock is added or removed from the s&p
500, then your equal weight s&p 500 strategy

318
00:24:54,200 --> 00:24:58,470
would reflect that now all of the tools that
would provide that information are paid and

319
00:24:58,470 --> 00:25:02,010
this is a free course. So I didn't want to
provide any paid resources in the free course

320
00:25:02,010 --> 00:25:06,950
that kind of defeats the point of it being
free. So what, what I did instead was I saved

321
00:25:06,950 --> 00:25:13,020
a list of the 500 stocks in the s&p 500 into
a CSV file, and you can click this link here

322
00:25:13,020 --> 00:25:18,070
to download that file. So what we need to
do is click that, it'll go into our Downloads

323
00:25:18,070 --> 00:25:23,960
folder, and then we need to move that file
into our starter files, full starter files,

324
00:25:23,960 --> 00:25:28,950
excuse me, we need to move this file into
our starter Files folder so that it can be

325
00:25:28,950 --> 00:25:33,260
accessed by the other files in that directory.
So let's do that now. And then once that's

326
00:25:33,260 --> 00:25:38,370
done, we can import into our Jupyter Notebook.
So open up your finder app, or I guess it

327
00:25:38,370 --> 00:25:43,550
would be finder app or Windows Explorer or
whatever app you have on your operating system

328
00:25:43,550 --> 00:25:47,840
to explore files and navigate to your downloads
folder in one tab. And then in your other

329
00:25:47,840 --> 00:25:52,020
tab, you're going to want to navigate into
that algorithmic trading and Python course.

330
00:25:52,020 --> 00:25:56,710
So here it is. And then specifically, you
want to navigate into the starter file folder

331
00:25:56,710 --> 00:26:02,010
and then drag this s&p 500 stocks dot CSV
into the starter Files folder like that. Okay,

332
00:26:02,010 --> 00:26:08,780
so now that that's done, what we need to do
is save the s&p 500 stocks as a panda's data

333
00:26:08,780 --> 00:26:13,210
frame. And the way to do that is we're going
to assign it to a panda's data frame named

334
00:26:13,210 --> 00:26:19,900
stocks. So stocks equals k dot read CSV, and
then the name of the file. So if you just

335
00:26:19,900 --> 00:26:24,659
type in SP, and then tab, it might autocomplete
there it is. And if it doesn't autocomplete,

336
00:26:24,659 --> 00:26:31,730
just type in the file name. So what is this,
it is a this is a method that lives within

337
00:26:31,730 --> 00:26:36,730
the pandas library that takes in data in the
form of a CSV, and then stores it into a panda's

338
00:26:36,730 --> 00:26:41,520
data frame. So you can verify that by just
doing type of stocks, and this should return

339
00:26:41,520 --> 00:26:48,260
panda's data frame. Yep. And then if you print
it out, it'll actually show the data. So Jupyter

340
00:26:48,260 --> 00:26:51,920
Notebooks have this kind of special feature
where if you type a variable on the last line

341
00:26:51,920 --> 00:26:57,130
of a code cell, it will print it. So this
is what is contained in our, in our panda's

342
00:26:57,130 --> 00:27:01,260
data frame. Like I said, there's actually
505 stocks within this data frame, which means

343
00:27:01,260 --> 00:27:05,770
that there's five stocks that have dual shared
share structures in the s&p 500 at this time.

344
00:27:05,770 --> 00:27:10,600
So that's what we're going to be working with
throughout the rest of this tutorial. The

345
00:27:10,600 --> 00:27:14,450
next thing we need to do is acquire an API
token, like I mentioned in the introduction

346
00:27:14,450 --> 00:27:18,780
to this course, we're going to be using the
IE x cloud API to gather all of our financial

347
00:27:18,780 --> 00:27:24,130
data. And like most API's, they require some
form of authentification before you can pull

348
00:27:24,130 --> 00:27:30,120
data from it. So what we're actually gonna
be using in this course, is the sandbox mode

349
00:27:30,120 --> 00:27:35,480
of the IE x cloud API. And sandbox mode is
a kind of like a play mode, where you can

350
00:27:35,480 --> 00:27:39,800
make sure that all of your API calls work,
but it doesn't actually return real time financial

351
00:27:39,800 --> 00:27:44,860
data. Instead, it returns randomized financial
data. And the reason why sandbox mode exists

352
00:27:44,860 --> 00:27:51,880
is because it allows you to test whether or
not your API calls function properly before

353
00:27:51,880 --> 00:27:57,230
you actually start to use the real API, and
incur data usage as a result. So the easiest

354
00:27:57,230 --> 00:28:03,780
way to to handle this, in my opinion, when
building this course, was to create a secrets.py

355
00:28:03,780 --> 00:28:11,160
file and secrets.py files are files that are
stored in your repository or on the server

356
00:28:11,160 --> 00:28:15,559
that's running this code that doesn't actually
get pushed to GitHub or any kind of remote

357
00:28:15,559 --> 00:28:21,250
Git store. So the reason why is because most
of the information stored in a secret.py file

358
00:28:21,250 --> 00:28:25,860
is sensitive or confidential in some way,
and you just don't want that type of information

359
00:28:25,860 --> 00:28:31,160
stored in a centralized Git repository. So
you'll notice in the Git ignore of this course,

360
00:28:31,160 --> 00:28:35,420
the secrets.py file is actually included in
the Git ignore, which means that if you ever

361
00:28:35,420 --> 00:28:39,750
fork this repository to work on it, and then
push your changes up to GitHub, the information

362
00:28:39,750 --> 00:28:45,059
contained in the secrets.py file doesn't actually
get pushed up as well. So since it's actually

363
00:28:45,059 --> 00:28:51,020
a sandbox API key, it doesn't really matter
in this specific instance, whether the secrets.py

364
00:28:51,020 --> 00:28:57,059
file is exposed. But keep in mind for future
Python courses are anything else that you

365
00:28:57,059 --> 00:29:00,780
work on that you should never share your secrets.py
file with anyone. But this course is kind

366
00:29:00,780 --> 00:29:04,309
of an exception, since we're working with
a sandbox API key. So to start, we're going

367
00:29:04,309 --> 00:29:08,880
to click here. And this will download a secrets.py
file to your downloads folder. Now, you may

368
00:29:08,880 --> 00:29:12,620
get a warning that says something like this,
in my case, it says this type of file can

369
00:29:12,620 --> 00:29:16,861
harm your computer do you want to keep secrets.pi
anyway, and we're going to keep it in and

370
00:29:16,861 --> 00:29:23,090
move it into the same starter Files folder
that we moved our CSV file of stocked into.

371
00:29:23,090 --> 00:29:29,780
So if you open back up your finder, app or
whatever app that you have on your operating

372
00:29:29,780 --> 00:29:33,140
system, you should have your two tabs still
open, you can click and drag the secrets.py

373
00:29:33,140 --> 00:29:38,630
file into the starter Files folder. And then
we need to import our IE x cloud API key into

374
00:29:38,630 --> 00:29:43,800
our script. So what we're going to do for
that is we're going to say from secrets, import,

375
00:29:43,800 --> 00:29:51,380
ie x, and then if you hit tab, it should autocomplete.
It says cannot import I yet have API token.

376
00:29:51,380 --> 00:30:05,070
From secrets. I wonder where that is. usually
done. Okay, so this is equally as. Alright,

377
00:30:05,070 --> 00:30:11,670
so sometimes what happens with these Jupyter
Notebooks is that when you add a file to the

378
00:30:11,670 --> 00:30:15,830
working directory that the Jupyter Notebook
is opening, it actually doesn't recognize

379
00:30:15,830 --> 00:30:20,110
that it's there until you reset the kernel.
So let's try that we're going to say, restart

380
00:30:20,110 --> 00:30:24,630
the kernel. And then we're going to go back
to the top and run all of our code cells from

381
00:30:24,630 --> 00:30:30,460
the start. Awesome. And this time it imported
correctly. So in a lot of cases, I might run

382
00:30:30,460 --> 00:30:34,240
into little hiccups like that when working
through this code. And in some courses, people

383
00:30:34,240 --> 00:30:37,700
edit it out for a more clean experience. But
I would say in the majority of cases, I'm

384
00:30:37,700 --> 00:30:41,060
going to leave them in so that you can see
the debugging process and what I actually

385
00:30:41,060 --> 00:30:45,320
do to fix the problems that I encounter. So
that was a small example of that. You'll see

386
00:30:45,320 --> 00:30:49,840
more as you work through this course. So now
we're going to make our first API call. So

387
00:30:49,840 --> 00:30:55,190
making API calls is a bit of a, an art because
every API works a little bit differently.

388
00:30:55,190 --> 00:31:01,470
And some API's have lackluster documentation.
In this case, the i x cloud API has excellent

389
00:31:01,470 --> 00:31:06,380
documentation. And I'm going to kind of show
you a bit of the documentation as we work

390
00:31:06,380 --> 00:31:10,500
through this section that creates our first
API call. So in this specific case, for the

391
00:31:10,500 --> 00:31:13,929
s&p 500 index fund, there's two things we
need, we need the market capitalization for

392
00:31:13,929 --> 00:31:19,030
each stock and the price of each stock. So
to start, we're just going to do an API call

393
00:31:19,030 --> 00:31:23,910
for one single stock. And then, to generalize
that, for our entire universe of stocks, what

394
00:31:23,910 --> 00:31:27,500
we're going to do is loop over every stock
that's contained in the panda's data frame

395
00:31:27,500 --> 00:31:32,100
that we created earlier, and then run that
same API, call it for each one of those stocks

396
00:31:32,100 --> 00:31:38,020
using a Python for loop. So to start, let's
just create symbol equals. And we're going

397
00:31:38,020 --> 00:31:42,210
to make this a string that is Apple's topic,
which is AAPL. And then on the next line,

398
00:31:42,210 --> 00:31:49,800
we're going to say, what is the API URL? And
that's a good question. What API endpoint

399
00:31:49,800 --> 00:31:52,750
is that, that's what we're gonna find out.
Next. To do that, we're going to navigate

400
00:31:52,750 --> 00:31:57,850
over to the IX, cog documentations. And the
easiest way to find this is just go to is

401
00:31:57,850 --> 00:32:02,481
cloud. Doc's on a Google search. And it's
this first hit here, that is not an ad. So

402
00:32:02,481 --> 00:32:08,100
click through to this. And what this is, is
basically a massive single page resource for

403
00:32:08,100 --> 00:32:13,520
all the possible information that you might
need about the cloud API. ie x cloud has remarkably

404
00:32:13,520 --> 00:32:18,550
good documentation. There are other API's
out there that maybe aren't as commercialized

405
00:32:18,550 --> 00:32:24,600
or are not as mature that won't have documentation
that that's this good. So as you kind of look

406
00:32:24,600 --> 00:32:28,429
through this, keep in mind that this is probably
a better than average documentation page for

407
00:32:28,429 --> 00:32:34,070
an public API. Now, the first thing we need
is the base URL for the API. And what the

408
00:32:34,070 --> 00:32:41,260
base URL is, is it's basically a URL that
will start every HTTP request. And then after

409
00:32:41,260 --> 00:32:45,191
that base URL, you have to add which specific
endpoint that you want to retrieve from the

410
00:32:45,191 --> 00:32:50,559
API. The way most API's work is they only
expose certain data through each endpoint,

411
00:32:50,559 --> 00:32:54,500
which makes things faster if you only need
to retrieve certain data. So one example might

412
00:32:54,500 --> 00:33:01,830
be, if you have the Google Maps API, you might
only want the name of a location. So you would

413
00:33:01,830 --> 00:33:05,530
send coordinates and get back its name, you
wouldn't get back other information like population

414
00:33:05,530 --> 00:33:09,929
or other sorts of things because you only
want name and sending only that limited information

415
00:33:09,929 --> 00:33:14,070
is faster than sending information you wouldn't
meet. So API endpoints are limited in that

416
00:33:14,070 --> 00:33:18,310
respect. But to start, the first thing we
did is the base URL. Now, you can see in this

417
00:33:18,310 --> 00:33:24,580
first block of text called API reference that
the base URL for the API is HTTPS for slash

418
00:33:24,580 --> 00:33:29,470
cloud.ie. x API comm we're actually using
the sandbox mode of this API in this course,

419
00:33:29,470 --> 00:33:34,250
which means that we're not charged for any
usage. But we get randomized that In exchange,

420
00:33:34,250 --> 00:33:37,581
so you could actually use the sandbox mode
to create real investment strategies, but

421
00:33:37,581 --> 00:33:43,260
it's free. And it's still a good way to learn
about how data API's work in general. But

422
00:33:43,260 --> 00:33:49,360
because of that, we can't use this base URL,
what we need to do is a Ctrl F for sandbox.

423
00:33:49,360 --> 00:33:53,560
And if we kind of search through the first
little bit, we find this section called testing

424
00:33:53,560 --> 00:33:58,460
sandbox. It says this is cloud provides all
accounts a free unlimited use sandbox for

425
00:33:58,460 --> 00:34:02,280
testing, every account will be assigned to
test tokens available via the console, all

426
00:34:02,280 --> 00:34:06,580
sandbox API, or sorry, all sandbox endpoints
function the same as production, you only

427
00:34:06,580 --> 00:34:10,829
need to change the base URL and token. So
what does that mean, we need to change the

428
00:34:10,829 --> 00:34:16,399
base URL, which means we need to grab this
instead of the base URL that was provided

429
00:34:16,399 --> 00:34:21,019
earlier. So copy that to your clipboard, move
back to our Jupyter Notebook and paste that

430
00:34:21,019 --> 00:34:25,249
right there. Awesome. So we have our base
URL. The next thing we need to do is figure

431
00:34:25,249 --> 00:34:29,940
out which endpoint we need. And as you can
see from looking at this, we ideally want

432
00:34:29,940 --> 00:34:35,080
to find an endpoint that provides both market
capitalization and stock price. There is one

433
00:34:35,080 --> 00:34:40,560
API endpoint provided by AI x cloud that provides
both of those, but I'm going to show you first

434
00:34:40,560 --> 00:34:44,839
how you would find just any endpoint that
provides one of those metrics and then I'll

435
00:34:44,839 --> 00:34:49,740
show you the input we're actually going to
use so let's start with market capitalization.

436
00:34:49,740 --> 00:34:53,570
Note that is cloud does have this search bar
over here in the top left, but for some reason,

437
00:34:53,570 --> 00:34:58,859
I always just find myself using a Ctrl F instead.
So what we're gonna do here is do market cap

438
00:34:58,859 --> 00:35:03,789
or let's just do market cap not market capitalization
because it's sometimes abbreviated. So what

439
00:35:03,789 --> 00:35:08,220
do we have here for the first its enterprise
value and price to sales. So these are both

440
00:35:08,220 --> 00:35:13,319
metrics that are calculated using market capitalization,
they don't actually give us market capitalization.

441
00:35:13,319 --> 00:35:18,680
So neither of those is what we need. The next
one is actually a true market cap metric.

442
00:35:18,680 --> 00:35:24,809
And this is exactly what we need. But if you
look through the rest of the response attributes

443
00:35:24,809 --> 00:35:30,999
from this API endpoint, this doesn't actually
give you stock price. So we like I said, we

444
00:35:30,999 --> 00:35:35,539
ideally want to find an endpoint that has
both price and market cap. And with a bit

445
00:35:35,539 --> 00:35:40,670
of searching, you would find that the, quote
endpoint provides both of those. So I just

446
00:35:40,670 --> 00:35:44,950
did a Ctrl F for for slash, quote, forward
slash. And this takes us to the information

447
00:35:44,950 --> 00:35:51,799
section about the quote endpoint. Now, every
endpoint description on the IE x cloud API

448
00:35:51,799 --> 00:35:57,180
starts with a section on how to execute the,
the HTTP request for that endpoint. So in

449
00:35:57,180 --> 00:36:03,720
this case, we want to execute a get HTTP request.
And the endpoint is for slash stock, and then

450
00:36:03,720 --> 00:36:10,849
symbol and then forward slash quote. So if
we just copy this, and add this to the API

451
00:36:10,849 --> 00:36:16,310
endpoint that we have in our Jupyter Notebook,
this actually won't work. Because this, you

452
00:36:16,310 --> 00:36:21,099
know, curly brackets symbol thing here doesn't
mean anything in the context of this string.

453
00:36:21,099 --> 00:36:27,009
If we tried to execute this HTTP request as
it is, this will return a 400 error probably.

454
00:36:27,009 --> 00:36:33,109
So what we need to do is we need to transform
this API URL into an F string. Now, an F string,

455
00:36:33,109 --> 00:36:36,900
if you've never used them before, I'll give
you a very brief introduction. So if you have

456
00:36:36,900 --> 00:36:44,819
string equals Free Code, camp is awesome.
And then you said I need to change the values

457
00:36:44,819 --> 00:36:52,519
within this string based on some outside variable.
We will say we'll create a variable called

458
00:36:52,519 --> 00:36:57,730
adjective. And this just describes a word
that we want to call Free Code Camp, we will

459
00:36:57,730 --> 00:37:04,299
say the adjective is superb instead of awesome.
And then we want to pass that adjective variable

460
00:37:04,299 --> 00:37:08,380
where this awesome word is within within the
strength. So the way to do that is you create

461
00:37:08,380 --> 00:37:12,360
an F string, now, as strings are called that
strings, because you simply put an F on the

462
00:37:12,360 --> 00:37:15,760
start of the string. And then this allows
you to interpolate values in so here, curly

463
00:37:15,760 --> 00:37:21,430
brackets, and then we type adjective. Now,
what this string actually stores is Free Code

464
00:37:21,430 --> 00:37:27,380
Camp is superb. And you can test that by printing
the string. Free Code Camp is super now we're

465
00:37:27,380 --> 00:37:32,619
going to use this string functionality to
create our API endpoint. And you're sorry,

466
00:37:32,619 --> 00:37:37,490
yeah, no, to create our API URL. So we're
going to do is we're going to cut this and

467
00:37:37,490 --> 00:37:41,890
just get rid of it. And then here, this already
has the curly brackets that are associated

468
00:37:41,890 --> 00:37:46,350
with an F string. So all we need to do. And
actually, in addition to the curly brackets,

469
00:37:46,350 --> 00:37:49,549
it has the right variable name that we called
here, I think I did that by design, well,

470
00:37:49,549 --> 00:37:55,289
kind of building the code for this course.
So what we're doing is adding an F there.

471
00:37:55,289 --> 00:38:04,420
And then if we print this oops, if we print
this API URL, this should print out this string.

472
00:38:04,420 --> 00:38:08,700
But instead of symbol, it should say a PL
all caps. Perfect. That's exactly what we

473
00:38:08,700 --> 00:38:16,720
need. Okay. The last thing we need to do is
we need to add an appendage to the end of

474
00:38:16,720 --> 00:38:25,190
this API URL that that passes in our API token
to authenticate us through the i x cloud API,

475
00:38:25,190 --> 00:38:29,599
and basically say, this user does have permission
to access this API endpoint. Now the way to

476
00:38:29,599 --> 00:38:35,100
do that is you say, question mark token equals,
and then we're going to use an F string again,

477
00:38:35,100 --> 00:38:41,089
and say, is cloud token that we imported earlier,
if you just type in all caps, ie x and then

478
00:38:41,089 --> 00:38:45,630
hit tab, this will autocomplete for you. Now,
if we print this, oh, sorry, I didn't actually

479
00:38:45,630 --> 00:38:54,819
have a print statement there. If we print
this. This gives us a fully fledged AI x cloud

480
00:38:54,819 --> 00:38:59,609
endpoint that we can pay using the requests
library. So moving on to that, what we need

481
00:38:59,609 --> 00:39:05,670
to do now is execute an HTTP request and store
the results of that HTTP request in some outside

482
00:39:05,670 --> 00:39:10,170
variable, we're going to call that variable
data. And what we need to assign it to is

483
00:39:10,170 --> 00:39:16,180
a requests dot get method. Now, if you've
never used the requests library, that's what

484
00:39:16,180 --> 00:39:22,900
we imported at the top of our script. Here.
It's kind of known as the world's best Python

485
00:39:22,900 --> 00:39:29,890
library for executing HTTP requests. Their
tagline is, their tagline is HTTP for humans.

486
00:39:29,890 --> 00:39:32,829
And I quite like that because it does describe
Well, what they do. So what we need to do

487
00:39:32,829 --> 00:39:40,119
here is just type in request dot get and then
pass in our API URL. Now, if we run that,

488
00:39:40,119 --> 00:39:44,989
what the heck is this data variable? The easiest
way to check is to just do the pipe function

489
00:39:44,989 --> 00:39:50,190
and pass in data. And what it is is it's a
response object, which is contained within

490
00:39:50,190 --> 00:39:55,900
the LA models, module of the requests library.
Now, this response object has many different

491
00:39:55,900 --> 00:40:02,220
things inside of it. And one of the more interesting
ones is the status code. So we can do bank

492
00:40:02,220 --> 00:40:08,549
data dot status code, and I'm gonna hit tab
and see if that autocompletes okay didn't

493
00:40:08,549 --> 00:40:13,059
set out, you know, there it is. And this gives
us a 404. Now, why the heck does it give us

494
00:40:13,059 --> 00:40:17,989
a 404? Clearly I did something wrong here.
Okay, so I just figured it out the error.

495
00:40:17,989 --> 00:40:25,529
And what I missed here was, there's an additional
kind of suffix that needs to get added to

496
00:40:25,529 --> 00:40:32,170
the i x cloud endpoint, called forward slash
stable. Now, why does that exist? If you look

497
00:40:32,170 --> 00:40:35,239
at this section, here, there's two different
naming conventions they can use, you can use

498
00:40:35,239 --> 00:40:41,500
stable or latest stable is kind of the latest
stable API version. As you can see here, well,

499
00:40:41,500 --> 00:40:45,570
latest, you can access the latest API version,
which may be in beta. So basically, stable

500
00:40:45,570 --> 00:40:48,770
is what you want to use if you want to make
sure that your application never breaks. And

501
00:40:48,770 --> 00:40:51,739
latest is what you want to use. If you want
access to the most bleeding edge tech that

502
00:40:51,739 --> 00:40:57,489
might not be fully tested yet. So all we need
to do is go back here, and here type for slash

503
00:40:57,489 --> 00:41:03,670
stable for slash, and then run this. Now we
get a response 200, air response 200 code,

504
00:41:03,670 --> 00:41:08,650
I mean, which means that the HTTP request
was executed properly. And I actually don't

505
00:41:08,650 --> 00:41:15,440
like this format. It's not as accessible as
this status code attribute that we can access.

506
00:41:15,440 --> 00:41:20,329
And the reason I like this better is you can
say, you can test it using equality operator.

507
00:41:20,329 --> 00:41:25,739
So is this equal to 200? True. And that's
kind of an easy way to handle exceptions with

508
00:41:25,739 --> 00:41:32,160
HTTP. But if you say, if it's not equal to
200, oops, you could say if it's not equal

509
00:41:32,160 --> 00:41:38,749
to 200, then do something. Anyways. What we
need to do now is this object is not in any

510
00:41:38,749 --> 00:41:42,799
format that we can really access. So what
we're going to do is we're going to transform

511
00:41:42,799 --> 00:41:48,940
the data that this HTTP request returned to
us into a JSON object, using the dot JSON

512
00:41:48,940 --> 00:41:53,220
method, it actually accept no parameters.
So that's all we need to do. Now, if we print

513
00:41:53,220 --> 00:41:59,650
the data object or the data variable, it gives
us a long JSON type kind of Python dictionary

514
00:41:59,650 --> 00:42:05,849
object that we can use to kind of parse objects
out. Now, if you've never worked much with

515
00:42:05,849 --> 00:42:15,849
Python dictionaries, they're very useful.
I'll make a very quick example here. dictionary

516
00:42:15,849 --> 00:42:19,660
equals now dictionaries are always kind of
created using curly brackets. And what you

517
00:42:19,660 --> 00:42:32,099
can say is say A equals sorry, a colon one,
and B, colon two. So this is a Python dictionary

518
00:42:32,099 --> 00:42:35,349
called dictionary, very creative naming, the
reason why dictionaries are useless because

519
00:42:35,349 --> 00:42:41,729
you can pass in. So these entries here are
called key value pairs. This is the key this

520
00:42:41,729 --> 00:42:46,019
a and this is the value one. The reason why
dictionaries are useful is because you can

521
00:42:46,019 --> 00:42:51,599
pass in the key and it returns the value.
Now, this data variable will behave exactly

522
00:42:51,599 --> 00:42:57,150
the same way. So as an example, if you want
to access this, so this is one key value pair.

523
00:42:57,150 --> 00:43:01,970
And if you want to access the value, which
is AAPL, all you have to do is pass in the

524
00:43:01,970 --> 00:43:07,759
key, which is symbol in square brackets like
that, and this should return an apple perfect.

525
00:43:07,759 --> 00:43:16,579
So the two attributes that we wanted of this
our market capitalization and price. So we're

526
00:43:16,579 --> 00:43:24,250
going to parse that in the next section of
this course. Okay, so what we're gonna do

527
00:43:24,250 --> 00:43:30,670
here is say price equals data. And then where
is the price contained in this, the easiest

528
00:43:30,670 --> 00:43:33,739
way to tell it to do a Ctrl F. And you can
see there's a whole bunch of different price

529
00:43:33,739 --> 00:43:39,599
variables here. The one we want is probably
not calculation price, latest price sounds

530
00:43:39,599 --> 00:43:45,599
right. So that's the latest price provided
by the IETF party API. Now, if you ever see

531
00:43:45,599 --> 00:43:49,640
something like this, and you say, Hmm, I don't
know what latest price means. That's kind

532
00:43:49,640 --> 00:43:58,569
of a bad example. But let's look at something
else in here. That's not as obvious. All right,

533
00:43:58,569 --> 00:44:02,740
this variable extended change. Now what the
heck is extended change the is called documentation.

534
00:44:02,740 --> 00:44:08,130
So that should tell you so if you just copy
that extended change string to your clipboard,

535
00:44:08,130 --> 00:44:12,789
and then go back to the IE x cloud docs, run
a Ctrl F search and type in extended change,

536
00:44:12,789 --> 00:44:17,400
it will take you not just to this JSON object,
but there should be a description below. So

537
00:44:17,400 --> 00:44:21,869
as you can see here, extended change refers
to the price change between extended price

538
00:44:21,869 --> 00:44:24,829
and latest price. So without knowing what
those two means this is kind of meaningless.

539
00:44:24,829 --> 00:44:30,109
But this was just an example to show you how
you can look up the meaning of different data

540
00:44:30,109 --> 00:44:36,729
points within the JSON response in the i x
cloud docs. Okay, so that's how to parse price.

541
00:44:36,729 --> 00:44:43,049
We can print it out and see what the actual
prices 515 28. Now, I actually am not sure

542
00:44:43,049 --> 00:44:47,859
if the is cloud price data is randomized in
our sandbox mode, you can test it pretty easily

543
00:44:47,859 --> 00:44:55,200
by just doing NASDAQ Apple on Google search
for 97. Did it ever get to 515? Okay, so I

544
00:44:55,200 --> 00:45:00,509
don't think that this price is accurate, but
it's actually not far off from the real world

545
00:45:00,509 --> 00:45:05,320
price. So this price data is randomized, but
it's interestingly, quite close to the real

546
00:45:05,320 --> 00:45:10,180
price. So that's how you price out price.
And then for market cap, we'll just say market

547
00:45:10,180 --> 00:45:18,930
cap, Eagles data, and then market cap. And
similarly, you can print market cap. Awesome.

548
00:45:18,930 --> 00:45:28,049
This gives like a, I think this is I'm gonna
divide this by a trillion. That's sorry, that's

549
00:45:28,049 --> 00:45:35,010
only a billion. That's a trillion. So this
gives us a market cap of 2.1 8 trillion, which

550
00:45:35,010 --> 00:45:39,960
again, I think is pretty close to Apple's
real market capitalization. Yeah, so they're

551
00:45:39,960 --> 00:45:45,309
at 2.1 3 trillion. So in both cases, pretty
similar, although, still not exactly correct.

552
00:45:45,309 --> 00:45:51,849
Okay, so that's how you parse a API call.
What we're going to do now is we're basically

553
00:45:51,849 --> 00:45:58,359
going to scale up that process to all of the
stocks within our s&p 500. csv, and then store

554
00:45:58,359 --> 00:46:03,920
all of the responses in a panda's data frame
that we will later save into an Excel file.

555
00:46:03,920 --> 00:46:08,529
So that's what's up next. Alright, so the
first thing we need to do is actually, we're

556
00:46:08,529 --> 00:46:13,130
going to exit out of this Ctrl F box here,
because it was lighting that up and causing

557
00:46:13,130 --> 00:46:17,460
me some eggs. The first thing we need to do
is specify the columns of our panda's data

558
00:46:17,460 --> 00:46:22,460
frame. And to do that, we're going to need
to know exactly what we're building. So we're

559
00:46:22,460 --> 00:46:25,640
going to build a panda's data frame that has
a few columns, it's going to have the ticker

560
00:46:25,640 --> 00:46:29,779
for each stock, it's going to have the stock
price for each stock is going to have the

561
00:46:29,779 --> 00:46:34,539
market capitalization of each stock, and then
it's going to have the number of shares to

562
00:46:34,539 --> 00:46:40,079
buy for each stock. So let's start by specifying
that in a variable called my columns, and

563
00:46:40,079 --> 00:46:46,941
this is just going to be a Python list. And
the entries are going to be thicker. stock

564
00:46:46,941 --> 00:46:56,249
price, market capitalization, hopefully, I
can spell everything right. number of shares

565
00:46:56,249 --> 00:47:03,400
to buy. Okay, so that's the Python list. And
then we're going to do now is create a blank

566
00:47:03,400 --> 00:47:07,539
panda's data frame that has those columns
specified. So to do that, we're going to call

567
00:47:07,539 --> 00:47:11,460
this variable final data frame, because we're
going to this will be the final output of

568
00:47:11,460 --> 00:47:18,069
this program at the end. And to create a panda's
data frame, you use the PD dot data frame,

569
00:47:18,069 --> 00:47:24,930
class instantiation. And inside of this, we're
going to pass in columns equals my columns.

570
00:47:24,930 --> 00:47:31,210
Now, you notice that since this is columns,
I didn't want to call this columns, because

571
00:47:31,210 --> 00:47:36,329
columns equals columns is a bit confusing,
although I think it would work. Let's try

572
00:47:36,329 --> 00:47:41,060
it out. So that does work. I just think it's
quite a bit easier to read. If you say caught

573
00:47:41,060 --> 00:47:46,999
my columns, it kind of removes that repetition.
Okay, so our panda's data frame has been created.

574
00:47:46,999 --> 00:47:52,420
What does it look like? pandas, data frames
are just kind of two ways to print them. As

575
00:47:52,420 --> 00:47:56,670
with most things in a Jupyter Notebook, you
can either use a formal print statement like

576
00:47:56,670 --> 00:48:03,510
that, or you can just list the variable name
as the last line of code. So this is kind

577
00:48:03,510 --> 00:48:08,619
of what it looks like. There's no data in
here right now. So it's kind of empty. But

578
00:48:08,619 --> 00:48:15,839
what we can do is just do create a list of
a list, that's going to be 0000. And this

579
00:48:15,839 --> 00:48:20,069
is kind of how pandas dataframes typically
render. So one of the advantages of not using

580
00:48:20,069 --> 00:48:24,059
a formal print statement is that when you
just list the data frame variable name on

581
00:48:24,059 --> 00:48:27,569
the last line of a code sale, it will render
in this nice format that kind of allows you

582
00:48:27,569 --> 00:48:31,249
to mouse over it, and it changes color. And
it's just a little bit nicer to look at than

583
00:48:31,249 --> 00:48:35,229
the alternative, if you use a print statement
will print like this in just plain text, and

584
00:48:35,229 --> 00:48:40,029
it's not quite as nice. So that's what it
looks like when you print it with plain text.

585
00:48:40,029 --> 00:48:45,079
Actually, you know, the, I'm not a big fan
of it at all. So we'll stick to printing data

586
00:48:45,079 --> 00:48:47,950
frames, specifically like this. So that's
what our data frame looks like. I'm going

587
00:48:47,950 --> 00:48:52,360
to get rid of this line of zeros because that
was just to show you how they render. And

588
00:48:52,360 --> 00:48:55,180
that's what we're going to be working with
moving forward. So what we're going to do

589
00:48:55,180 --> 00:49:02,569
now is I'm going to show you how to append
these data points to this panda's data frame.

590
00:49:02,569 --> 00:49:09,380
So what we're going to use to do that is the
append method. So final data frame dot append.

591
00:49:09,380 --> 00:49:15,809
And then what we need to put in here is a
panda's series that lists all of the entries

592
00:49:15,809 --> 00:49:21,460
in the data frame. So I'll just quickly explain
what a panda's series before a panda's series

593
00:49:21,460 --> 00:49:28,289
is before we move on, so if we add back this
row of zeros to our panda's data frame, like

594
00:49:28,289 --> 00:49:34,769
that. So a panda's data frame is a two dimensional
data structure, which means it has rows and

595
00:49:34,769 --> 00:49:39,569
columns, whereas a panda's series is a one
dimensional data frame. If you've ever worked

596
00:49:39,569 --> 00:49:43,510
much in Python, it's similar to a Python list.
And if you've ever worked with NumPy, it's

597
00:49:43,510 --> 00:49:47,219
similar to a NumPy array just has different
methods and functions associated with it.

598
00:49:47,219 --> 00:49:52,630
But within a panda's data frame, every row
and every column of that data frame is a panda's

599
00:49:52,630 --> 00:49:57,640
series. So, in order to a panda's data to
the bottom of a panda's data frame, that data

600
00:49:57,640 --> 00:50:01,869
needs to be a panda's series. I'll show you
what I mean now. So let's take this row zeros

601
00:50:01,869 --> 00:50:06,160
out and rerun this code cell. And then what
we need to do here is create a panda's series

602
00:50:06,160 --> 00:50:12,130
with PD dot series. And then the pandas series
accepts a Python list. So lots of different

603
00:50:12,130 --> 00:50:16,390
layers here. But what we're eventually going
to work out to is adding a row to this panda's

604
00:50:16,390 --> 00:50:20,829
data frame. So the first thing we're going
to add is the name of the stock, the routing,

605
00:50:20,829 --> 00:50:26,460
which was stored in the symbol variable earlier.
And then we're going to add our price and

606
00:50:26,460 --> 00:50:33,279
market cap variables which we created earlier
price market cap, and then we're going to

607
00:50:33,279 --> 00:50:42,000
add another cell called N A. And what does
this na mean? Well, this last column, the

608
00:50:42,000 --> 00:50:46,410
number of shares to buy, we actually can't
calculate it until we have pulled in all the

609
00:50:46,410 --> 00:50:51,539
metrics for every stock. So what we're going
to do is just start as na now, and later on,

610
00:50:51,539 --> 00:50:54,859
we'll go back in access that data and change
it once we've actually pulled in data for

611
00:50:54,859 --> 00:51:01,190
all of our stocks. So what happens when we
run this code cell? Oh, we missed a comma

612
00:51:01,190 --> 00:51:06,410
in there. Now we get an error can only append
a series if ignore index equals true. So this

613
00:51:06,410 --> 00:51:11,710
is super super common. We're working in pandas,
this ignore index equals true, basically,

614
00:51:11,710 --> 00:51:14,989
almost always needs to be added to the append
method whenever you're appending data to a

615
00:51:14,989 --> 00:51:19,510
panda's data frame. So this is when we get
Whoa, this isn't what we wanted. And as you

616
00:51:19,510 --> 00:51:26,430
can see, all of these columns that we created
have na n values in them, which means not

617
00:51:26,430 --> 00:51:29,780
a number. And then over here, we have the
data that we actually want it now why is that?

618
00:51:29,780 --> 00:51:35,910
It's because we didn't tell the append method,
which columns to add that data to. So what

619
00:51:35,910 --> 00:51:41,700
we need to do to fix that is we need to add
another argument here that says, index equals

620
00:51:41,700 --> 00:51:55,969
my columns. Oh, I missed a comma, I think
No. Oh, so the first sorry, the problem here

621
00:51:55,969 --> 00:52:01,200
is that this index equals my column needs
to be within the pandas series and not within

622
00:52:01,200 --> 00:52:10,180
the panda's data frame. So small difference
there. So when we run this, we're missing

623
00:52:10,180 --> 00:52:14,460
a comma. Again, when we run this, this actually
generates what we want. And so to give a quick

624
00:52:14,460 --> 00:52:23,011
recap, we created a final data frame dot append
method. And then within that final data frame

625
00:52:23,011 --> 00:52:28,329
dot append method, we created a pandas series
that has all of the data points we wanted.

626
00:52:28,329 --> 00:52:32,940
And then we specified index equals my columns,
which tells the append method which columns

627
00:52:32,940 --> 00:52:36,660
to add this data to. And then the last thing
we did was we added to ignore index equals

628
00:52:36,660 --> 00:52:41,259
true, which is kind of necessary whenever
you're appending data to a panda's data frame.

629
00:52:41,259 --> 00:52:48,060
Alright, so what we need to do now is loop
through every ticker in our stocks variable,

630
00:52:48,060 --> 00:52:53,839
and execute an API call for that stock, and
then store the results of that API call in

631
00:52:53,839 --> 00:52:57,509
our panda's data frame. So to start, we're
going to overwrite our old panda's data frame

632
00:52:57,509 --> 00:53:04,579
variable with an empty panda's data frame
that has the same columns as before, so columns

633
00:53:04,579 --> 00:53:13,489
equals my columns, then, we need to create
a for loop that says for stock stock in stocks,

634
00:53:13,489 --> 00:53:20,510
ticker. And to start, let's just print all
of these print stock, what happens? Great.

635
00:53:20,510 --> 00:53:24,140
So we're successfully looping through all
the stocks in that data frame, we can get

636
00:53:24,140 --> 00:53:30,630
rid of that print statement. Now what happens
next, we, we need to actually create an API

637
00:53:30,630 --> 00:53:36,359
call for each stock. So to do that, we'll
scroll up to our old API call cell. And we're

638
00:53:36,359 --> 00:53:44,009
going to copy both of these lines, copy and
then scroll down. Alright, so both of those

639
00:53:44,009 --> 00:53:48,710
are getting copied in here, this needs to
get indented. And then instead of symbol here,

640
00:53:48,710 --> 00:53:55,420
we're going to write stock. R IE x cloud API
token is the same, the data is the same. So

641
00:53:55,420 --> 00:53:59,950
that's all good. Now, one thing to note about
looping through our list of stocks in this

642
00:53:59,950 --> 00:54:05,739
way, is that it's going to be really, really
slow. And the reason why it's slow is because

643
00:54:05,739 --> 00:54:10,509
executing an HTTP request is one of the slowest
things that you can do in Python. So this

644
00:54:10,509 --> 00:54:16,469
slide here, where we actually execute the
request is very, very slow. Later on, we'll

645
00:54:16,469 --> 00:54:20,450
see how to improve the performance of this
code by doing batch API requests that make

646
00:54:20,450 --> 00:54:25,309
it very easy to retrieve information on multiple
stocks with a single API requests. But that's

647
00:54:25,309 --> 00:54:29,130
kind of a more advanced topic. So we're going
to go through with single API requests first.

648
00:54:29,130 --> 00:54:32,859
Okay, so now we need to basically recreate
the append statement that we use earlier.

649
00:54:32,859 --> 00:54:39,500
So final data frame dot append. Inside the
append statement, we need to create a panda's

650
00:54:39,500 --> 00:54:45,500
series of sorry, PD dot series, and inside
that pandas series, we need to create a Python

651
00:54:45,500 --> 00:54:50,749
list. So lots going on here. The first thing
that we're going to add is stock. Now what

652
00:54:50,749 --> 00:54:55,700
is stock stock is the incrementer of this
for loop. So this will actually be the ticker

653
00:54:55,700 --> 00:55:01,269
of the stock we're working with. The next
thing we need to add is data. parsed to latest

654
00:55:01,269 --> 00:55:07,279
price, so this is the same person that we
did before, this will give us our stock price,

655
00:55:07,279 --> 00:55:13,739
which is the second column of the data frame.
The last thing is data, and then market cap,

656
00:55:13,739 --> 00:55:17,160
which is the market capitalization just like
we did earlier. And then just like before,

657
00:55:17,160 --> 00:55:27,269
we will do na for the last row within this
pandas series, function, we need to add index

658
00:55:27,269 --> 00:55:35,789
equals my columns. And then outside of the
pandas series as before, we need to add, ignore

659
00:55:35,789 --> 00:55:42,029
in index equals true. Now, since this is going
to be so slow, like I mentioned, let's just

660
00:55:42,029 --> 00:55:51,020
do this for five stocks and see what happens.
Next, oh, there's a missing comma right there,

661
00:55:51,020 --> 00:55:56,559
run. Great. Now if we print final DataFrame,
what's gonna happen? You think it'll have

662
00:55:56,559 --> 00:56:01,680
information for all five stocks, and nothing's
there. Why is that? Now, the reason why that

663
00:56:01,680 --> 00:56:07,599
is, is because this final data frame dot append
method doesn't actually modify the original

664
00:56:07,599 --> 00:56:11,940
data frame unless you tell it to. So to do
that, the easiest way is to just say, final

665
00:56:11,940 --> 00:56:19,690
data frame. I can't spell today final data
frame equals equals, and then the append statement.

666
00:56:19,690 --> 00:56:24,609
So if we run this, and then run the following,
so we should see a different output. Awesome.

667
00:56:24,609 --> 00:56:30,309
So this is for the first five stocks in our
list of stocks. If we take off this little

668
00:56:30,309 --> 00:56:37,589
argument here, this will take a very long
time to run, let's just see that in action.

669
00:56:37,589 --> 00:56:40,959
I'm going to run this print statement too.
And then while this runs, I'm going to have

670
00:56:40,959 --> 00:56:45,670
a little sip of my coffee and cut out the
rest of this until it's done. Alright, so

671
00:56:45,670 --> 00:56:49,030
as you can see, this is a very long panda's
data frame that has all of the information

672
00:56:49,030 --> 00:56:53,829
we needed. Since it took so long, we're going
to move on now to using batch API calls to

673
00:56:53,829 --> 00:56:59,329
improve the performance of this code. Now,
I x cloud, like most data providers actually

674
00:56:59,329 --> 00:57:03,569
gives you discounts if you use batch API calls,
because it's a lot less load on their infrastructure.

675
00:57:03,569 --> 00:57:07,519
So that's one reason to use them. The fact
that it speeds up your code is another reason

676
00:57:07,519 --> 00:57:11,289
to use them. Overall, if you can use batch
API calls in your scripts, it's generally

677
00:57:11,289 --> 00:57:15,729
a good practice. So pay attention to this
section because it's really important. I x

678
00:57:15,729 --> 00:57:20,299
cloud as a data provider limits their batch
API calls to 100 tickers. So what we need

679
00:57:20,299 --> 00:57:27,140
to do first is find some way to split our
list of tickers up into sub lists of length

680
00:57:27,140 --> 00:57:32,829
100. Now, it's not super intuitive on how
to do that. But basically, what I did just

681
00:57:32,829 --> 00:57:43,109
to show you is I said, how to split a list
into sub lists. And in Python. Awesome, here's

682
00:57:43,109 --> 00:57:47,489
the sorry, that took a bit of time, I had
to skip ahead. But here's the function that

683
00:57:47,489 --> 00:57:51,809
I was talking about. So it's called chunks.
And in the finished files of this course,

684
00:57:51,809 --> 00:57:55,920
you'll see that actually gave credit to this.
It has 3000 uploads, which is pretty crazy,

685
00:57:55,920 --> 00:58:01,239
even for Stack Overflow. So this is what we'll
be using to split our list or our pandas series,

686
00:58:01,239 --> 00:58:08,319
in this case into chunks of size n. So we'll
run that code cell to define this function.

687
00:58:08,319 --> 00:58:13,789
Okay, what we need to do now is use this chunks
function to create a list of lists where every

688
00:58:13,789 --> 00:58:18,779
list is no longer than 100. So to do that,
we'll say, symbol groups that will we'll call

689
00:58:18,779 --> 00:58:26,300
this equals chunks, and then the list we want
to split is stocks, ticker. Now, the reason

690
00:58:26,300 --> 00:58:31,700
why we have to pass this as ticker is because
this is a panda's data frame. And ticker is

691
00:58:31,700 --> 00:58:36,140
the header of the only column. So if we just
did stocks, this gives us the data frame.

692
00:58:36,140 --> 00:58:40,700
If we do stocks at header ticker, that gives
us a series which we can pass into this chunks

693
00:58:40,700 --> 00:58:46,739
function. And everyone say 100. So this gives
us a chunk generator. And to get the actual

694
00:58:46,739 --> 00:58:51,240
lists, we just have to pass it into a list
function. So we'll do that. And it will say

695
00:58:51,240 --> 00:58:56,589
symbol groups, see what that gives us. Okay,
so this gives us a list of lists, or more

696
00:58:56,589 --> 00:59:02,770
specifically gives us a list of pandas series.
So this is from index zero to index 99. This

697
00:59:02,770 --> 00:59:10,430
is from index 100, index 199. This is from
index 200 to 299 300 to 399 400 to 49. At

698
00:59:10,430 --> 00:59:14,720
the end, we have this one that's much shorter,
it's 500 to 504. And that's because there's

699
00:59:14,720 --> 00:59:21,549
505 stocks in the s&p 500. And this just gives
us groups of 100. At most, and since this

700
00:59:21,549 --> 00:59:26,099
one only has five minutes shorter. Okay, so
moving back up, what we need to do now is

701
00:59:26,099 --> 00:59:31,779
make a for loop that lists loops through every
list, or sorry, every panda's series within

702
00:59:31,779 --> 00:59:37,479
that list, executes a batch API call. And
then for every stock in that list, appends

703
00:59:37,479 --> 00:59:42,579
the information from that stock to our final
data frame. So first thing to do is for i

704
00:59:42,579 --> 00:59:55,839
in range, zero to length of symbol groups,
and then print. So what does this give us

705
00:59:55,839 --> 01:00:01,980
this gives us 012345. Now, those are all the
indices This symbol group groups list. So

706
01:00:01,980 --> 01:00:11,000
if we do this, oh, sorry, that's not what
I meant to do print that. This will just print

707
01:00:11,000 --> 01:00:15,549
out all of the lists within our list of lists
called symbol groups. So now what we need

708
01:00:15,549 --> 01:00:20,829
to do is we need to transform all of the stocks
that's in each of those lists into a string,

709
01:00:20,829 --> 01:00:25,249
and that string will be passed into the URL
of the HTTP request that we're executing.

710
01:00:25,249 --> 01:00:31,982
So first, we'll just create an empty list
called symbol strings. And what this is, is

711
01:00:31,982 --> 01:00:36,400
it's going to be a list of strings, where
each string is a comma separated string of

712
01:00:36,400 --> 01:00:42,259
all the stocks in this object. So all we need
to do is use the append method tabbies in

713
01:00:42,259 --> 01:00:49,180
so we're going to do symbol strings, dot 10.
And then what we're going to use is the join

714
01:00:49,180 --> 01:00:56,950
method called on the comma character join,
and then symbol groups. Now, if you've never

715
01:00:56,950 --> 01:01:00,519
used the join method before, basically what
this does is it says, Take all of the elements

716
01:01:00,519 --> 01:01:05,700
of this and join them together by separating
them with this. So to see that in action,

717
01:01:05,700 --> 01:01:14,650
we'll just do print symbol, strings. Strings
at index i. Alright, so here's one example.

718
01:01:14,650 --> 01:01:18,839
Here's another example. And you can tell these
examples apart. Because at the end of the

719
01:01:18,839 --> 01:01:24,200
line, there's a gap. Sorry, this is one example,
I had one extra line there, you can see this

720
01:01:24,200 --> 01:01:28,450
example ends there because there's a gap.
And it starts on the line after this, because

721
01:01:28,450 --> 01:01:32,890
this is the last line of the first example.
So there we have our five lists of symbol

722
01:01:32,890 --> 01:01:35,250
strings, I'm going to comment this out, because
we don't want that printing every time we

723
01:01:35,250 --> 01:01:41,269
run this code. So the next thing we need to
do is create a blank final data frame again.

724
01:01:41,269 --> 01:01:44,229
So we're using the same variable name, which
probably not a good practice, but we're overriding

725
01:01:44,229 --> 01:01:48,930
it each time. So equals P dot data, frame,
and columns equals my columns, you guys know

726
01:01:48,930 --> 01:01:58,069
the drill by now. Now, let's just print out
to make sure that it looks okay. Awesome,

727
01:01:58,069 --> 01:02:12,900
so we can delete this out. Okay, the next
thing we need to do is loop through every

728
01:02:12,900 --> 01:02:18,319
string in our symbol strings object, and then
use that string to execute a batch API request.

729
01:02:18,319 --> 01:02:27,989
So we're gonna use a for loop for this. And
to keep the, the nomenclature pretty simple,

730
01:02:27,989 --> 01:02:40,200
we're going to just say for symbol string,
in symbol, strings. And then we can actually

731
01:02:40,200 --> 01:02:47,789
print these out to make sure that this is
working right. Simple string. Awesome, that

732
01:02:47,789 --> 01:02:51,529
looks good. We're going to take away that
print statement now. And then we need to create

733
01:02:51,529 --> 01:02:59,180
a batch API call URL. And as before, this
is going to be an F string where we pass in

734
01:02:59,180 --> 01:03:06,180
the the base URL of the API endpoint, and
then pass in all of the strings through for

735
01:03:06,180 --> 01:03:12,390
each of these symbol strings into the endpoint
to get 100 to get data for 100 stocks back.

736
01:03:12,390 --> 01:03:17,001
Now, if you've never run a batch API call
through is called before you probably are

737
01:03:17,001 --> 01:03:21,749
unsure how to do this, let's just go to the
docks here and do a Ctrl F for batch and see

738
01:03:21,749 --> 01:03:34,270
what comes up batch requests. Okay. So 
So what it says here is that use market to

739
01:03:34,270 --> 01:03:38,970
query multiple symbols, okay, so this is what
we want this stock market. And then, as you

740
01:03:38,970 --> 01:03:43,849
can see, you pass in one of the parameters
as symbols equals a comma separated value

741
01:03:43,849 --> 01:03:48,540
of symbols, and then types equals a comma
separated value of API endpoints that you

742
01:03:48,540 --> 01:03:53,510
want to hit. And then if applicable range
tells you how much data to pull for. And then

743
01:03:53,510 --> 01:03:57,019
at the very end of this, you would pass on
your token as well. Because we're going to

744
01:03:57,019 --> 01:04:03,709
do is oops, did not mean to click that. What
we're going to do is copy this, go back to

745
01:04:03,709 --> 01:04:08,000
our Jupyter Notebook. We're going to pass
that in here for now. And then we're going

746
01:04:08,000 --> 01:04:13,789
to scroll up to our last API call and get
this base URL, including the stable that I

747
01:04:13,789 --> 01:04:21,410
missed earlier. We're going to copy this here.
We're going to delete the double forward slash.

748
01:04:21,410 --> 01:04:25,660
And then we're going to move over to the end
of the API call and change a few things. So

749
01:04:25,660 --> 01:04:30,549
the first thing we're going to do is remove
this last parameter and this range parameter.

750
01:04:30,549 --> 01:04:34,220
We don't need those for the API call that
we're doing. The next thing we're going to

751
01:04:34,220 --> 01:04:38,809
do is remove the chart and news endpoint from
that example, because we don't need them.

752
01:04:38,809 --> 01:04:43,630
Next, we're going to actually remove these
symbols that are hard coded into this, we're

753
01:04:43,630 --> 01:04:50,829
going to do a variable interpolation interpolation
for a symbol string. And then what we're going

754
01:04:50,829 --> 01:04:56,650
to do is move to the very end. And as before,
we can just copy on the IaaS cloud API token

755
01:04:56,650 --> 01:05:01,650
that we had in our original API call. So copy
this scroll. Like down, go to the end of the

756
01:05:01,650 --> 01:05:09,940
string and add it. Awesome. Now, let's just
do for symbol string and symbol string up

757
01:05:09,940 --> 01:05:14,440
to, but not including the first one. And then
we're going to just print this and see what

758
01:05:14,440 --> 01:05:27,740
it gives us. Oh, and I spelt that wrong here,
which I'm going to correct now. And then print

759
01:05:27,740 --> 01:05:31,849
API call URL. Now we're getting an error,
that API call URL is not defined. There's

760
01:05:31,849 --> 01:05:39,750
three L's here. That's why I run that again.
Alright, so this gives us a long URL that

761
01:05:39,750 --> 01:05:45,839
looks okay to me. One really easy way to test
this is to just click on it. It's a 400. Bad

762
01:05:45,839 --> 01:05:53,869
request. I'm not sure why. Stable slash stock
slash bash, let's make sure that that matches,

763
01:05:53,869 --> 01:06:08,470
slash stock market slash batch. Symbols equals
symbol string. Types equals one. Oh, so the

764
01:06:08,470 --> 01:06:13,160
problem here is that when you're passing on
multiple parameters to an API request, so

765
01:06:13,160 --> 01:06:17,690
this first character is a question mark, and
then every successive character that chains

766
01:06:17,690 --> 01:06:24,019
these parameters together needs to be an ampersand.
So we're going to copy this ampersand and

767
01:06:24,019 --> 01:06:28,910
replace this question mark with it. And I
think that should fix the problem. Great.

768
01:06:28,910 --> 01:06:33,459
So this is actually opened in a browser, the
JSON that is going to be returned from this

769
01:06:33,459 --> 01:06:39,089
API request. So now we can do what we did
before, use the requests library to get this

770
01:06:39,089 --> 01:06:47,890
data. So I'm gonna do data equals requests,
dot get, and then that URL. And then as before,

771
01:06:47,890 --> 01:06:52,039
we're going to pass the JSON method onto this.
Actually, before we do that, let's just do

772
01:06:52,039 --> 01:06:59,850
print data dot status code. So returns 200,
which means it's working properly. Now what

773
01:06:59,850 --> 01:07:07,240
we can do is pass the JSON method on to this
data variable. And then we need to parse data

774
01:07:07,240 --> 01:07:11,949
from this. So more specifically, we need to
parse data for every specific stock that's

775
01:07:11,949 --> 01:07:16,619
in this symbol string. Now the way to do this
is just like before, how we use this join

776
01:07:16,619 --> 01:07:22,579
method to join together all of the different
strings that were contained in that list,

777
01:07:22,579 --> 01:07:26,849
you can use the split method to basically
do the opposite. So we can say, or symbol

778
01:07:26,849 --> 01:07:36,609
in symbol, string dot split, and we're going
to split on the comma character. Let's just

779
01:07:36,609 --> 01:07:42,099
print every symbol and see what happens. Awesome.
So it looks like it's successfully looping

780
01:07:42,099 --> 01:07:47,589
through all of the first 100 stocks there.
And what we need to do now is parse the batch

781
01:07:47,589 --> 01:07:52,609
API call for data for every specific stock
in the order that we need, and then append

782
01:07:52,609 --> 01:07:56,479
that data to the panda's data frame. So just
like before, we're going to use the append

783
01:07:56,479 --> 01:08:04,999
method, we're gonna say final data frame,
equals final data frame, dot append. And then

784
01:08:04,999 --> 01:08:10,219
in here, we're going to specify that it's
a panda's series. And inside the pandas series,

785
01:08:10,219 --> 01:08:13,809
we're going to pass in a Python list. So all
of that is exactly what we did before. So

786
01:08:13,809 --> 01:08:18,750
I kind of skipped over it. And then here,
we're going to pass in the same for variable,

787
01:08:18,750 --> 01:08:25,460
so symbol, and then price, which will be data.
And then we have to do actually multiple levels

788
01:08:25,460 --> 01:08:30,210
of parsing this time, because not only do
we have to parse the metric for that stock,

789
01:08:30,210 --> 01:08:35,330
but we also have to parse the batch API call
to get the information for that specific stock.

790
01:08:35,330 --> 01:08:44,020
So here's how you do that. We do symbol, and
then quote, so this is the stock and then

791
01:08:44,020 --> 01:08:51,370
the endpoint, and then we need to parse out
the metric latest price. And we can follow

792
01:08:51,370 --> 01:09:03,730
similar logic here to get 
the market capitalization. So market cap,

793
01:09:03,730 --> 01:09:08,150
and then just like before, we are going to
not specify the last column, we will calculate

794
01:09:08,150 --> 01:09:14,000
that later. Let's run this and see what happens.
Actually, I'm going to add one last line to

795
01:09:14,000 --> 01:09:19,460
this set print scalar data frame. All right,
let's run this and see what happens. Type

796
01:09:19,460 --> 01:09:28,170
error can only append a series. This is that
ignore index specification that I mentioned

797
01:09:28,170 --> 01:09:32,359
earlier. So that needs to get added in right
here. And actually now that I think about

798
01:09:32,359 --> 01:09:42,150
it, inside this pandas series class instantiation,
we need to pass in index equals my columns.

799
01:09:42,150 --> 01:09:49,339
Alright, let's try this. Invalid index index
and ignore index equals true. I'm missing

800
01:09:49,339 --> 01:09:54,440
a comma there. One more time. Awesome. So
as you can see, we've successfully upended

801
01:09:54,440 --> 01:10:00,240
the ticker, the stock price, the market capitalization
and the number of shares to buy the only other

802
01:10:00,240 --> 01:10:05,080
Change we have to make this code sell is to
remove this little appendage right here, that

803
01:10:05,080 --> 01:10:08,540
made it loop only over the first instance.
So now when we run this, it will actually

804
01:10:08,540 --> 01:10:13,560
loop over every single string and add every
stock within our list to our panda's data

805
01:10:13,560 --> 01:10:21,620
frame. So let's try that. Awesome. As you
can see, that was way, way faster than using

806
01:10:21,620 --> 01:10:25,310
individual API calls for each stock, the other
one took probably two or three minutes. And

807
01:10:25,310 --> 01:10:31,210
that was only a few seconds. So huge improvement
there. I mean, in theory, if all the API requests

808
01:10:31,210 --> 01:10:34,500
take the same amount of time using batch API
call should make it 100 times faster because

809
01:10:34,500 --> 01:10:40,010
it does one call for every 100 stocks, but
anyways, much faster in any case, and it looks

810
01:10:40,010 --> 01:10:45,030
like we go all the way from A to Z, all the
data looks okay, so we're ready to proceed

811
01:10:45,030 --> 01:10:50,260
to calculating the number of shares to buy.
Alright, so the reason why we left this calculating

812
01:10:50,260 --> 01:10:55,600
the number of shares to buy step until later
in the script is because I want this to actually

813
01:10:55,600 --> 01:11:00,140
work regardless of how big your portfolio
is. So how we're going to handle that is,

814
01:11:00,140 --> 01:11:03,640
we're going to create a Python input that
says how large is your portfolio, and then

815
01:11:03,640 --> 01:11:07,690
based on what you tell Python, it will calculate
the number of shares to buy accordingly. So

816
01:11:07,690 --> 01:11:11,920
to do that, we're going to use pythons input
function. And more specifically, we're gonna

817
01:11:11,920 --> 01:11:16,750
say, portfolio size is equal to input. And
then inside this input, it accepts a string.

818
01:11:16,750 --> 01:11:22,120
And that string is kind of what question you
want, Python asked you. So here's how it's

819
01:11:22,120 --> 01:11:32,980
the looks, enter the value of your portfolio.
Now if we run this, you can see there's an

820
01:11:32,980 --> 01:11:37,770
input that says enter the value of your portfolio,
we can write, you know, $1,000. And then we

821
01:11:37,770 --> 01:11:43,440
can access that value later on in the script.
So now, if we do, you know, portfolio size,

822
01:11:43,440 --> 01:11:48,980
it'll print out 1000. Note that this is actually
a string. So that fact that this accepts a

823
01:11:48,980 --> 01:11:52,550
string is actually something we need to make
sure we handle because since it's a string,

824
01:11:52,550 --> 01:11:57,980
you could say I don't have a portfolio. And
that would actually kind of break the rest

825
01:11:57,980 --> 01:12:01,180
of this script, because it's going to try
to do mathematical operations on this string,

826
01:12:01,180 --> 01:12:06,290
which is obviously impossible. So what we
need to do is create kind of a try accept

827
01:12:06,290 --> 01:12:11,290
statement. So if you're not familiar with
try accept, basically, the way these work

828
01:12:11,290 --> 01:12:16,480
is, try except, you could say, try to do this.
And if this doesn't work, it will do whatever

829
01:12:16,480 --> 01:12:22,660
is specified here. So one example would be
like, if you say, two plus n, and is not defined,

830
01:12:22,660 --> 01:12:28,590
so then it will print out, you know, and is
not fine. We're going to comment this out,

831
01:12:28,590 --> 01:12:32,820
so it doesn't run. Now if we run this, it
should print n is not defined. Awesome. Now,

832
01:12:32,820 --> 01:12:39,380
if we say two plus two, it will doesn't print
it. But if we wrapped it in a print statement

833
01:12:39,380 --> 01:12:45,600
would four, okay, so we're going to use this
same logic to handle the fact that people

834
01:12:45,600 --> 01:12:52,090
might not put number variables into this portfolio
size input. So the first thing to do is uncomment.

835
01:12:52,090 --> 01:12:59,360
This, the next thing we need to do is to try
to kind of handle our input as a float variable.

836
01:12:59,360 --> 01:13:02,690
So to do that, we're just gonna create a variable
called Val. And we're going to say that's

837
01:13:02,690 --> 01:13:12,390
equal to float, portfolio size. Now, this
float function is basically going to take

838
01:13:12,390 --> 01:13:21,030
this portfolio size variable and try to force
it to be a float. So if we say, print vow,

839
01:13:21,030 --> 01:13:30,030
actually, no ignore that we're going to do
is put that in here and say, print vow. And

840
01:13:30,030 --> 01:13:37,900
then for this, except we're going to say,
Please enter an integer. Now, if we put in

841
01:13:37,900 --> 01:13:46,100
a sentence will say, again, I don't have a
portfolio returns, please enter an integer.

842
01:13:46,100 --> 01:13:53,340
Now, this broad try accept statement is actually
not good. And the reason why is because this

843
01:13:53,340 --> 01:13:57,460
will react regardless of what type of error
is happening. So what we need to do to make

844
01:13:57,460 --> 01:14:02,210
sure that it only handles this specific type
of error that we're trying to address is we

845
01:14:02,210 --> 01:14:09,020
need to try to do this and kind of force an
error. So we'll put a string in there. And

846
01:14:09,020 --> 01:14:15,190
then as you can see, the type of error that's
created is a value error. So we need to basically

847
01:14:15,190 --> 01:14:20,020
change this script so that it only reacts
to value errors instead of reacting to all

848
01:14:20,020 --> 01:14:26,920
types of errors. And the way that you do that
is you put the type of error right here and

849
01:14:26,920 --> 01:14:33,670
run this again and see that it does handle
this properly. Okay, so what we want to do

850
01:14:33,670 --> 01:14:40,560
now is instead of just handling this, instead
of just handling this and saying please enter

851
01:14:40,560 --> 01:14:48,090
an integer, we need to actually make it redo
this. So how does this look? Please enter

852
01:14:48,090 --> 01:15:00,000
an integer. All we want to do is say in here,
enter the value of your portfolio. And then

853
01:15:00,000 --> 01:15:04,590
above this, we want to tell them exactly why
they're getting this input prompt again. So

854
01:15:04,590 --> 01:15:13,150
we're going to print and say, That's, please
double brackets, that's not a number, and

855
01:15:13,150 --> 01:15:25,900
then four slash, and so that'll create a new
line, please. Please try again. And then now

856
01:15:25,900 --> 01:15:34,230
equals float. Awesome. So just to recap, we
try to get the value of someone's portfolio

857
01:15:34,230 --> 01:15:40,350
using the input function. In the first step
of the try accept block, we try to force that

858
01:15:40,350 --> 01:15:46,580
that that input ID value to be a flow variable
and assign it to a variable called Val. If

859
01:15:46,580 --> 01:15:50,880
that doesn't work, because of a value error,
then we print down, that's not a number, please

860
01:15:50,880 --> 01:15:54,870
try again. And then we prompt them to enter
the value of their portfolio again, and then

861
01:15:54,870 --> 01:16:00,520
we, we force it to be a strongly typed float
again. Now, one interesting thing to note

862
01:16:00,520 --> 01:16:06,290
about this is that if you do it twice, string,
and then string, it will still trigger a value

863
01:16:06,290 --> 01:16:10,580
error. So you need to kind of rely that the
user of this script is going to be like, I

864
01:16:10,580 --> 01:16:15,300
guess, astute enough to not enter a string
twice. So it might look something like this,

865
01:16:15,300 --> 01:16:22,340
they go and say, enter the value of your portfolio
$1,000. And they say, That's not a number,

866
01:16:22,340 --> 01:16:26,210
please try again. So then you say, Oh, it's
$1,000. And then you can proceed through the

867
01:16:26,210 --> 01:16:30,480
rest of the script. Okay, so now that we've
accepted the number from the user of this

868
01:16:30,480 --> 01:16:36,000
script, we need to actually use that number
to base our share calculations on now since

869
01:16:36,000 --> 01:16:41,460
this is equal weight, every stock in the portfolio
will have the same position size and position

870
01:16:41,460 --> 01:16:45,580
size is kind of just a fancy financial term
that says how much money you're going to invest

871
01:16:45,580 --> 01:16:50,940
in each stock now, Center's 505. Stocks, an
easy example would be if your portfolio is

872
01:16:50,940 --> 01:16:56,130
$505,000, all you would do is invest $1,000
in each stock. So as you can see, the easiest

873
01:16:56,130 --> 01:17:05,000
way to calculate that is just to say, position
size, is equal to the value divided by the

874
01:17:05,000 --> 01:17:09,130
length of any column from the final data frame.
So in this case, we'll just do final data

875
01:17:09,130 --> 01:17:17,610
frame dot index, and then print position size.
This says, We made a small portfolio here

876
01:17:17,610 --> 01:17:24,010
of $1,000. So it's just you know, saying give
us $1.98 in each stock, let's use something

877
01:17:24,010 --> 01:17:30,901
more reasonable, like a million dollars. Awesome.
So now saying invest, you know, $19,000 in

878
01:17:30,901 --> 01:17:35,730
each stock, that sounds about right to me,
Oh, hang on, is this a million or 123, that's

879
01:17:35,730 --> 01:17:41,880
10 million. So $19,000 in each stock, or almost
20,000 makes sense for a $10 million portfolio.

880
01:17:41,880 --> 01:17:47,210
Alright, so we have the position size now.
Now we need to calculate how many shares of

881
01:17:47,210 --> 01:17:53,130
each stock need to be purchased to get to
that position size in that stock. So let's

882
01:17:53,130 --> 01:17:59,080
take an easy example. Apple stock price is
about $500. Right now. So if we wanted, you

883
01:17:59,080 --> 01:18:08,540
know, number of Apple shares to buy, you would
just say, position, size divided by Apple

884
01:18:08,540 --> 01:18:16,180
stock price, which is $500. ish. And then
you can print the number of Apple shares.

885
01:18:16,180 --> 01:18:22,190
And in this case, it says, okay, buy 39.6
Apple shares. Now, this introduces an interesting

886
01:18:22,190 --> 01:18:26,710
concept in that a lot of places do not support
fractional trading, which means that you can

887
01:18:26,710 --> 01:18:31,410
buy a portion of a share, you can only buy
whole shares. So you can buy 39 shares, or

888
01:18:31,410 --> 01:18:37,550
you can buy 40 shares, but you cannot buy
39.6 shares. So how do we handle this? Well,

889
01:18:37,550 --> 01:18:41,960
it's tempting to just say, let's round it
to the closest number up or down. But what

890
01:18:41,960 --> 01:18:47,960
might happen then is that if you are rounding
up more integers than you're rounding down,

891
01:18:47,960 --> 01:18:51,310
you'll actually end up buying more stock than
you have money for. And that is not a good

892
01:18:51,310 --> 01:18:55,390
thing, you would get to the end of your allocation
and say, oh, man, I don't actually have enough

893
01:18:55,390 --> 01:19:00,420
money left over to get to my position size
target on this stock. So because of that,

894
01:19:00,420 --> 01:19:04,730
we actually have to round each of these down.
And that's where that math module that we

895
01:19:04,730 --> 01:19:11,301
imported earlier comes in. So math dot floor
is pythons round down function. So if we print

896
01:19:11,301 --> 01:19:15,410
this, that should give us 39. Oh, shoot, math
is not defined. I think it might be lowercase

897
01:19:15,410 --> 01:19:21,790
n. Yeah, math floor. So that gives us 39.
Okay, so this is kind of like the logical

898
01:19:21,790 --> 01:19:26,210
intuition on how to do this, we now need to
programmatically loop through every row of

899
01:19:26,210 --> 01:19:33,470
our panda's data frame, and actually apply
this logic to the number of shares by column.

900
01:19:33,470 --> 01:19:37,260
Now to do this, I'm just going to comment
that out because it'll be useful for us later.

901
01:19:37,260 --> 01:19:43,460
Alright, so we're going to say for i in range
from zero, and then we needed to go to the

902
01:19:43,460 --> 01:19:47,700
last row of the data frame, and the easiest
way to do that is just say the length of any

903
01:19:47,700 --> 01:19:54,860
row within the data frame. What I typically
use is final data frame index. As you can

904
01:19:54,860 --> 01:20:00,720
see, this logic is actually basically what
I used here as well. So Let's use this and

905
01:20:00,720 --> 01:20:10,191
then just print everything in here. All right,
this goes from goes from zero to 504. Let's

906
01:20:10,191 --> 01:20:13,780
just make sure that adds up with the data
frame we clicked earlier or printed earlier,

907
01:20:13,780 --> 01:20:20,520
I should say, it goes from zero to 504. Awesome.
Now, we need to access this cell in each row

908
01:20:20,520 --> 01:20:24,510
of the data frame. The easiest way to do that
is using the LLC method. So what we're gonna

909
01:20:24,510 --> 01:20:32,100
do is, say final data frame, dot LLC. And
this is a basically like an easy row column

910
01:20:32,100 --> 01:20:39,840
way of accessing data in pandas. So for the
row, we're going to say I and for the column,

911
01:20:39,840 --> 01:20:45,630
we're going to say, the number of shares to
buy. And let's just print this to see if it

912
01:20:45,630 --> 01:20:52,420
prints a bunch of Ma, because that's what
it should print. Awesome. So we're correctly

913
01:20:52,420 --> 01:20:56,950
accessing the data. Now we need to actually
assign the data. So to do that, you can just

914
01:20:56,950 --> 01:21:03,650
use the equality operator and then say, math
dot floor. And then we need to do basically

915
01:21:03,650 --> 01:21:11,400
this calculation here, position size divided
by the stock price. So we'll say, position,

916
01:21:11,400 --> 01:21:15,670
size divided by now what are we going to do
for stock price? Do we have to execute another

917
01:21:15,670 --> 01:21:22,460
API call and pull that data from IE x again,
we actually don't and the reason why is because

918
01:21:22,460 --> 01:21:27,191
that data is already stored in the panda's
data frame. So we can take similar logic to

919
01:21:27,191 --> 01:21:35,800
this LFC method here and put that there, paste
it, and just change this to stock. Price.

920
01:21:35,800 --> 01:21:45,020
Oh, this tab, autocomplete is not working.
So if we run this, what happens? It ran correctly.

921
01:21:45,020 --> 01:21:53,121
Let's do this again, and print the data frame
to see if it looks okay. Awesome. So as you

922
01:21:53,121 --> 01:21:57,690
can see, it correctly kind of shows the number
of shares to buy here. One easy way to fact

923
01:21:57,690 --> 01:22:01,170
check this, well, there's a couple things
you knew, the first thing is to say, Okay,

924
01:22:01,170 --> 01:22:05,650
this apple stock price is close to the 39
that we calculated earlier. So that's a good

925
01:22:05,650 --> 01:22:10,480
sign. Another thing you can do is say, look
at two stocks that have different stock prices,

926
01:22:10,480 --> 01:22:15,140
and the one that has the higher stock price
should be recommended to buy less shares than

927
01:22:15,140 --> 01:22:18,930
one that has a lower stock price. So let's
just use the first two rows of this data frame

928
01:22:18,930 --> 01:22:25,570
as an example, you can see that for this stock
with ticker a, it costs $100 to buy it and

929
01:22:25,570 --> 01:22:29,770
you're buying 197. And then the second stock
has a much lower stock price. And because

930
01:22:29,770 --> 01:22:34,960
of that, you have to buy many more shares
to actually reach your target position size.

931
01:22:34,960 --> 01:22:38,270
Now, that kind of all looks good. So we can
move on, I'm going to take away this comment

932
01:22:38,270 --> 01:22:43,300
code and just tidy this up a little bit. And
we can proceed to the next cell. All right.

933
01:22:43,300 --> 01:22:47,430
So this brings us to the last section of this
project, which is to save our panda's data

934
01:22:47,430 --> 01:22:53,190
frame into an XLS. x file for non technical
users to access to excel. So the big idea

935
01:22:53,190 --> 01:22:57,680
here is that we did all the work in a Python
script, you could schedule the script to run

936
01:22:57,680 --> 01:23:01,450
periodically, and then the output would be
sent to your trading team to actually buy

937
01:23:01,450 --> 01:23:06,490
and sell stocks in response to the output.
So to do this, we're going to use the XLS

938
01:23:06,490 --> 01:23:10,890
x writer library for Python. Now, oops, the
new mean remnant. If you remember, at the

939
01:23:10,890 --> 01:23:15,530
start of this project, many lines of code
ago, we actually imported this here. So it's

940
01:23:15,530 --> 01:23:20,770
actually in our script already, we just need
to use it now to save our data frame as an

941
01:23:20,770 --> 01:23:27,070
Excel file. Now XLS x writer is an excellent
package and offers an insane amount of customization.

942
01:23:27,070 --> 01:23:31,190
But the trade off for this is that the library
can seem a bit complex to new users, I'm going

943
01:23:31,190 --> 01:23:35,370
to do my best to explain it well throughout
this section. And because of that, this might

944
01:23:35,370 --> 01:23:41,100
be a bit long. So if this seems easy, or you've
used that asset, if this seems easy, or you've

945
01:23:41,100 --> 01:23:45,370
used XLS x writer in the past, you can feel
free to speed up the speed here a bit or skip

946
01:23:45,370 --> 01:23:50,240
ahead. Alright, so the first thing we need
to do is actually initialize our XLS x writer

947
01:23:50,240 --> 01:23:56,990
object. And the way that we do that is by
saying writer equals PD dot XML writer. And

948
01:23:56,990 --> 01:24:00,600
then here, we need to pass in the file name
that we want to save to in this case, we're

949
01:24:00,600 --> 01:24:06,380
going to do recommended trades dot XLS x.
And then we need to specify the engine, which

950
01:24:06,380 --> 01:24:11,060
is XLS x writer. Now, let's break this down
a little bit to kind of describe what's going

951
01:24:11,060 --> 01:24:16,250
on here. As you can see, the class that we're
initializing here is from the pandas library,

952
01:24:16,250 --> 01:24:21,500
and not actually from XLS x writer. And the
reason why that is, is because since pandas

953
01:24:21,500 --> 01:24:25,841
deals with tabular data, and so much tabular
data is actually saved to Excel files. They

954
01:24:25,841 --> 01:24:31,330
have a very tightly coupled integration. And
it actually kind of is easiest to initialize

955
01:24:31,330 --> 01:24:36,490
a new writer object from pandas rather than
XLS x writer and kind of by default, you always

956
01:24:36,490 --> 01:24:41,590
save these objects to a variable called writer.
It allows you to reuse your code without having

957
01:24:41,590 --> 01:24:45,490
to change the object name later and it's kind
of just a best practice. So when I say writer

958
01:24:45,490 --> 01:24:52,030
equals P dot x, x l writer, and then this
is the filename that we want to save to and

959
01:24:52,030 --> 01:24:58,190
then the engine equals XLS x writer. It may
seem a bit redundant, but this library can

960
01:24:58,190 --> 01:25:03,360
also be used to Save XML file. So we have
to actually specify that we want to work in

961
01:25:03,360 --> 01:25:06,350
Excel. So that's the first thing we need to
do. The next thing we need to do is actually

962
01:25:06,350 --> 01:25:12,130
to pass our panda's data frame into this object
in specify which tab of the Excel file we

963
01:25:12,130 --> 01:25:18,710
want it to be saved to. So to do that, we
do final data frame.to Excel. And then the

964
01:25:18,710 --> 01:25:22,370
first thing we pass in is that writer object.
The next thing we pass in is the name of the

965
01:25:22,370 --> 01:25:27,120
tab we want it to be saved to so we'll say
recommended trade again. And the last thing

966
01:25:27,120 --> 01:25:34,730
we pass in is an index equals false argument.
Alright, so our object has been created. The

967
01:25:34,730 --> 01:25:40,000
next thing we need to do is to create the
format's we need for our XLS x file. Now,

968
01:25:40,000 --> 01:25:43,870
earlier when I said that this library can
be confusing or complicated to new users,

969
01:25:43,870 --> 01:25:48,980
this is where it gets really, really complicated.
Formatting Excel files with XLS x writer is

970
01:25:48,980 --> 01:25:52,890
a science and there's a lot to it. But I'm
going to try to keep things simple here. And

971
01:25:52,890 --> 01:25:56,520
hopefully, you guys won't run into any hiccups.
First things we're going to do is create,

972
01:25:56,520 --> 01:26:01,750
I guess, two variables that specify the color
scheme for our Excel sheet. And then we will

973
01:26:01,750 --> 01:26:06,141
reference those variables in all the formats
that we create later on. So that if we want

974
01:26:06,141 --> 01:26:09,621
to change one color, it will be reflected
across all the different formats that we create

975
01:26:09,621 --> 01:26:12,770
later, instead of hard coding them in and
having to change many different instances

976
01:26:12,770 --> 01:26:19,400
have a specific color. So specifically, what
we're going to create is a background color

977
01:26:19,400 --> 01:26:24,560
variable and a font color variable. So background
color, and these are just going to be empty

978
01:26:24,560 --> 01:26:31,900
strings for now. font color. Alright, so what
goes in here, these actually store the HTML

979
01:26:31,900 --> 01:26:36,410
hex codes for the very first for the colors
that we want to select. So I'm going to use

980
01:26:36,410 --> 01:26:40,620
two colors that kind of match the style of
the Free Code Camp website, I really like

981
01:26:40,620 --> 01:26:43,650
it, it's command line chic, and very modern.
So we're just going to follow that to make

982
01:26:43,650 --> 01:26:53,040
things easy, the background color is going
to be zero, a zero, a two, three, and the

983
01:26:53,040 --> 01:27:01,330
font color is going to be at six s. Alright,
so that's that. Now we need to actually create

984
01:27:01,330 --> 01:27:07,390
a few different formats that we will be referencing
when we actually apply the format's to our

985
01:27:07,390 --> 01:27:13,250
cells in our Excel sheet later on. So as you
can see up here, we need a string format $1

986
01:27:13,250 --> 01:27:17,500
format with decimals, $1 format without decimals
and an integer format. So let's start with

987
01:27:17,500 --> 01:27:29,380
string format. And then what we're going to
do here is create a writer dot buck dot add

988
01:27:29,380 --> 01:27:34,580
format method. Inside this add format method,
we have to create a dictionary. And this dictionary

989
01:27:34,580 --> 01:27:40,800
specifies the format of the cells that are
going to have this applied to them later.

990
01:27:40,800 --> 01:27:49,500
So what goes in here, there's three main attributes
on color, background, color, and border. Now

991
01:27:49,500 --> 01:27:53,850
each of these should actually be strings,
I'm going to fix that indenting issue. Since

992
01:27:53,850 --> 01:27:59,610
this is a dictionary, what is going on, I
find the indenting on Jupyter Notebooks leaves

993
01:27:59,610 --> 01:28:05,670
a lot to be desired. Since this is a dictionary,
these should be strings. And we have to add

994
01:28:05,670 --> 01:28:13,240
colons to each one. All right, so the font
color is going to be font color. And this

995
01:28:13,240 --> 01:28:18,840
font color variable is what we defined up
here, this background color is going to be

996
01:28:18,840 --> 01:28:23,630
background color. And this border is going
to be one, this just means that a solid border

997
01:28:23,630 --> 01:28:28,300
around each one now. This is our first one,
let's run this code to make sure it works

998
01:28:28,300 --> 01:28:33,220
properly. Awesome. Now we need to basically
template off of this and create a few other

999
01:28:33,220 --> 01:28:40,710
formats. So we have string format, and we
need to name the other ones that we described

1000
01:28:40,710 --> 01:28:54,310
before this code cell is a string format,
dollar format, and in integer format, now,

1001
01:28:54,310 --> 01:29:00,640
all of these are going to share the same attributes
that the string format specified, we just

1002
01:29:00,640 --> 01:29:05,330
need to add a few things to each one. So for
dollar format, we need to specify a number

1003
01:29:05,330 --> 01:29:12,290
format attribute like this. And the way that
this works is actually pretty easy. You just

1004
01:29:12,290 --> 01:29:15,900
pass in a number with zeros in it templated
the way that you want it to be formatted.

1005
01:29:15,900 --> 01:29:21,670
So in this case, it will look like that. And
then we will do the same thing for the integer

1006
01:29:21,670 --> 01:29:30,650
format. So num format and then we're just
going to say zero. Awesome. Let's run this

1007
01:29:30,650 --> 01:29:35,800
code cell to make sure there's no syntax errors.
Excellent. Alright, so now we need to apply

1008
01:29:35,800 --> 01:29:41,030
the format that we just created to our XLS
x file. And this is like a big complicated

1009
01:29:41,030 --> 01:29:46,300
so what I did here was I actually provided
an example and we can kind of use this to

1010
01:29:46,300 --> 01:29:51,110
template on for all of the columns in our
sheet. So what we need to do is say writer

1011
01:29:51,110 --> 01:29:57,190
dot sheets, and then parse out the recommended
trade sheet from an object. And then we use

1012
01:29:57,190 --> 01:30:01,340
the set column method on that item to success.
To find information about the column we're

1013
01:30:01,340 --> 01:30:05,400
doing now, we're gonna do this one by one
first, and then we're going to kind of put

1014
01:30:05,400 --> 01:30:08,970
everything into a loop because it'll be a
bit more efficient on code and much more readable.

1015
01:30:08,970 --> 01:30:13,190
So let's start with column A. And you actually
can't just put a, you have to put a through

1016
01:30:13,190 --> 01:30:17,800
a like that. So that tells you the column.
And then we need to specify the column width,

1017
01:30:17,800 --> 01:30:21,940
let's do 18 pixels. And then you need to say
which format you want to apply to it. Column

1018
01:30:21,940 --> 01:30:26,440
A is our ticker format. So we need string
format, it's not a number. Now, if you run

1019
01:30:26,440 --> 01:30:30,940
that, it returns zero. And that basically
tells you that it ran properly, the way to

1020
01:30:30,940 --> 01:30:35,110
actually see this in action is you need to
actually save your writer object. Now, to

1021
01:30:35,110 --> 01:30:40,110
do that, you say writer dot save. And then
if you go to your working directory, where

1022
01:30:40,110 --> 01:30:45,670
you're running through this, you should be
able to open up your recommended trades. Excel

1023
01:30:45,670 --> 01:30:49,540
file and see that the first column has actually
been formatted properly. So let's do that

1024
01:30:49,540 --> 01:30:54,310
for all the other columns. And then we can
change a couple things to make it formatted

1025
01:30:54,310 --> 01:30:59,880
better. So how to do this, we'll just copy
this a few times and change the letter four

1026
01:30:59,880 --> 01:31:06,800
times to be specific. So this should be B
for me, this should be C for C, and this should

1027
01:31:06,800 --> 01:31:15,030
be d3, D. Now let's run this and see that
what happens to the Excel sheet. Only one

1028
01:31:15,030 --> 01:31:23,510
was formatted. Why is that? These? Oh, I think
we have to go back here and re initialize

1029
01:31:23,510 --> 01:31:33,420
this. Alright, let's try now. Awesome. So
as you can see, the columns are being formatted

1030
01:31:33,420 --> 01:31:37,511
properly, but the headers aren't. Just so
you know, we're gonna solve that later. It's

1031
01:31:37,511 --> 01:31:42,920
not something that I'm ignoring. But we will
solve that in a few cells. So what we need

1032
01:31:42,920 --> 01:31:47,110
to do now is we're going to simplify this
by making two loops. And each of those loops

1033
01:31:47,110 --> 01:31:50,510
is going to work with this column format,
a dictionary that we're going to create. So

1034
01:31:50,510 --> 01:31:56,130
let's create column format, and make a dictionary.
Now what this dictionary is going to be is

1035
01:31:56,130 --> 01:32:08,240
it's going to have a key for each column.
So A, B, C, and D. and the value for each

1036
01:32:08,240 --> 01:32:12,560
column is going to be a list inside that list,
the first item is going to be the title. And

1037
01:32:12,560 --> 01:32:19,320
the second item is going to be which format
we want to apply. format. It's a ticker string

1038
01:32:19,320 --> 01:32:43,280
format, and then stock price, dollar format,
comma, their market cap. And the last one

1039
01:32:43,280 --> 01:32:54,650
is going to be number of shares to buy and
integer format. So let's run that sudden,

1040
01:32:54,650 --> 01:32:59,800
that cell ran correctly, which tells you that
that dictionary is formatted properly. And

1041
01:32:59,800 --> 01:33:03,610
now we're ready to start building a couple
of loops to do all of the work that we did

1042
01:33:03,610 --> 01:33:06,830
up here, but automatically, so the loop that
we're going to be building specifically is

1043
01:33:06,830 --> 01:33:13,350
going to loop through every key in that dictionary.
So when you say for column in column, format

1044
01:33:13,350 --> 01:33:19,750
stuff key, if you've never used the, the keys
method to iterate through a dictionary before,

1045
01:33:19,750 --> 01:33:24,850
it basically just returns all of these. So
we print the call and it should print ABCD.

1046
01:33:24,850 --> 01:33:34,030
Yep. Now what we need to do is create a writer
dot sheets, recommended trades dot set column,

1047
01:33:34,030 --> 01:33:42,090
we're basically doing all the work we did
up here. So set column. Here, we're going

1048
01:33:42,090 --> 01:33:51,650
to do an F string that interpolates in column,
column. So this would just be like for column

1049
01:33:51,650 --> 01:34:00,710
A would be a colon a, we're going to Ms string.
And then we're gonna do 18 pixels wide. And

1050
01:34:00,710 --> 01:34:09,020
then we're going to do column format, add
column. So this will be this dictionary at

1051
01:34:09,020 --> 01:34:14,010
key A. So this would return this list. And
then we need the second element of this list.

1052
01:34:14,010 --> 01:34:20,760
And since Python is zero index, three parts
one. Great, so that runs properly. Awesome.

1053
01:34:20,760 --> 01:34:27,600
So if you if we redo all of this to Okay,
here's we're going to do, we're going to comment

1054
01:34:27,600 --> 01:34:41,250
out this. We're going to put a writer dot
save method there. And then we're going to

1055
01:34:41,250 --> 01:34:46,670
go back to the start reinitialize, our writer
object and run all this code. Awesome. Let's

1056
01:34:46,670 --> 01:34:52,020
take a look and see what our Excel file looks
like. Great, so everything's being formatted

1057
01:34:52,020 --> 01:34:56,370
properly. In that loop. Our code is a lot
cleaner, it's easier to read. It's a big improvement.

1058
01:34:56,370 --> 01:35:01,750
Now what we need to do is handle these and
columns in XLS x right are kind of hard to

1059
01:35:01,750 --> 01:35:11,210
deal with, what I always do is I just overwrite
them. So writer dot sheets, recommended trades.

1060
01:35:11,210 --> 01:35:18,360
And then I do dot, right. And this right method
you pass in, what information you want stored

1061
01:35:18,360 --> 01:35:23,560
in the cell, and what format you want to apply
to that cell. You also need to specify the

1062
01:35:23,560 --> 01:35:28,830
location of the cell. So here's what we're
gonna do renew a one, we're gonna say ticker.

1063
01:35:28,830 --> 01:35:37,990
And we're gonna say string format. Now, if
we go back to the top again, reinitialize

1064
01:35:37,990 --> 01:35:45,870
this and run through the rest of this, and
go back to our cell file. The first cell is

1065
01:35:45,870 --> 01:35:49,630
formatted properly. So now we just need to
do the same thing for stock price market capitalization

1066
01:35:49,630 --> 01:35:54,281
and number of shares to buy. Let's go back,
easiest way to handle that is to just copy

1067
01:35:54,281 --> 01:36:02,620
and paste. So this will change to a one B
one note sorry, that should be a one or sorry,

1068
01:36:02,620 --> 01:36:14,190
a two or B one. B one, Okay, perfect. All
right, a one, B one, c one, D one. And this

1069
01:36:14,190 --> 01:36:31,260
will be stock price. With dollar format. This
will be market capital realization with dollar

1070
01:36:31,260 --> 01:36:44,230
format. And this will be number shares to
buy with integer format. Alright, as before,

1071
01:36:44,230 --> 01:36:48,750
we're going to go back to the top, we're going
to reinitialize, this Excel writer object,

1072
01:36:48,750 --> 01:36:54,140
run our code to the very end, and then take
another look at our Excel file. Awesome. So

1073
01:36:54,140 --> 01:36:57,350
everything looks formatted properly, the only
thing that might be worth improving is to

1074
01:36:57,350 --> 01:37:01,990
widen this a little bit. But I mean, anyone
who has an auto format or for Excel will be

1075
01:37:01,990 --> 01:37:07,390
able to handle that pretty easily. Alright,
so this violates the programming principle

1076
01:37:07,390 --> 01:37:11,210
of do not repeat yourself, this is very, very
loopable. So we're going to create another

1077
01:37:11,210 --> 01:37:16,980
loop here, that basically does this logic.
So Alright, so we're going to add this in

1078
01:37:16,980 --> 01:37:26,330
here. And what we need to do is, say, column
here, and convert this to an F string. So

1079
01:37:26,330 --> 01:37:32,680
as this loopster through this will go from
a one to B one to C one to D one. And then

1080
01:37:32,680 --> 01:37:41,530
we need to capture this value here. So it's
going to be column, column, format. So this

1081
01:37:41,530 --> 01:37:48,550
is the dictionary. And then we parse out columns.
So this is the value of a key value pair,

1082
01:37:48,550 --> 01:37:56,190
and then we want zero, and this will be the
first entry of the list, that is the value

1083
01:37:56,190 --> 01:38:00,740
in the key value pair. So that's this, and
then this needs to get replaced with the second

1084
01:38:00,740 --> 01:38:04,490
entry of the list. Easiest way to do that
is to just copy this and replace the zero

1085
01:38:04,490 --> 01:38:10,860
with a one. So let's go there, one. Alright,
as before, we're going to scroll all the way

1086
01:38:10,860 --> 01:38:17,280
up to the top reinitialize, our writer object,
move all the way through to the end. Let's

1087
01:38:17,280 --> 01:38:21,850
open this up and see if everything works.
Okay, great. So this is the final output of

1088
01:38:21,850 --> 01:38:27,520
the first project from this algorithmic trading
and Python course. It says here that the last

1089
01:38:27,520 --> 01:38:31,810
step is to save the writer output that's actually
this line. So we're already done. And just

1090
01:38:31,810 --> 01:38:35,530
like that, you built your first algorithmic
trading project in Python, I hope you had

1091
01:38:35,530 --> 01:38:38,348
fun, the next few projects are gonna be even
more often, you're going to learn a lot more.

1092
01:38:38,348 --> 01:38:42,720
So I hope you enjoy the rest of this course.
And kudos to you for sticking through it so

1093
01:38:42,720 --> 01:38:47,100
far. All right. So welcome to the second project
for this course, where we're going to build

1094
01:38:47,100 --> 01:38:51,200
a quantitative momentum strategy, what we
need to do to start just like before is we

1095
01:38:51,200 --> 01:38:56,730
need to open up our Jupyter Notebook. So here,
I'm here in my terminal in my home root directory,

1096
01:38:56,730 --> 01:39:00,940
and what I need to do is navigate into my
dev folder. And within that dev folder, I

1097
01:39:00,940 --> 01:39:04,680
need to navigate into algorithmic trading
in Python, which you can see here auto completed

1098
01:39:04,680 --> 01:39:08,950
for me, so we'll move into there. And now
that we're here, we need to activate our virtual

1099
01:39:08,950 --> 01:39:12,970
environment. So you'll remember from before
that the command to do that is source and

1100
01:39:12,970 --> 01:39:18,740
then V and V four slash bin forward slash
activate. If you look to the left and your

1101
01:39:18,740 --> 01:39:23,660
terminal command, here, you can see that that
V and V in parentheses there shows that the

1102
01:39:23,660 --> 01:39:27,160
virtual environment has been activated correctly,
and none of the virtual environment has been

1103
01:39:27,160 --> 01:39:32,210
activated. You can watch it with Python bash,
and a notebook that will launch a Jupyter

1104
01:39:32,210 --> 01:39:35,910
Notebook. Now, one thing that I'm not sure
I mentioned before is that you can deactivate

1105
01:39:35,910 --> 01:39:39,750
a virtual environment by simply typing deactivate.
And if you try to launch a Jupyter Notebook

1106
01:39:39,750 --> 01:39:45,090
with this, it will actually fail because it'll
say no module named notebook. So we need to

1107
01:39:45,090 --> 01:39:48,780
reactivate our virtual environment and then
launch our Jupyter Notebook. This will start

1108
01:39:48,780 --> 01:39:53,300
the server in our browser and we can get started.
Just like before, we're going to want to navigate

1109
01:39:53,300 --> 01:39:58,240
into starter files and then open up the second
project this time, which is quantitative momentum

1110
01:39:58,240 --> 01:40:04,260
strategy. So let's open that To get started.
Alright, so just like before, this Jupyter

1111
01:40:04,260 --> 01:40:09,220
Notebook starts with a bit of background information.
So it says momentum investing means investing

1112
01:40:09,220 --> 01:40:12,930
in the stocks that have increased in price
the most. For this project, we're going to

1113
01:40:12,930 --> 01:40:17,260
build an investing strategy that selects the
50 stocks with the highest price momentum.

1114
01:40:17,260 --> 01:40:20,540
From there, we will calculate recommended
trades for an equal weight portfolio of the

1115
01:40:20,540 --> 01:40:24,950
stock. So, this project will combine a lot
of the stuff that we used in the last section.

1116
01:40:24,950 --> 01:40:27,360
So that repetition will help you remember
what we actually just did, because I know

1117
01:40:27,360 --> 01:40:31,030
that that last project actually contain a
lot of stuff. And then we're going to build

1118
01:40:31,030 --> 01:40:35,790
on top of that by not just equal weighting
a already selected universe of stocks being

1119
01:40:35,790 --> 01:40:40,990
the s&p 500. But we're going to actually select
a subset of those stocks based on their momentum

1120
01:40:40,990 --> 01:40:47,440
characteristics. So let's get started by first
importing some libraries. Alright, so just

1121
01:40:47,440 --> 01:40:51,970
like before, we're gonna need NumPy, and we're
gonna import that as NP, we're gonna need

1122
01:40:51,970 --> 01:40:57,720
pandas, and we're gonna import that as PD.
So as a quick recap, NumPy is the best Python

1123
01:40:57,720 --> 01:41:02,260
library for numerical computing and pandas
is a Data Science Library that makes it very

1124
01:41:02,260 --> 01:41:06,720
easy to work with tabular data in Python,
you'll remember that we worked a bunch of

1125
01:41:06,720 --> 01:41:10,850
the PD dot data frame structure in the last
project. And we'll do the same thing in this

1126
01:41:10,850 --> 01:41:15,590
project. We're also going to need the requests
library for making HTTP requests, we're going

1127
01:41:15,590 --> 01:41:21,770
to need the math library for performing some
basic math functions. And we're going to need

1128
01:41:21,770 --> 01:41:26,850
the Sai pi library. Actually, we're not going
to need the whole library, we're just going

1129
01:41:26,850 --> 01:41:34,200
to need the stats library from Sai pi imports
that. And the last thing that we need is the

1130
01:41:34,200 --> 01:41:41,030
XLS. x writer library, which we saw in the
last section allows us to easily format and

1131
01:41:41,030 --> 01:41:44,800
save Excel files from a Python script. Now,
we've seen all of these before except for

1132
01:41:44,800 --> 01:41:50,340
the sci fi stats module. And what this does
is it makes it very easy to calculate percentile

1133
01:41:50,340 --> 01:41:53,590
scores. So we'll see later on in this project
that what we're actually going to do is we're

1134
01:41:53,590 --> 01:42:00,480
going to gather and parse momentum momentum
metrics for all of the stocks in our universe.

1135
01:42:00,480 --> 01:42:04,560
And then we're going to calculate percentile
scores for those momentum metrics, then we're

1136
01:42:04,560 --> 01:42:08,830
going to rank the stocks on those percentile
scores, and we're going to select the 50 stocks

1137
01:42:08,830 --> 01:42:14,030
that have the highest average percentile score
across a broad basket of momentum metrics.

1138
01:42:14,030 --> 01:42:17,640
So if you haven't seen side by stats, it's
pretty easy. We're just gonna use the percentile

1139
01:42:17,640 --> 01:42:22,020
score calculation feature of it. And yeah,
so that's it for our libraries, let's move

1140
01:42:22,020 --> 01:42:27,510
on to importing our list of stocks. So actually,
we should run this code sale first. Alright,

1141
01:42:27,510 --> 01:42:32,230
so now that our imports have been done for
our open source Python libraries, we need

1142
01:42:32,230 --> 01:42:37,570
to actually import our list of stocks. Now.
We also need to import our API token, we did

1143
01:42:37,570 --> 01:42:43,650
both of these steps in the last project as
well. So before I actually code this out,

1144
01:42:43,650 --> 01:42:48,650
try to go through and without looking at your
last one, figure out how to import your list

1145
01:42:48,650 --> 01:42:53,850
of stocks into a panda's series and figure
out how to import your API token from your

1146
01:42:53,850 --> 01:42:59,520
secrets file. So cut here and try to do that
before proceeding. Okay, I hope you had success

1147
01:42:59,520 --> 01:43:05,271
doing that if you didn't, the command to import
your list of SOS PT, underscore, sorry, dot

1148
01:43:05,271 --> 01:43:11,050
read underscore CSV, and then type in your
list of stocks. Now, it should autocomplete

1149
01:43:11,050 --> 01:43:15,930
if you just type in SP. And then you can print
it out to make sure it looks okay. Just like

1150
01:43:15,930 --> 01:43:21,260
before, it has all 505 stocks in the s&p 500.
And then for the secrets file, we went from

1151
01:43:21,260 --> 01:43:27,280
secrets import. And if you hit tab, you can
see that the is how the API token actually

1152
01:43:27,280 --> 01:43:32,240
shows up here. So that is great. We can run
this code cell to get both of those imported,

1153
01:43:32,240 --> 01:43:36,810
and we can move on to make our first API call.
Now, this is where this project will start

1154
01:43:36,810 --> 01:43:40,420
to be quite a bit different than the last
project that we worked through. Because we're

1155
01:43:40,420 --> 01:43:45,790
actually going to be pulling different stock
market information from the IE x cloud API.

1156
01:43:45,790 --> 01:43:50,800
More specifically, instead of trying to pull
price and market capitalization, we're going

1157
01:43:50,800 --> 01:43:56,220
to be pulling price in one year stock return.
So to do that, we're going to go to the i

1158
01:43:56,220 --> 01:44:01,790
x cloud docs. Oops, let's try and keep this
all in one browser window. There we go. So

1159
01:44:01,790 --> 01:44:10,620
I x docs. And we're gonna go here, it's usually
the first non Add Entry in a Google search.

1160
01:44:10,620 --> 01:44:15,770
And then we're going to run a Ctrl F and see
what kind of return metrics we can actually

1161
01:44:15,770 --> 01:44:22,580
find in here. Okay, so return is clearly not
a good thing to search for, because it gives

1162
01:44:22,580 --> 01:44:26,850
341 heads and you can see why that is, is
because a lot of these will say most endpoints

1163
01:44:26,850 --> 01:44:32,270
return. So the fact that endpoints can return
something in stocks can also return a percentage

1164
01:44:32,270 --> 01:44:45,470
is not good. What if we just type it in momentum?
These are all more complex momentum metrics

1165
01:44:45,470 --> 01:44:53,950
than we need. Okay, what if we type in price
return? Zero if we type in price return with

1166
01:44:53,950 --> 01:45:01,170
no space. Okay, once we type in year return,
this might be REST API endpoint that gives

1167
01:45:01,170 --> 01:45:07,880
us a one year return or something like that.
Still nothing. What if we do performance?

1168
01:45:07,880 --> 01:45:19,240
Okay, this gives us 21. sector performance.
As you can see, it's not always super straightforward

1169
01:45:19,240 --> 01:45:37,760
on how to find these. Okay. So now I'm searching
through return again, it is a lot of hits.

1170
01:45:37,760 --> 01:46:03,300
But I feel like it's going to be near the
top of this documentation page. Okay, so this

1171
01:46:03,300 --> 01:46:08,180
looks promising. This is a historical prices
endpoint. And this would actually allow you

1172
01:46:08,180 --> 01:46:14,170
to get the job and you could pull in historical
prices for let's say, one year, and use the

1173
01:46:14,170 --> 01:46:17,990
today's price divided by the price one year
ago, and then subtract one and that will give

1174
01:46:17,990 --> 01:46:22,570
you your one year price return. However, I
know that I x actually calculates this metric

1175
01:46:22,570 --> 01:46:31,260
and I separate endpoints. So we're going to
keep moving through this until we find it.

1176
01:46:31,260 --> 01:46:46,660
Alright, so I had to cut their terms of what
we're actually looking for is the word change,

1177
01:46:46,660 --> 01:46:51,870
not the word return. And I do a Ctrl F, it's
the first thing we find, of course, so this

1178
01:46:51,870 --> 01:46:56,740
is the key stats endpoint, which you can get
with the stats keyword in the URL. And if

1179
01:46:56,740 --> 01:47:01,480
you look down here, there's actually an awesome
group of momentum metrics. So you can do maximum

1180
01:47:01,480 --> 01:47:07,080
percent change five year percent change to
year percent change one year, year to date,

1181
01:47:07,080 --> 01:47:12,920
six months, three months, in case you can't
see us all zoom in a little bit. I guess you

1182
01:47:12,920 --> 01:47:32,470
can't zoom I There we go. Woof. That's a lot
of zoom. There we go. There we go. Alright,

1183
01:47:32,470 --> 01:47:39,091
so max change five year, two year, one year
here today, six months, three months, one

1184
01:47:39,091 --> 01:47:44,830
month, three days, sorry, 30 days and five
days. So this is the stats endpoint we're

1185
01:47:44,830 --> 01:47:50,970
going to do is we're going to copy this. And
we're just going to put it in our Jupyter

1186
01:47:50,970 --> 01:47:57,010
Notebook for now to come back to later. And
we also need the sandbox, base API endpoint.

1187
01:47:57,010 --> 01:48:03,920
zoom back to normal zoom, because it's a little
easier for me to navigate. So here's the testing

1188
01:48:03,920 --> 01:48:08,830
sandbox, we're going to find that this is
the base URL, we're going to put this in here,

1189
01:48:08,830 --> 01:48:13,210
right here. And then remember from last time,
we need to actually include stable here. So

1190
01:48:13,210 --> 01:48:20,090
this is a example of the base URL that we
need to hit with our API call. We're going

1191
01:48:20,090 --> 01:48:26,300
to call this string API underscore URL. And
then we actually need to specify a symbol.

1192
01:48:26,300 --> 01:48:32,900
So just like before, we're going to use Apple
as an example symbol. And we're going to use

1193
01:48:32,900 --> 01:48:37,710
an F string to interpolate that symbol variable
into this, we can take this right off the

1194
01:48:37,710 --> 01:48:42,700
end, because we're not actually trying to
parse a specific stat. And then we can use

1195
01:48:42,700 --> 01:48:47,860
the requests library to make an easy API call
to get this data. So to do that, we're going

1196
01:48:47,860 --> 01:48:54,730
to say data is equal to request dot get, and
then we're going to do API underscore URL.

1197
01:48:54,730 --> 01:49:00,950
And then we're going to sprint the status
code of that HTTP request to make sure that

1198
01:49:00,950 --> 01:49:06,090
went through properly. So this gets 400. We
did something wrong. What is it? sandbox that

1199
01:49:06,090 --> 01:49:12,070
is, oh, we didn't pass on our i x cloud API
token. So we need to do question mark token

1200
01:49:12,070 --> 01:49:17,900
equals IE x and then tab, it should autocomplete
and try that. Alright, so returns 200, which

1201
01:49:17,900 --> 01:49:26,260
means the API call is working properly. Let's
transform this into a JSON and put this again.

1202
01:49:26,260 --> 01:49:29,170
Alright, so as you can see this content. As
you can see, this contains all the information

1203
01:49:29,170 --> 01:49:34,070
that it should contain. The information that
we specifically want is the one year price

1204
01:49:34,070 --> 01:49:37,870
returns for every stock in the universe. So
to do that, it's actually quite easy. We're

1205
01:49:37,870 --> 01:49:45,080
going to cover that next. So to parse a JSON
object like this, we saw in the last section

1206
01:49:45,080 --> 01:49:49,180
that you just pass in square brackets, and
then the key of the dictionary. So the key

1207
01:49:49,180 --> 01:49:54,240
that we want now is one year change percent.
And all these keys generally don't start with

1208
01:49:54,240 --> 01:49:58,500
integers. They start with letters so that's
why it says year five instead of five year

1209
01:49:58,500 --> 01:50:02,100
and etc. But this is the We want, so we're
going to copy this, we're going to move down

1210
01:50:02,100 --> 01:50:07,240
here, we're going to add that in. And then
this should give us 1.42. So what does that

1211
01:50:07,240 --> 01:50:12,530
mean? That means that Apple has increased
in price 142% in the last year, which is pretty

1212
01:50:12,530 --> 01:50:16,130
impressive, it means that the stock has more
than doubled. But I guess that's what happens

1213
01:50:16,130 --> 01:50:21,690
when you sell a lot of expensive iPhones.
So just like before, we're going to kind of

1214
01:50:21,690 --> 01:50:27,070
loop through all of the stocks in our universe
and provide API calls for all of them. Instead

1215
01:50:27,070 --> 01:50:30,190
of living through them one by one, like we
saw in the last section, which is extremely

1216
01:50:30,190 --> 01:50:34,460
slow, we're going to move right on to executing
batch API calls, because that's kind of a

1217
01:50:34,460 --> 01:50:38,750
better practice. And there's no point practicing
executing single API calls when you'll generally

1218
01:50:38,750 --> 01:50:45,950
never do that in practice. So the first thing
we need to do is chunk our list of stocks

1219
01:50:45,950 --> 01:50:51,950
into groups of 100, using the chunks function
that we created last time. So to make this

1220
01:50:51,950 --> 01:50:56,920
easy, I've actually included a bunch of reusable
code from the last project here. So just run

1221
01:50:56,920 --> 01:51:01,590
this code cell that will give us the chunks
function. And then we use the chunks function

1222
01:51:01,590 --> 01:51:07,490
to divide our list of stocks into symbol groups
of length 100, then we create an empty list

1223
01:51:07,490 --> 01:51:13,950
called symbol strings. And then for every
100 stocks in this symbol groups list, we

1224
01:51:13,950 --> 01:51:17,900
create a comma separated list of strings and
then add them to this simple strings variable.

1225
01:51:17,900 --> 01:51:24,930
So if you go through every symbol string in
that list, we did this last project as well.

1226
01:51:24,930 --> 01:51:32,840
But we're gonna do it again, just for practice.
And then you print it, you'll see that this

1227
01:51:32,840 --> 01:51:38,460
is basically just five lists. And I'm sorry,
there should be four in Yeah, so this is just

1228
01:51:38,460 --> 01:51:42,940
five lists of length 100. So when I say lists,
they're not Python lists, they're actually

1229
01:51:42,940 --> 01:51:50,071
strings separated by commas, but there's five
of them. So here's one, here's another. Here's

1230
01:51:50,071 --> 01:51:55,150
where the third one and fourth one, the fifth
one, and I said there's five, there's actually

1231
01:51:55,150 --> 01:52:00,210
six sorry, that's because we have this short
one of length five at the end. Okay, so that's

1232
01:52:00,210 --> 01:52:05,790
all of this, I'm going to delete this out.
And we are going to move on to creating a

1233
01:52:05,790 --> 01:52:13,420
blank panda's data frame. So just like before,
we're going to call this final data frame.

1234
01:52:13,420 --> 01:52:20,980
And we're going to instantiate it by saying
PT, dot data, frame, and then columns equals,

1235
01:52:20,980 --> 01:52:23,840
and then you'll see up in this code, so I've
actually defined the names of the columns

1236
01:52:23,840 --> 01:52:28,590
we want here. So it's ticker price, when your
price return and number of shares to buy.

1237
01:52:28,590 --> 01:52:33,300
These are basically the same column names
as we used in the last project, except market

1238
01:52:33,300 --> 01:52:37,550
capitalization has been replaced by one year
price return here. So we can go down here

1239
01:52:37,550 --> 01:52:42,541
and specify those columns by saying columns
equals my underscore columns. And then, if

1240
01:52:42,541 --> 01:52:47,690
we print this, we should see an empty panda's
data frame with the columns we specify. Awesome,

1241
01:52:47,690 --> 01:52:52,710
so that's good. We're going to delete that.
And then we need to loop through all of our

1242
01:52:52,710 --> 01:52:57,650
symbol strings in the symbol string, symbol
strings object and create a batch API call.

1243
01:52:57,650 --> 01:53:04,940
So for symbol, string and symbol, strings,
and then we want to create a batch API call

1244
01:53:04,940 --> 01:53:10,041
URL, we're going to leave that as an empty
string for a moment. And then we want to create

1245
01:53:10,041 --> 01:53:15,670
a data variable. And that's going to be a
requests dot get method that accepts batch

1246
01:53:15,670 --> 01:53:23,320
API call URL, and then calls the JSON method
on it to transform it from a request subject

1247
01:53:23,320 --> 01:53:29,420
to a JSON object. So what goes in here? Let's
go back to the iCloud Doc's to look at fact

1248
01:53:29,420 --> 01:53:37,100
API call syntax again. Alright, so I just
did a Ctrl, F for batch here to find this

1249
01:53:37,100 --> 01:53:41,730
section, which tells you everything you need
to know about batch requests, so stock, and

1250
01:53:41,730 --> 01:53:52,450
then symbol, and then batch. Actually, we
want to query. So this syntax here is for

1251
01:53:52,450 --> 01:53:58,760
querying multiple endpoints for one stop,
but we want to query one endpoint for multiple

1252
01:53:58,760 --> 01:54:03,790
socks. So we actually want to use this syntax
here. So I'm going to copy this link address.

1253
01:54:03,790 --> 01:54:09,340
And I think this just gives us the last bit.
Now it gives us the entire thing, we're going

1254
01:54:09,340 --> 01:54:16,490
to change this to sandbox, because by default,
the docs give you a a live URL, not a sandbox

1255
01:54:16,490 --> 01:54:20,010
URL. And then we're gonna want to move down
here and change a few things here. So what

1256
01:54:20,010 --> 01:54:25,010
endpoint Do we need first, actually, to start,
move this up here so you can actually see

1257
01:54:25,010 --> 01:54:29,390
it. To start, let's take off this last parameter
and the range parameter. So those can both

1258
01:54:29,390 --> 01:54:35,889
be gone. And we're going to have to add back
our token equals, and then is cloud. Oh, sorry,

1259
01:54:35,889 --> 01:54:44,440
this isn't an F string. So that won't autocomplete
i x cloud. Yep, I x cloud API token, then

1260
01:54:44,440 --> 01:54:48,860
we're going to want to change the endpoints
next. So what goes there? Let's scroll back

1261
01:54:48,860 --> 01:54:55,840
up to see which endpoint we actually queried
earlier. Alright, so we use the stats endpoint.

1262
01:54:55,840 --> 01:55:01,490
So let's put that down into our batch API
call. stats. Then here, we want to change

1263
01:55:01,490 --> 01:55:07,650
our symbols to be an interpolated variable
that matches whatever the incrementer is of

1264
01:55:07,650 --> 01:55:15,010
our for loop. So that is symbol string. Alright,
so now what we need to do is, we're going

1265
01:55:15,010 --> 01:55:20,450
to run over this loop once, just to make sure
that we're getting a 200 HTTP code to make

1266
01:55:20,450 --> 01:55:27,100
sure that the HTTP request is being executed
properly. So to do that, we're going to print

1267
01:55:27,100 --> 01:55:31,820
data dot status code. And for this to actually
work properly, we're gonna have to remove

1268
01:55:31,820 --> 01:55:37,300
this JSON method temporarily from the HTTP
request. And then here, we're specifying what

1269
01:55:37,300 --> 01:55:41,630
we loop over, we're gonna want to change this
to a colon one, which tells us to loop only

1270
01:55:41,630 --> 01:55:45,910
over the first entry of that string. So if
this is working properly, we will get a response

1271
01:55:45,910 --> 01:55:52,670
of 200. Awesome, so that's good, we can get
rid of this status code attribute from the

1272
01:55:52,670 --> 01:56:00,760
data object and call this JSON method on it
to see what the structure of the HTTP response

1273
01:56:00,760 --> 01:56:06,161
actually looks like. So this is basically
a huge dictionary, it has many levels. So

1274
01:56:06,161 --> 01:56:12,801
at the top level, there is a key for this
ticker, and a value of a dictionary. And then

1275
01:56:12,801 --> 01:56:18,010
within that dictionary, there is a key for
the endpoint stats, and a dictionary for the

1276
01:56:18,010 --> 01:56:22,800
value. And then within that dictionary, there's
a key for every metric with a value that corresponds

1277
01:56:22,800 --> 01:56:27,170
to that metric. So we have to do multiple
levels of parsing here. But before we do that,

1278
01:56:27,170 --> 01:56:32,710
we actually have to loop over all of the stocks.
So let's let's build that loop. First off

1279
01:56:32,710 --> 01:56:40,570
we're going to do is we're going to say for
symbol in symbol, string, dot split, and we're

1280
01:56:40,570 --> 01:56:45,150
going to split on the colon character, which
separates all of the tickers in the symbol

1281
01:56:45,150 --> 01:56:50,050
string. So let's see what that split method
actually returns before we go any further,

1282
01:56:50,050 --> 01:56:57,150
Copy that, comment that out and then print
that oops, print that print, this is what

1283
01:56:57,150 --> 01:57:04,071
I want to print. There we go. Awesome. So
let's run that and see what it gives us. As

1284
01:57:04,071 --> 01:57:08,660
you can see, this is a Python list where each
item in the list is a symbol that corresponds

1285
01:57:08,660 --> 01:57:13,950
to all the comma separated symbols in the
symbol string. Okay, perfect. So we'll get

1286
01:57:13,950 --> 01:57:23,500
rid of this did not mean open my dev tools.
We will uncomment this. And then we will start

1287
01:57:23,500 --> 01:57:31,611
parsing the data in this loop. So we're going
to say. So what we want to do here is we want

1288
01:57:31,611 --> 01:57:35,790
to, for every ticker in this list, we want
to append the relevant metrics to the final

1289
01:57:35,790 --> 01:57:41,540
data frame. So to do that, we're going to
say final data frame is equal to final data

1290
01:57:41,540 --> 01:57:45,270
frame dot append. And then within this append
method, there's a few things we need, we need

1291
01:57:45,270 --> 01:57:51,420
a pandas series. And that pandas series will
accept a Python list. And it will also accept

1292
01:57:51,420 --> 01:57:58,070
the index equals my underscore columns argument
that, as you'll recall, from the first project,

1293
01:57:58,070 --> 01:58:03,610
this tells the append method were to actually
put the new metrics in the existing panda's

1294
01:58:03,610 --> 01:58:08,570
data frame. And then outside the panda series,
we're going to actually add ignore index equals

1295
01:58:08,570 --> 01:58:14,110
true. Okay, perfect. So this is where we want
to do our parsing. The first metric we want

1296
01:58:14,110 --> 01:58:18,260
is symbol. The second metric we want is price.
So to get price, we're going to need to do

1297
01:58:18,260 --> 01:58:26,370
data, and then parse the symbol, and then
parse the stats endpoint. And then we're going

1298
01:58:26,370 --> 01:58:35,450
to have to actually see what the name of the
price metric is within this. So let's write

1299
01:58:35,450 --> 01:58:43,960
here. Let's just print out one example of
this. Oh, sorry. All right there, right here.

1300
01:58:43,960 --> 01:58:49,690
Let's crank data. And then we'll use Apple
as an example ticker. And then we'll use stats.

1301
01:58:49,690 --> 01:58:55,490
And then let's just see what this gives us.
All right, there's giving us an error, because

1302
01:58:55,490 --> 01:58:59,220
we didn't actually format the rest of it properly.
But let's look and see here what we have for

1303
01:58:59,220 --> 01:59:09,210
price. I'm going to do Ctrl, F for price,
and see if anything highlights up here. market

1304
01:59:09,210 --> 01:59:18,880
cap employees. Doesn't look like this actually
has any price data. So we need to add here

1305
01:59:18,880 --> 01:59:25,090
to our endpoints, we're gonna say price, and
stats, let's go back gives us if we parse

1306
01:59:25,090 --> 01:59:33,800
price, I think this just gives us 504 hours.
Okay, perfect. So this is what we need to

1307
01:59:33,800 --> 01:59:46,610
do for price. We're going to replace Apple
with a symbol that we're looping over. And

1308
01:59:46,610 --> 01:59:55,450
then we're also going to pass in one year
price return. So we can use this print statement

1309
01:59:55,450 --> 02:00:00,060
up here to see what we need. We're getting
an error here because we're trying to open

1310
02:00:00,060 --> 02:00:06,150
To values to a data frame that has four values.
So for now, I'm just going to put in NA placeholders

1311
02:00:06,150 --> 02:00:11,670
for both of them. And actually, for the number
of shares to buy, that na placeholder is actually

1312
02:00:11,670 --> 02:00:15,810
going to stick. So we only need to figure
out the one year price return. So we'll run

1313
02:00:15,810 --> 02:00:20,630
this to get rid of that error. And then look
in here to see what we need to parse out for

1314
02:00:20,630 --> 02:00:29,360
the one year price return. All right. Year
One is what we need to search for, okay, here's

1315
02:00:29,360 --> 02:00:37,320
the metric year one change percent. So we'll
copy that, we will paste that there for now.

1316
02:00:37,320 --> 02:00:44,720
And then what we want to do is copy this,
paste it there, and then add this in as a

1317
02:00:44,720 --> 02:00:51,450
additional level of parsing to that. Alright,
let's run this, I'm going to take this off.

1318
02:00:51,450 --> 02:00:54,200
And this means that instead of looping over
just the first symbol string, we're going

1319
02:00:54,200 --> 02:00:57,760
to loop over all of the symbol strings. And
then inside of this big loop, I'm going to

1320
02:00:57,760 --> 02:01:00,970
print the final data frame so you can see
what it looks like. With any luck, this should

1321
02:01:00,970 --> 02:01:10,230
be okay. I'm sorry, I'm going to do this again
and remove this print statement. Alright.

1322
02:01:10,230 --> 02:01:15,840
Float object is not sub scriptable. Huh, that's
because we need to change this endpoint to

1323
02:01:15,840 --> 02:01:22,510
stats price. Alright, so this will take a
sec to run. It's a pretty big data frame to

1324
02:01:22,510 --> 02:01:29,130
build. Awesome, everything looks good. So
just to recap, what we did here was, we created

1325
02:01:29,130 --> 02:01:34,220
an empty panda's data frame with the columns
that are specified here. And then we looped

1326
02:01:34,220 --> 02:01:39,790
over all of the symbol strings in our symbol
strings object, we created a batch API call

1327
02:01:39,790 --> 02:01:44,660
URL for those symbol strings that hits two
different endpoints, it hits the price endpoint

1328
02:01:44,660 --> 02:01:51,450
and it hits the stats endpoint. And then we
use the requests library to execute an HTTP

1329
02:01:51,450 --> 02:01:56,550
request and get that data in the form of a
JSON object. For every string in that comma

1330
02:01:56,550 --> 02:02:01,580
separated string of string, or sorry, for
every symbol in that comma separated string

1331
02:02:01,580 --> 02:02:06,250
of symbols. We split them using the split
method to get a list of them. And then we

1332
02:02:06,250 --> 02:02:12,600
looped over that list to a pend the data for
each symbol to our empty panda's data frame.

1333
02:02:12,600 --> 02:02:16,050
And then we printed the panda's data frame.
And it looks like this. Everything seems to

1334
02:02:16,050 --> 02:02:20,360
be working so far, so we can move on to removing
low momentum stocks from our panda's data

1335
02:02:20,360 --> 02:02:25,380
frame. Alright, so like the other code cells
in this project, this has a bit of background

1336
02:02:25,380 --> 02:02:29,220
information, it says the investment strategy
that we're building seeks to identify the

1337
02:02:29,220 --> 02:02:32,680
50 highest momentum stocks in the s&p 500.
Because of this, the next thing we need to

1338
02:02:32,680 --> 02:02:36,540
do is remove all the stocks in our data frame
that fall below this momentum threshold. To

1339
02:02:36,540 --> 02:02:40,080
do that, we'll sort the panda's data frame
by one year price return and then drop all

1340
02:02:40,080 --> 02:02:44,180
stocks outside the top 50. That sounds easy
enough, and pandas actually makes it very

1341
02:02:44,180 --> 02:02:48,670
easy to sort data within the data frame. So
we're going to use some built in functionality

1342
02:02:48,670 --> 02:02:53,140
of the pandas library to do this. Alright,
so the first thing we're gonna do is call

1343
02:02:53,140 --> 02:02:57,300
final data frame. And then on this final data
frame, we're going to call the pandas method

1344
02:02:57,300 --> 02:03:01,150
that allows us to sort the data frame based
on values contained as columns. And that method

1345
02:03:01,150 --> 02:03:06,470
is sorted values. Now, this takes a few different
parameters. The first one is the column that

1346
02:03:06,470 --> 02:03:09,780
you want to use to sort so we're going to
use one year price return, if you just type

1347
02:03:09,780 --> 02:03:14,240
in one and then tab, it might autocomplete.
Now if it doesn't autocomplete, you can just

1348
02:03:14,240 --> 02:03:18,340
go up here and copy it, copying is always
a good idea, because there's lots of different

1349
02:03:18,340 --> 02:03:23,300
ways you could spell this and just kind of
avoid any typos, although typos are pretty

1350
02:03:23,300 --> 02:03:28,040
easy bug to fix. Alright, so one year price
return. And then the next parameter it accepts

1351
02:03:28,040 --> 02:03:32,830
is whether or not you want it to sort ascending
or sort by descending. Now, we want to sort

1352
02:03:32,830 --> 02:03:37,490
descending values so that the highest momentum
stocks are at the top. So to do that, we'll

1353
02:03:37,490 --> 02:03:41,370
say ascending equals false. And then the last
thing we want to say is in place equals true.

1354
02:03:41,370 --> 02:03:44,630
Now, if you've worked with pandas lots in
the past, you're definitely familiar with

1355
02:03:44,630 --> 02:03:50,380
this in place equals true method. What this
does is it changes the function from just

1356
02:03:50,380 --> 02:03:54,280
returning a sorted data frame to actually
modifying the original data frame. Now, to

1357
02:03:54,280 --> 02:03:59,750
see this in action, you can take it away,
run this, and it shows the highest one year

1358
02:03:59,750 --> 02:04:05,220
price return stocks at the top. But then,
if you run that line, and then print the original

1359
02:04:05,220 --> 02:04:08,781
data frame right below it, it will not return
the sort of data frame, it will just return

1360
02:04:08,781 --> 02:04:13,510
the original one. So this shows you that without
the in place equals true method that doesn't

1361
02:04:13,510 --> 02:04:16,940
actually modify the original date. Right now,
if you add the in place equals true method,

1362
02:04:16,940 --> 02:04:21,400
that's not true, it will return the sorted
data frame. So that's how we start the values.

1363
02:04:21,400 --> 02:04:27,630
Now what we need to do is modify the panda's
data frame so that it only includes the first

1364
02:04:27,630 --> 02:04:33,280
50 rows. Now to do that, it's actually quite
easy. You can just pass in the dash 50 Yeah,

1365
02:04:33,280 --> 02:04:42,950
dash 50 or sorry, not dash colon 50 specification
into square brackets like this. Now, the indices

1366
02:04:42,950 --> 02:04:46,051
are all different now because it's been sorted.
So I'm actually going to just make sure that

1367
02:04:46,051 --> 02:04:52,510
this is right by doing length. Yeah, so it's
50. Great. So this has 50 stocks now. And

1368
02:04:52,510 --> 02:04:55,840
then to make this so that it actually modifies
the original pandas data frame, all you need

1369
02:04:55,840 --> 02:05:02,980
to do is say file dot train equals finals
that frame equals 50. Now if you print it,

1370
02:05:02,980 --> 02:05:11,050
it will just return a data frame with 50 rows.
Awesome. So awesome. So one last thing that

1371
02:05:11,050 --> 02:05:15,430
we can do is to reset the index. So it doesn't
start and have kind of this random list of

1372
02:05:15,430 --> 02:05:19,750
numbers. So the easiest way to do that is
just with pandas reset underscore index method

1373
02:05:19,750 --> 02:05:25,200
doesn't actually accept any parameters. But
as you can see, it does the job. Now, just

1374
02:05:25,200 --> 02:05:30,800
like before. Without the in place equals true
method, this doesn't actually modify the original

1375
02:05:30,800 --> 02:05:37,640
data frame, so we'll have to specify that
in here. You'll notice as you work more and

1376
02:05:37,640 --> 02:05:42,830
more with the pandas library that this in
place equals true parameter works in almost

1377
02:05:42,830 --> 02:05:47,489
all of the functions that you use regularly
in the library. So there we go. So just to

1378
02:05:47,489 --> 02:05:52,380
recap what we did here, we took our final
data frame object, which contains price and

1379
02:05:52,380 --> 02:05:58,560
momentum data on all the stocks in the s&p
500. And we sorted its rows based on their

1380
02:05:58,560 --> 02:06:03,180
one year price returns such that the highest
momentum stocks are at the top, and then we

1381
02:06:03,180 --> 02:06:07,020
use the in place equals true parameter to
actually modify the original data frame instead

1382
02:06:07,020 --> 02:06:13,020
of just returning a temporary copy. Once that
was done in the next line, we modified the

1383
02:06:13,020 --> 02:06:17,340
data frames such that it only contains the
50 stocks with the highest price momentum.

1384
02:06:17,340 --> 02:06:22,460
And then we use pandas reset underscore index
method to change the index of the data frame

1385
02:06:22,460 --> 02:06:27,239
so that it actually runs from zero to 49,
or zero to 50, I should say, zero to 49. Yeah,

1386
02:06:27,239 --> 02:06:32,230
zero 49. And then we just printed out the
final data frame on the last line. So with

1387
02:06:32,230 --> 02:06:36,840
that out of the way, we can move on to actually
calculating the number of shares to buy for

1388
02:06:36,840 --> 02:06:44,720
this simple momentum strategy. Alright, so
just like in the last project, this is going

1389
02:06:44,720 --> 02:06:47,890
to be kind of similar, the only change we're
going to make is that we're going to wrap

1390
02:06:47,890 --> 02:06:52,960
the functionality of accepting the port portfolio
size inside of a function because we'll actually

1391
02:06:52,960 --> 02:06:59,000
be using the same functionality later in this
tutorial, when we build a better and more

1392
02:06:59,000 --> 02:07:02,030
robust strategy, you can actually see that
heading here, we started in the next code

1393
02:07:02,030 --> 02:07:06,480
sale. So to do that, we're gonna have to wrap
it in a function and it's probably not necessary,

1394
02:07:06,480 --> 02:07:09,630
wrap it in a function, you could just copy
paste code, it is a Jupyter Notebook after

1395
02:07:09,630 --> 02:07:14,450
all, but it is definitely better to create
functions if you're ever going to reuse any

1396
02:07:14,450 --> 02:07:18,230
code. And since we're not building too many
functions in this Python course, it's kind

1397
02:07:18,230 --> 02:07:23,070
of a good excuse to practice building Python
functions. So if you're familiar with Python

1398
02:07:23,070 --> 02:07:28,091
functions, and since we've already done this
same functionality in the last project, try

1399
02:07:28,091 --> 02:07:31,260
to pause this video here and try to complete
the function yourself without watching me

1400
02:07:31,260 --> 02:07:35,200
code through it. So break now and try that
yourself. Alright, so we're going to do is

1401
02:07:35,200 --> 02:07:41,360
we're going to say def portfolio underscore
size. So if you're not familiar with function

1402
02:07:41,360 --> 02:07:45,720
syntax, in Python, this is just defining a
new function called portfolio size. And the

1403
02:07:45,720 --> 02:07:50,030
empty brackets here means that it's accepts
no parameters. And then the first thing we're

1404
02:07:50,030 --> 02:07:55,570
gonna do is we need to create a global variable
in here. So this function can define a variable,

1405
02:07:55,570 --> 02:07:59,180
and then it can be accessed outside of that
function. So if you were to do that as global,

1406
02:07:59,180 --> 02:08:04,410
and we're going to call this variable at portfolio
underscore size, and then what we're gonna

1407
02:08:04,410 --> 02:08:12,690
do is we're gonna say portfolio. portfolio,
underscore size equal to input. And then just

1408
02:08:12,690 --> 02:08:22,300
like before, we're gonna say, enter this size
of your portfolio. Now, as we saw in the last

1409
02:08:22,300 --> 02:08:29,570
project, we need to make some special functionality
here such that if someone tries to enter a

1410
02:08:29,570 --> 02:08:34,180
string into this Python input, it will tell
them to re enter a float value. So we're going

1411
02:08:34,180 --> 02:08:41,070
to do inverse A try float, portfolio, underscore
size. And if this returns an error, we're

1412
02:08:41,070 --> 02:08:54,870
going to say, print. That is not a number.
And then we're going to print again and say,

1413
02:08:54,870 --> 02:09:06,350
Please try it again. And then we are going
to say, basically, this exact same functionality.

1414
02:09:06,350 --> 02:09:11,360
Great. And then the only other change we need
to make is to actually specialize this accept

1415
02:09:11,360 --> 02:09:15,170
statement so that it only works on the certain
type of error that would happen if someone

1416
02:09:15,170 --> 02:09:18,740
entered a string into this. So that type of
error is a value error. So we'll do that here.

1417
02:09:18,740 --> 02:09:23,010
And actually not to look at this, this is
a bit unnecessary with two separate print

1418
02:09:23,010 --> 02:09:28,130
statements. So I'm going to copy this here
and do in newline character and try that.

1419
02:09:28,130 --> 02:09:32,239
Okay, so let's run this and see if it defines
properly. Awesome, it does. So we're going

1420
02:09:32,239 --> 02:09:35,630
to use this portfolio size function to accept
a portfolio size now and then we're going

1421
02:09:35,630 --> 02:09:41,239
to use it again later to accept a portfolio
size for our better and more realistic momentum

1422
02:09:41,239 --> 02:09:45,200
strategy. But we're going to make sure this
works. And actually, before we proceed, one

1423
02:09:45,200 --> 02:09:48,680
thing that's worth noting is that this should
function should be called portfolio input.

1424
02:09:48,680 --> 02:09:51,930
And it doesn't actually have to be called
portfolio input. But it definitely should

1425
02:09:51,930 --> 02:09:55,090
not be called portfolio size, because then
it has the same name as this variable. And

1426
02:09:55,090 --> 02:09:59,130
that's kind of an easy way to introduce logical
bugs in your code is by having a function

1427
02:09:59,130 --> 02:10:02,280
and a variable with this same name. So we're
going to change this to portfolio input, and

1428
02:10:02,280 --> 02:10:05,240
we're going to run this code cell to define
it, then we're going to test it by running

1429
02:10:05,240 --> 02:10:10,690
portfolio underscore input. And then we are
going to print portfolio underscore size.

1430
02:10:10,690 --> 02:10:15,720
Now, here, it's especially important to print
the variable that's defined inside the function

1431
02:10:15,720 --> 02:10:19,680
because we need to make sure that this, this
global keyword is working properly. So let's

1432
02:10:19,680 --> 02:10:23,450
run this and see what happens. So another
size of your portfolio will enter $1,000,

1433
02:10:23,450 --> 02:10:27,721
and it should print $1,000. Awesome. Now let's
try this again, we'll put in a string. So

1434
02:10:27,721 --> 02:10:35,840
I will say, my portfolio is too small to matter
to you. That's kind of sad, but we're gonna

1435
02:10:35,840 --> 02:10:40,210
try it and then it says that is not a number,
please try again. Okay, so my portfolio is

1436
02:10:40,210 --> 02:10:44,030
one. Awesome, so our portfolio input function
is working properly, we can now move on to

1437
02:10:44,030 --> 02:10:49,210
looping through our panda's data frame and
calculating the number of shares to buy. So

1438
02:10:49,210 --> 02:10:53,030
the first thing we need to do is actually
calculate our position size. And to do that,

1439
02:10:53,030 --> 02:10:56,610
I'm going to actually enter a slightly larger
portfolio. So we're gonna say, That's 1000.

1440
02:10:56,610 --> 02:11:03,110
That's a million. Let's do 10 million. And
what we need to do is calculate position size.

1441
02:11:03,110 --> 02:11:11,360
So to calculate, to calculate position size,
we're going to do position size is equal to

1442
02:11:11,360 --> 02:11:15,800
float portfolio size, divided by the length
of our panda's data frame. So we'll say length

1443
02:11:15,800 --> 02:11:20,110
of final data frame, and then you can pick
the length of any column, I usually do dot

1444
02:11:20,110 --> 02:11:27,800
index for this. So this gives us let's print
it out to see what the position size is. This

1445
02:11:27,800 --> 02:11:34,930
gives us is that 200,000? Yep, yep, 200,000.
And that makes sense, because we're just doing

1446
02:11:34,930 --> 02:11:38,880
10 million divided by 50. So that kind of
math checks out. And then the next thing to

1447
02:11:38,880 --> 02:11:42,870
do is we need to loop through all of the rows
in the panel data frame. So for that, we're

1448
02:11:42,870 --> 02:11:52,160
gonna say for i in range, zero, and then the
length of the data frame, final data frame.

1449
02:11:52,160 --> 02:11:58,980
And then let's just print it to see what happens.
So this goes from zero to 49. And if we go

1450
02:11:58,980 --> 02:12:03,570
back up to a panda's data frame, we can see
that the last index is 49. And the first index

1451
02:12:03,570 --> 02:12:09,050
is zero. So that's awesome. That looks like
it should work properly. Let's take away this

1452
02:12:09,050 --> 02:12:15,781
print statement now. And we're going to loop
through all of the entries within the number

1453
02:12:15,781 --> 02:12:21,489
of shares to buy column. Now, the way to do
that is with pandas LLC functionality, we're

1454
02:12:21,489 --> 02:12:28,340
gonna pass in I for the row, and we're going
to pass in number of shares to buy for the

1455
02:12:28,340 --> 02:12:33,170
column. Now, what we want to do here is just
make sure that we're accessing this properly.

1456
02:12:33,170 --> 02:12:36,630
So we're going to say zero. And then at the
bottom, we're going to say final underscore

1457
02:12:36,630 --> 02:12:41,690
data. Now, if this works properly, what should
happen is every entry in the column of number

1458
02:12:41,690 --> 02:12:46,160
of shares to buy should be replaced with a
zero. So let's try this. Awesome. Now we're

1459
02:12:46,160 --> 02:12:50,520
getting a warning here, because it's saying,
I think this is actually a bug with penisula,

1460
02:12:50,520 --> 02:12:54,940
I'm not sure the setting with copy warning,
it's because it says, If value is trying to

1461
02:12:54,940 --> 02:12:59,780
be set on a copy of a slice from a DataFrame,
try using dot LLC equals value instead. And

1462
02:12:59,780 --> 02:13:03,670
that's kind of exactly what we're doing. So
I'm not really sure what's going on here.

1463
02:13:03,670 --> 02:13:08,780
But you can definitely ignore that for now.
So now what we need to do is calculate actually

1464
02:13:08,780 --> 02:13:15,330
how many shares to buy. So to do that, we're
going to have to access to the Price column

1465
02:13:15,330 --> 02:13:19,250
of the data frame, and we're gonna have to
divide the position side by price. So first,

1466
02:13:19,250 --> 02:13:25,180
we'll take position size, and then we will
divide it by this LLC method, but instead

1467
02:13:25,180 --> 02:13:30,380
of number of shares to buy, we're just going
to replace it with price. Now, let's run this

1468
02:13:30,380 --> 02:13:37,200
and see what happens. Awesome. So as you can
see, this is giving us fractional shares for

1469
02:13:37,200 --> 02:13:40,820
everything. And like we talked about in the
last section of this course, we don't want

1470
02:13:40,820 --> 02:13:44,800
fractional shares for this. So the last thing
we need to do is wrap all of this in a math

1471
02:13:44,800 --> 02:13:52,910
dot floor function. Oops. And this will round
every number in this number shares to by column

1472
02:13:52,910 --> 02:14:00,340
to the lowest, closest interviewer. So let's
try that. Awesome. It's looking good. I think

1473
02:14:00,340 --> 02:14:05,180
we are ready to proceed to building our better
and more realistic momentum strategy. So let's

1474
02:14:05,180 --> 02:14:10,890
do that now. Alright, so it's time for us
to build a better and more realistic quantitative

1475
02:14:10,890 --> 02:14:16,020
momentum strategy. Now, what does it mean
for a momentum strategy to be better? There's

1476
02:14:16,020 --> 02:14:20,310
a lot of different ways you could define it.
Obviously, a strategy is better if it performs

1477
02:14:20,310 --> 02:14:26,320
better, but it's kind of hard to tell that
in without foresight. So what I mean by building

1478
02:14:26,320 --> 02:14:32,210
a better momentum strategy is that real world
quantitative investment firms typically differentiate

1479
02:14:32,210 --> 02:14:37,460
between high quality momentum stocks and low
quality momentum stocks. So a high quality

1480
02:14:37,460 --> 02:14:42,790
momentum stock is a stock that over a long
period of time shows slow and steady price

1481
02:14:42,790 --> 02:14:48,989
returns. So you know, if a stock returns half
a percent every month for a year, that would

1482
02:14:48,989 --> 02:14:54,239
be kind of like a high quality, slow and steady
momentum stock, a low quality momentum stock

1483
02:14:54,239 --> 02:14:58,220
might not show any momentum for a long period
of time and then surge upwards over a short

1484
02:14:58,220 --> 02:15:03,470
period of time. So if you haven't done VAT
returns 0% for 11 months and then 10% in one

1485
02:15:03,470 --> 02:15:08,130
month, that would be considered a low quality
momentum stock, even though it's one year

1486
02:15:08,130 --> 02:15:12,820
price return would be 10%. And might be better
than a lot of other stocks. So it might be

1487
02:15:12,820 --> 02:15:18,800
hard to tell why that definition of high quality
versus low quality stocks is important. But

1488
02:15:18,800 --> 02:15:24,720
the reason why is because you want stocks
that are seeing price returns in reaction

1489
02:15:24,720 --> 02:15:29,040
to slow and steady business progress, not
one time Business News. So the example that

1490
02:15:29,040 --> 02:15:33,080
I used here, as I said, the reason why high
quality momentum stocks are preferred is because

1491
02:15:33,080 --> 02:15:37,240
low quality momentum can often be caused by
short term news that is unlikely to be repeated

1492
02:15:37,240 --> 02:15:42,800
in the future, like an FDA drug approval for
a biotechnology company. So this kind of begs

1493
02:15:42,800 --> 02:15:48,021
the question, how do you identify high quality
momentum stocks, and the best way to do it

1494
02:15:48,021 --> 02:15:54,120
is to take a basket of different time series
momentum metrics, and use them all when calculating

1495
02:15:54,120 --> 02:15:58,860
which momentum stocks to include in your strategy.
So to identify high quality momentum, we're

1496
02:15:58,860 --> 02:16:03,860
going to build a quantitative momentum strategy
that select stocks that have the highest percentiles

1497
02:16:03,860 --> 02:16:09,500
of one month price return, three month price
returns, six months price returns, and one

1498
02:16:09,500 --> 02:16:13,680
year price returns. And we're going to call
this our high quality momentum strategy. So

1499
02:16:13,680 --> 02:16:17,770
you'll see that I use the abbreviation of
HQ m fairly often. And that stands for high

1500
02:16:17,770 --> 02:16:23,120
quality momentum. Let's start by building
our data frame so so the first thing we need

1501
02:16:23,120 --> 02:16:28,360
to do is actually specify our columns. This
is going to be a much longer Python list than

1502
02:16:28,360 --> 02:16:31,310
what we used in the past for columns, because
it's going to include so many more metrics.

1503
02:16:31,310 --> 02:16:40,800
So the first thing we're going to use is ticker,
and then price. And then number of shares

1504
02:16:40,800 --> 02:16:50,960
to buy. We're gonna have to create a bunch
of slots for our, for our return metrics and

1505
02:16:50,960 --> 02:16:54,800
our percentile metrics. So to give you like
a broad overview, we're gonna fill in one

1506
02:16:54,800 --> 02:16:59,510
column for each time period that has how much
that stock has returned in the last year.

1507
02:16:59,510 --> 02:17:03,750
And then right beside that column, there's
going to be another column that has the percentile

1508
02:17:03,750 --> 02:17:08,969
score of that return relative to all of the
other stocks in the universe. So we're going

1509
02:17:08,969 --> 02:17:23,610
to do one year, Christ's return, one year,
return percentile, and then six month, price

1510
02:17:23,610 --> 02:17:32,510
return. And then six month return percentile,
and then helps three, what's the next one,

1511
02:17:32,510 --> 02:17:48,290
three months, yeah, three month price return.
And then three month, return for same trial,

1512
02:17:48,290 --> 02:18:00,099
and then one month price return. And one month,
return percentile. Alright, let's run this

1513
02:18:00,099 --> 02:18:04,269
just to make sure it's formatted properly.
Awesome. So now we can create our data frame

1514
02:18:04,269 --> 02:18:09,920
which is going to be HQ n data frame is equal
to PD data frame. And we're going to specify

1515
02:18:09,920 --> 02:18:20,301
columns equals HQ m underscore columns. Awesome.
Now let's print this HTML data frame to make

1516
02:18:20,301 --> 02:18:25,010
sure that it is an empty panda's data frame
with the columns that we specified. Awesome.

1517
02:18:25,010 --> 02:18:30,679
Now, we can start looping over our symbol
string object that we created earlier for

1518
02:18:30,679 --> 02:18:38,420
symbol, string, and symbol strings. And here's
where we have to create our batch API calls

1519
02:18:38,420 --> 02:18:42,570
and do kind of all the similar logic that
we use before. So the first thing we're going

1520
02:18:42,570 --> 02:18:49,190
to do is execute our batch API call. So we
can actually use very similar logic to that

1521
02:18:49,190 --> 02:18:54,010
as before. So we're going to scroll up here,
find our old batch API call, and use the same

1522
02:18:54,010 --> 02:18:57,729
logic because we don't actually need any metrics
that weren't included in this. So we'll copy

1523
02:18:57,729 --> 02:19:03,840
both of these lines. So what we're grabbing
here is the batch API call URL, and the HTTP

1524
02:19:03,840 --> 02:19:08,620
request that grabs the JSON object from that
URL and stores it in our Python script. So

1525
02:19:08,620 --> 02:19:13,130
we'll scroll back down to where we were here.
And we're going to add this to this loop.

1526
02:19:13,130 --> 02:19:20,940
All right, and now we need to loop through
all of the symbols in that symbol string.

1527
02:19:20,940 --> 02:19:27,360
So we're gonna use for symbol and symbol underscore
string dot split on the comma, character,

1528
02:19:27,360 --> 02:19:34,429
just like before. And then in here, we need
to parse out all of these metrics. So whenever

1529
02:19:34,429 --> 02:19:39,650
I'm doing high level parsing like this, I
find that it's easiest to just literally copy

1530
02:19:39,650 --> 02:19:45,469
this in, and then you can replace each metric
with what you need. So this is going to be

1531
02:19:45,469 --> 02:19:51,300
an append method. First HQ m underscore data
frame is equal to h qm underscore data frame

1532
02:19:51,300 --> 02:19:55,670
dot append. And then in here, we have to pass
in all the things that we've been using throughout

1533
02:19:55,670 --> 02:19:59,610
this course. So first, it'll be a panda's
series. And inside that pandas series, there'll

1534
02:19:59,610 --> 02:20:03,970
be a pipe tongueless we'll fill that in later.
And then we have to say index equals HTML

1535
02:20:03,970 --> 02:20:10,970
underscore columns. And then here we have
to add the special ignore, index equals true.

1536
02:20:10,970 --> 02:20:14,810
Alright, let's move back inside this Python
list, we're going to paste those metrics.

1537
02:20:14,810 --> 02:20:21,670
And then I'm just going to get the indentation
looking a little better here. So do that.

1538
02:20:21,670 --> 02:20:26,700
Alright, so one easy thing we can do is all
of the percentile metrics, we're just going

1539
02:20:26,700 --> 02:20:33,240
to fill in to start with na. And we will loop
back through all of those metrics. And use

1540
02:20:33,240 --> 02:20:42,360
the Sai pi library to calculate their percentile
scores later. Alright, so that's easy. ticker

1541
02:20:42,360 --> 02:20:47,000
will be replaced by symbol, which is the incrementer
of the for loop that we're in here, price

1542
02:20:47,000 --> 02:20:53,630
will be replaced by the price metric, the
price endpoint from the cloud API. So to do

1543
02:20:53,630 --> 02:21:05,210
that, we're going to say, data and then symbol.
And then price. Awesome, the number of shares

1544
02:21:05,210 --> 02:21:10,341
to buy just like before will be filled in
with an NA placeholder. And the one year price

1545
02:21:10,341 --> 02:21:15,270
return we actually already parsed out in our
last example, so we can just go back up and

1546
02:21:15,270 --> 02:21:21,080
copy that down to our new high quality momentum
strategy. Alright, so here's the original

1547
02:21:21,080 --> 02:21:29,930
parsing of the one year price return, we can
copy that, scroll back down to where we were.

1548
02:21:29,930 --> 02:21:36,660
Sorry, right here. All right. And we will
replace this with the parsing of the equivalent

1549
02:21:36,660 --> 02:21:42,550
metric. Awesome. And then, as you can see,
here, we are just going to copy this down

1550
02:21:42,550 --> 02:21:48,630
to all of the other price returns and then
change them to fit. So this is month six instead

1551
02:21:48,630 --> 02:21:56,740
of year one. And then we'll copy this and
move it down to here. And this will be month

1552
02:21:56,740 --> 02:22:04,810
three instead of MONTH six. And this will
be month one instead of MONTH three. All right,

1553
02:22:04,810 --> 02:22:08,030
so let's run this to see if it works. And
then I'll do a quick recap of everything we

1554
02:22:08,030 --> 02:22:17,510
did in that cell. So there is invalid syntax
here. There's a missing comment there. Let's

1555
02:22:17,510 --> 02:22:34,290
try this again. Length of past values is 11.
Index implies 10. What's going on 1-234-567-8910

1556
02:22:34,290 --> 02:22:42,700
11. So we're missing a comma here. And if
we run this, now, it should work. Alright,

1557
02:22:42,700 --> 02:22:48,440
so that is running correctly, it looks like
we're gonna run this again and print out the

1558
02:22:48,440 --> 02:22:54,810
final date, or sorry, it's not the final data
frame anymore. It's the HTM data frame. And

1559
02:22:54,810 --> 02:23:04,250
see what happens. All right, so this is a
big data frame quite a bit bigger than the

1560
02:23:04,250 --> 02:23:08,410
ones we worked with. In the past. It has ticker
price number of shares to buy when your price

1561
02:23:08,410 --> 02:23:13,630
return, one year return percentile, six month
price, return six month return percentile,

1562
02:23:13,630 --> 02:23:17,280
three month price, return three month term,
percentile, one month, press return and one

1563
02:23:17,280 --> 02:23:21,960
month return percentile. So we have lots left
to do to this data frame. But first, we're

1564
02:23:21,960 --> 02:23:25,450
going to go through to each of these percentile
columns. And we're going to replace these

1565
02:23:25,450 --> 02:23:31,850
na values with a percentile score that shows
how high a company's momentum is for that

1566
02:23:31,850 --> 02:23:37,210
time period, relative to all the other stocks
in the universe. So this is we're gonna do

1567
02:23:37,210 --> 02:23:44,010
this, there's going to be a lot of repeated
logic in this section. So I find the easiest

1568
02:23:44,010 --> 02:23:48,300
way to do this is to create a array called
time periods. And then inside this array,

1569
02:23:48,300 --> 02:23:52,410
we're going to create a string for each time
period that we're going to be looping over.

1570
02:23:52,410 --> 02:23:58,360
And then we can use string interpolation to
make this much easier. So we're basically

1571
02:23:58,360 --> 02:24:10,870
going to say our time periods are one year,
and six months, and three months, and one

1572
02:24:10,870 --> 02:24:18,610
month. Now, he's not exactly clear yet how
we're going to be using this, what we're going

1573
02:24:18,610 --> 02:24:23,630
to do is we're going to loop through all of
our columns and replace this value with a

1574
02:24:23,630 --> 02:24:28,590
value from this list so that we have to write
the logic one, the logic ones, but we can

1575
02:24:28,590 --> 02:24:32,800
actually use a loop to calculate the percentile
scores for all of the percentile columns.

1576
02:24:32,800 --> 02:24:40,970
So that's kind of what we're doing here. Now,
the next thing to do is create the actual

1577
02:24:40,970 --> 02:24:50,940
loop. So for row in HQ, m dot data frame dot
index, and then we need to use another loop

1578
02:24:50,940 --> 02:24:55,340
inside of this. This inner loop is going to
loop over the time periods object that we

1579
02:24:55,340 --> 02:25:02,870
just created. So for time period in time periods,
And then here, we're going to use the pandas

1580
02:25:02,870 --> 02:25:10,611
LLC method to change the value of each time
period column. So we're gonna say, HQ m, data

1581
02:25:10,611 --> 02:25:18,040
frame dot LLC, the row is going to be this
row incrementer, that we're looping over here.

1582
02:25:18,040 --> 02:25:26,841
And then the column is going to be we're gonna
make an F string here. And we're going to

1583
02:25:26,841 --> 02:25:31,710
say, it's going to look something like this
with an interpolated value. And so let's copy

1584
02:25:31,710 --> 02:25:37,340
that, we will put that in here. And then this
is the time period that we want to interpolate.

1585
02:25:37,340 --> 02:25:41,950
So we will Oh, and just so you know, you've
probably seen me do this quite a few times

1586
02:25:41,950 --> 02:25:46,440
in this course, all that I'm doing there is
I highlight the string, and then I do a, you

1587
02:25:46,440 --> 02:25:51,180
know, I enter the curly bracket character,
so I just enter that character, and it will

1588
02:25:51,180 --> 02:25:54,880
automatically wrap whatever you have highlighted
in those curly brackets, it's quite a nice

1589
02:25:54,880 --> 02:26:02,431
little feature. Okay, so we're going to replace
this with time period. And then what we want

1590
02:26:02,431 --> 02:26:05,960
to do is assign that to something. So to start,
let's just try assigning them all to zero.

1591
02:26:05,960 --> 02:26:09,500
And then oops, didn't mean to edit that. And
then at the end of this code cell, we will

1592
02:26:09,500 --> 02:26:15,080
print HTM underscore data frame. Let's see
what happens. Alright, so you can see all

1593
02:26:15,080 --> 02:26:19,460
the percentile scores are being replaced with
zero, which is awesome. But that's not quite

1594
02:26:19,460 --> 02:26:24,940
exactly what we need to do yet, we need to
actually use the sci fi stats module to calculate

1595
02:26:24,940 --> 02:26:30,440
the percentile score based on whatever's inside
of this. So let's do that. Now. The function

1596
02:26:30,440 --> 02:26:38,710
we're gonna use is stats dot percentile of
score. And then how this function works is

1597
02:26:38,710 --> 02:26:43,010
it takes two arguments, the first argument
is the entire column. And then the second

1598
02:26:43,010 --> 02:26:48,660
argument is an entry from that column. So
to start, we're going to need the column which

1599
02:26:48,660 --> 02:26:57,722
is simply HQ m, issue m underscore data frame,
I'm going to scroll this up to make sure you

1600
02:26:57,722 --> 02:27:05,180
can see it, and then we need to pass in this
string. Sorry, not that string, we need to

1601
02:27:05,180 --> 02:27:11,290
pass in the this string as the column name
and then interpolate in the time period. So

1602
02:27:11,290 --> 02:27:23,820
it will look like this. Awesome. Now, what
we need to do next is interpolate in the time

1603
02:27:23,820 --> 02:27:30,240
period value, so we need to change this to
an F string, and then change this to time

1604
02:27:30,240 --> 02:27:38,970
period. Alright, the last thing we need to
do is put a comma here, and add in the actual

1605
02:27:38,970 --> 02:27:43,390
value that we want to calculate. So what we're
going to do is use the LFC method, I'm going

1606
02:27:43,390 --> 02:27:51,530
to copy this and put it in as a placeholder.
And then all I have to do is change the oops,

1607
02:27:51,530 --> 02:27:55,850
the column name to match this. Now, I know
that this is a really long Python line, we're

1608
02:27:55,850 --> 02:28:03,420
gonna refactor it in a second. So just hang
tight. Copy that, and put that in here. All

1609
02:28:03,420 --> 02:28:13,970
right, looks like I got some duplicate apps
in parentheses. Okay, let's try this. Alright,

1610
02:28:13,970 --> 02:28:18,840
so these look quite good. You can see that
Apple, which has one of the highest percentile

1611
02:28:18,840 --> 02:28:24,640
scores for one year has a sorry, has one of
the highest momentum scores for one year has

1612
02:28:24,640 --> 02:28:29,590
a 99th percentile. So that's good. Everything
here looks pretty logical to me. So what we're

1613
02:28:29,590 --> 02:28:35,690
going to do now is refactor this code, so
it's much more readable. So first thing we're

1614
02:28:35,690 --> 02:28:48,590
going to do is we're gonna say, change row
equals in our sorry, change column equals

1615
02:28:48,590 --> 02:28:58,311
something and percentile call is equal to
something, the percentile column is this.

1616
02:28:58,311 --> 02:29:10,450
So we can copy that and replace this with
this. And the return column is this. Or the

1617
02:29:10,450 --> 02:29:17,860
change column mean? Sorry. Alright, so let's
go back through and replace these. Oops. And

1618
02:29:17,860 --> 02:29:27,990
we'll go down here and replace this with the
same thing. Okay, this is quite a bit more

1619
02:29:27,990 --> 02:29:32,520
readable. Let's scroll up. So you can see
what actually did here. So basically, this

1620
02:29:32,520 --> 02:29:40,101
is saying, we're going to take the HTM data
frame, and at row of row, and in the percentile

1621
02:29:40,101 --> 02:29:46,200
column, we're going to assign it to this calculation
stats dot percentile of score. And then we're

1622
02:29:46,200 --> 02:29:51,301
going to call this H chrome underscore data
frame a change call. So this is the column

1623
02:29:51,301 --> 02:29:55,800
that we're using to base our percentile calculations
on. And this is the entry from that column

1624
02:29:55,800 --> 02:30:00,220
whose percentile score we want to calculate.
Now, one other thing that we could do to this

1625
02:30:00,220 --> 02:30:10,550
is we could say, change this import somehow.
So if we go back to the top, and we say, copy

1626
02:30:10,550 --> 02:30:22,311
this, and move up to here, and from Sai pi,
import stats, and then we could say, okay,

1627
02:30:22,311 --> 02:30:35,061
percentile of score is what we want. Score.
Score. Okay, so what this is, we run this

1628
02:30:35,061 --> 02:30:40,860
import now. So we're saying from the side
PI's stats module, import the percentile of

1629
02:30:40,860 --> 02:30:46,050
score, function as score, so we can go down
and erase that very long function call and

1630
02:30:46,050 --> 02:30:50,510
just type score instead. And all those changes
will make this much more readable, it means

1631
02:30:50,510 --> 02:30:55,670
you won't have to scroll horizontally to actually
see the entire line. Just so you know, in

1632
02:30:55,670 --> 02:30:58,570
Python, and most software development kind
of considered a bad practice to have really

1633
02:30:58,570 --> 02:31:02,979
long lines. So if you can break it up like
this, it's much more readable and much better,

1634
02:31:02,979 --> 02:31:15,160
I think, I believe too much. Take this. Alright,
but almost fits on one line. Now, it's still

1635
02:31:15,160 --> 02:31:19,400
quite a long call. But if we run this, now,
it should have all the same functionality.

1636
02:31:19,400 --> 02:31:25,010
Great. So now we can move on to actually calculating
the HTM score. Now, we haven't actually talked

1637
02:31:25,010 --> 02:31:30,510
about the H COVID score yet. So let's do that.
Now. The HTM score is just going to be an

1638
02:31:30,510 --> 02:31:35,271
arithmetic mean of all the percentile scores
for the momentum returns that we calculated

1639
02:31:35,271 --> 02:31:39,301
in the last section. So to do that, we're
going to import the mean function from pythons

1640
02:31:39,301 --> 02:31:45,690
built in statistics module. So we're gonna
say from statistics, import mean, let's run

1641
02:31:45,690 --> 02:31:49,450
that to see if it works properly. Now, the
way the mean function works is you can just

1642
02:31:49,450 --> 02:31:54,550
say, like, a few numbers in here, what's the
mean of two and six? Well, this should be

1643
02:31:54,550 --> 02:32:02,220
four. And mean takes one position. Sorry,
this has to be a list in here. Yeah, so that's

1644
02:32:02,220 --> 02:32:04,540
kind of the mean function works, it's kind
of exactly what you'd expect, we're going

1645
02:32:04,540 --> 02:32:08,280
to use that to calculate the average of all
of the percentile scores that we calculated

1646
02:32:08,280 --> 02:32:12,260
in the last section of this project. And we
actually have to do this row by row. So the

1647
02:32:12,260 --> 02:32:15,710
first thing to do is to create a loop. We've
been using lots of loops in here, but it's

1648
02:32:15,710 --> 02:32:22,720
good practice. So for throw in HTN, data frame
dot index, and then the first thing we're

1649
02:32:22,720 --> 02:32:28,060
going to do is create a empty Python list
called momentum percentiles. And then we're

1650
02:32:28,060 --> 02:32:33,500
going to loop through all of the appropriate
columns in the data frame to get the momentum

1651
02:32:33,500 --> 02:32:40,310
score for that row. So let's first do momentum,
percentiles equals empty Python list. And

1652
02:32:40,310 --> 02:32:45,330
then we need to loop through all of the time
periods and the time period object that we

1653
02:32:45,330 --> 02:32:54,010
created earlier. So for time, period and time
periods, and then we need to append the momentum

1654
02:32:54,010 --> 02:32:59,810
scores to this momentum percentiles list.
So momentum percentiles dot append. And then

1655
02:32:59,810 --> 02:33:07,850
in here, we want to say, an LLC method on
the HTM data frame HTML underscore data frame,

1656
02:33:07,850 --> 02:33:14,030
dot LLC, the first entry will be the row,
the second entry will be an F string. And

1657
02:33:14,030 --> 02:33:21,340
inside that F string, we are going to say,
time period, and then return percentile. Alright,

1658
02:33:21,340 --> 02:33:33,200
let's try this just once. And see if we actually
get a reasonable momentum percentiles object.

1659
02:33:33,200 --> 02:33:43,021
Alright, so we get 8585 6235. Let's go up
here and see if that looks right. 8585 62

1660
02:33:43,021 --> 02:33:49,400
and 35. Awesome. So now what we can do is
calculate the mean. And we're going to put

1661
02:33:49,400 --> 02:33:55,640
that mean in the HTM score column. Now, looking
at this, in hindsight, we don't actually have

1662
02:33:55,640 --> 02:34:00,500
an H COVID score column doing. What we're
going to do now is go back up to the top and

1663
02:34:00,500 --> 02:34:07,010
add our h qm score to our columns. So first,
add this to this column. For now, it's going

1664
02:34:07,010 --> 02:34:13,430
to be an NA placeholder, just like all of
these were h score. So we have to add and

1665
02:34:13,430 --> 02:34:20,610
add a placeholder here. And now we just need
to go back to here and rerun all of our code

1666
02:34:20,610 --> 02:34:27,550
cells. If this runs correctly, then we know
that everything we just did worked awesome.

1667
02:34:27,550 --> 02:34:34,620
So now, we need to say that each gram column
needs to be assigned the mean of all of the

1668
02:34:34,620 --> 02:34:38,730
values in the momentum percentiles list. So
we can do that again, using an LLC method.

1669
02:34:38,730 --> 02:34:45,570
We'll say HTM data frame, dot LLC, and then
the first sector This is row The second is

1670
02:34:45,570 --> 02:34:55,910
HTM store. And this needs to be assigned to
the mean of momentum. percentiles and now

1671
02:34:55,910 --> 02:35:03,751
if we print the HM data frame after running
this All of the entries in our HTML data frame

1672
02:35:03,751 --> 02:35:07,610
should have a HTM score calculated on the
very right. Now the only other change we need

1673
02:35:07,610 --> 02:35:14,130
to make is to delete this limiter on the end
of index. And let's see how this looks. Awesome.

1674
02:35:14,130 --> 02:35:18,220
So it looks like we've successfully calculated
an HTM score for every stock in our panda's

1675
02:35:18,220 --> 02:35:23,500
data frame. Let's do a quick recap of what
we did here. So from the Python statistics

1676
02:35:23,500 --> 02:35:27,170
module, we imported the mean function. And
then we loop over all of the rows in our panda's

1677
02:35:27,170 --> 02:35:33,010
data frame. For each row, we re instantiated
an empty Python list called momentum percentiles.

1678
02:35:33,010 --> 02:35:37,990
And then, for every time period in our time
periods list, we lived through the time periods

1679
02:35:37,990 --> 02:35:45,180
and to the momentum percentiles list, we upended
the percentile scores for that stock, and

1680
02:35:45,180 --> 02:35:51,130
then we used the LSC method to assign the
average of all of those percentile scores

1681
02:35:51,130 --> 02:35:56,530
to the HTM score column. Then, to conclude,
we printed out that panda's data frame. Alright,

1682
02:35:56,530 --> 02:36:01,530
let's move on to selecting the 50 best momentum
stocks. So as before, we can identify the

1683
02:36:01,530 --> 02:36:06,640
50 best momentum stocks in our universe by
sorting the panda's data frame on the score

1684
02:36:06,640 --> 02:36:11,470
that matters to us. So in the last section,
that was one year price return, and this section

1685
02:36:11,470 --> 02:36:15,980
is actually going to be HTM score. So the
logic here is very similar, we're going to

1686
02:36:15,980 --> 02:36:23,510
do HTM underscore data frame. And we're going
to use the sort values method, sorry, underscore

1687
02:36:23,510 --> 02:36:33,040
values. And we're going to pass in here is
the HTM score. And then we also need ascending

1688
02:36:33,040 --> 02:36:38,970
equals false. So this will put our highest
ranked momentum stocks at the top. And the

1689
02:36:38,970 --> 02:36:43,141
last thing we need is in place equals true,
this will cause the store value function to

1690
02:36:43,141 --> 02:36:46,891
actually modify the original data frame. So
let's print it out and see what this looks

1691
02:36:46,891 --> 02:36:52,760
like. Alright, we can see our top few stocks
all have extremely high momentum here, which

1692
02:36:52,760 --> 02:37:01,830
is a great sign. Okay. The next thing we need
to do is to drop all stocks except for the

1693
02:37:01,830 --> 02:37:06,840
top 50. And we saw how to do this earlier,
you just say HTM data frame equals HTM data

1694
02:37:06,840 --> 02:37:20,640
frames, and then index it from calling 50.
And if we print this out, now, you can see

1695
02:37:20,640 --> 02:37:23,800
that it is shorter than it was before, it's
hard to tell how much because we haven't reset

1696
02:37:23,800 --> 02:37:33,930
the index yet. So let's do reset underscore
index. Sorry, that's a method, not an attribute.

1697
02:37:33,930 --> 02:37:43,570
And it goes from zero to 49. Awesome. The
last thing we need to do is Pat place in place

1698
02:37:43,570 --> 02:37:49,080
equals true into this. And then if we print
it out, we should see our finalized hmda data

1699
02:37:49,080 --> 02:37:54,370
frame that goes from zero to 49 on the index
column. Awesome. Great. So we are ready to

1700
02:37:54,370 --> 02:37:59,340
start calculating the number of shares to
buy. And we'll use the portfolio input function

1701
02:37:59,340 --> 02:38:04,720
that we created earlier. So let's run that.
And named portfolio input is not defined as

1702
02:38:04,720 --> 02:38:12,550
we as I spelt it wrong. Let's do $1 million
portfolio. And then in the next section, we

1703
02:38:12,550 --> 02:38:17,840
need to calculate the number of shares to
buy and this is exactly what we did before.

1704
02:38:17,840 --> 02:38:24,140
So first, we need to calculate position size,
which is going to be the size of our portfolio

1705
02:38:24,140 --> 02:38:29,810
divided by how many stocks are in it. So the
first thing we need to do is take the float

1706
02:38:29,810 --> 02:38:35,970
value of portfolio underscore size, and then
divide it by the length of our HTM data frame.

1707
02:38:35,970 --> 02:38:45,020
And you can take any column here, I usually
take the index, just like that, and then let's

1708
02:38:45,020 --> 02:38:48,150
print out position size 20,000, that looks
right. Awesome. Now we need to loop through

1709
02:38:48,150 --> 02:38:56,050
a row or panda's data frame. So we'll say
for I and H m data frame index. And then we

1710
02:38:56,050 --> 02:39:01,740
need to assign the number of shares to buy
to the number of shares and I call them so

1711
02:39:01,740 --> 02:39:07,891
we'll use the LLC method to do that issue
dot frame dot LLC. And then we'll pass in

1712
02:39:07,891 --> 02:39:17,780
i comma and then the number of shares to buy.
To test this out, let's assign them all a

1713
02:39:17,780 --> 02:39:26,090
value of zero first, and then print it out
to see what happens. That comma shouldn't

1714
02:39:26,090 --> 02:39:31,680
be there. Awesome number of shares to buy
has all been assigned zero. Great. So like

1715
02:39:31,680 --> 02:39:35,880
before, what we're going to do now is we're
going to divide our position size by the company's

1716
02:39:35,880 --> 02:39:39,720
stock price. And the easiest way to do that
is to copy this over and replace the number

1717
02:39:39,720 --> 02:39:45,840
of shares to buy column with the Price column.
Price. Okay, this looks good. We're getting

1718
02:39:45,840 --> 02:39:54,500
decimals again. So the last thing to do is
wrap this in the math dot floor function.

1719
02:39:54,500 --> 02:40:00,030
And just like that, we successfully calculated
the number of shares to buy for each stock

1720
02:40:00,030 --> 02:40:06,280
In our HCM data frame, oh, there's a there's
one thing actually that we did wrong earlier.

1721
02:40:06,280 --> 02:40:10,250
So you'll notice now that there's a, there's
a new column called index. And the reason

1722
02:40:10,250 --> 02:40:13,881
why that's there is because when we did our
reset index earlier, I can't believe I didn't

1723
02:40:13,881 --> 02:40:18,250
notice that at the time. But there's an optional
parameter here. And just to give you ever

1724
02:40:18,250 --> 02:40:21,900
been more information about how to use Jupyter
notebooks, if you want to know what possible

1725
02:40:21,900 --> 02:40:25,970
parameters are available for a function or
a method, you can do Shift Tab and this will

1726
02:40:25,970 --> 02:40:33,070
pop up. And what we want to do is say drop
equals true. What this does is drop equals

1727
02:40:33,070 --> 02:40:37,640
true. What this does is, the old index just
gets removed from the pandas DataFrame completely.

1728
02:40:37,640 --> 02:40:45,460
That's not the case, I'm going to show you
exactly how you debug this. I'm going to do

1729
02:40:45,460 --> 02:41:03,310
pandas dot, and then reset index to go to
the actual documentation. Oh, sorry, I'll

1730
02:41:03,310 --> 02:41:32,321
tell you exactly what the bug is here. And
the reason why this happened is because we

1731
02:41:32,321 --> 02:41:38,240
ran this more than once. So if we just go
back up here, to where we initialize the issue

1732
02:41:38,240 --> 02:41:46,140
data frame, and then run all the way down,
this problem will be solved. See, just like

1733
02:41:46,140 --> 02:41:51,420
that, it's gone. It goes index and then ticker.
Okay, so just to recap, we should have originally

1734
02:41:51,420 --> 02:41:56,021
put this here, drop equals true in our reset
index method we didn't and that caused that

1735
02:41:56,021 --> 02:42:02,181
to be an extra index column, which we've now
fixed. So now when we run this, we get the

1736
02:42:02,181 --> 02:42:07,130
number of shares to buy, and all the other
columns we need. Alright, so the next thing

1737
02:42:07,130 --> 02:42:12,770
we need to do is format our panda's data frame
into a Microsoft Excel document for use by

1738
02:42:12,770 --> 02:42:18,250
non technical LSI users. So the first thing
we need to do to do this, we're gonna actually

1739
02:42:18,250 --> 02:42:21,130
to back up a bit. To do this, we're gonna
be using the same libraries we did in the

1740
02:42:21,130 --> 02:42:25,230
last project, which is XLS x writer. And to
start, the first thing we need to do is initialize

1741
02:42:25,230 --> 02:42:34,800
a writer object. So to do that you do writer
equals pd.xl, XL, writer. And then the first

1742
02:42:34,800 --> 02:42:39,300
thing you need to pass in is the name of the
Excel file that you want to create. In this

1743
02:42:39,300 --> 02:42:44,880
case, we're going to call it momentum underscore
strategy dot XLS x. The next thing you want

1744
02:42:44,880 --> 02:42:53,150
to add is the engine, which is engine equals
XLS. x writer. Alright, so the next thing

1745
02:42:53,150 --> 02:43:01,580
we need to do is say, Hmm, data frame, got
to underscore Excel. And the first argument

1746
02:43:01,580 --> 02:43:05,330
of this function is going to be the writer
object we just created. The second argument

1747
02:43:05,330 --> 02:43:12,160
is going to be the sheet name. In this case,
it's going to be sheet underscore name equals

1748
02:43:12,160 --> 02:43:18,430
moment momentum strategy. And the last argument
is going to be index equals false. Alright,

1749
02:43:18,430 --> 02:43:24,020
so run that code cell, and we can proceed.
Now, the next thing we need to do is actually

1750
02:43:24,020 --> 02:43:27,540
create the formats that we need, we actually
created all of these formats in the last section

1751
02:43:27,540 --> 02:43:31,340
of this course. So or in the last project
of this course, I should say, so I'm not going

1752
02:43:31,340 --> 02:43:38,220
to make you work through this again, instead,
we're just going to run this code cell to

1753
02:43:38,220 --> 02:43:49,590
proceed. Now we need to actually loop through
the columns format dictionary, again, to apply

1754
02:43:49,590 --> 02:43:55,630
the formats that we created to the columns
that we have. So the easiest way to do this,

1755
02:43:55,630 --> 02:44:00,390
in my opinion, is to scroll all the way back
here to where we initially created our columns,

1756
02:44:00,390 --> 02:44:05,450
which is right here. And then I'm going to
copy all of these and use this as kind of

1757
02:44:05,450 --> 02:44:09,170
a basis for our dictionary that we're going
to build. Alright, so we're going to paste

1758
02:44:09,170 --> 02:44:15,290
that there. Now we need to start with column
name. So it's just gonna we're just gonna

1759
02:44:15,290 --> 02:44:30,660
be doing this to start a, b, c, d, e. Now
note that if I was in like an actual development

1760
02:44:30,660 --> 02:44:35,720
environment, I typically write big programs
in VS code. I can do this much faster with

1761
02:44:35,720 --> 02:44:47,851
multi cursor. Ah, Jupyter notebooks are better
for visualizations and other sorts of things,

1762
02:44:47,851 --> 02:44:55,410
though. Alright, so our columns are going
to be from a through L. And then we're going

1763
02:44:55,410 --> 02:45:06,360
to want to wrap each of these inside of a
list. Now depending on your operating system,

1764
02:45:06,360 --> 02:45:10,560
there's different ways that you can enable
this multi cursor functionality that I'm using

1765
02:45:10,560 --> 02:45:16,850
right now, I am using Linux, and I'm just
Ctrl clicking so that I can add the start

1766
02:45:16,850 --> 02:45:20,840
of the list each line. And then Oops, I'm
going to move back to the start of the list,

1767
02:45:20,840 --> 02:45:35,439
I should try this again. Now what I'm going
to do is try to move to the end of the line

1768
02:45:35,439 --> 02:45:38,750
and add the closing list brackets not gonna
be super pretty because some of these have

1769
02:45:38,750 --> 02:45:44,479
columns and don't look back before the comma,
try that. Okay, what do we have any of these

1770
02:45:44,479 --> 02:45:51,920
broken? Last one is? Great. Okay, so now we
have a columns from a dictionary where the

1771
02:45:51,920 --> 02:45:58,050
keys are each column letter, and the values
are a list with one item where that one item

1772
02:45:58,050 --> 02:46:02,340
is the name of that column. The last thing
we need to do is work through these one by

1773
02:46:02,340 --> 02:46:08,160
one and apply the template we want. So this
will be string underscore template, price

1774
02:46:08,160 --> 02:46:16,790
will be dollar underscore template, number
of shares to buy will be string, note energy

1775
02:46:16,790 --> 02:46:27,870
template, not string template. One year price
return will be percent, one year return percentile,

1776
02:46:27,870 --> 02:46:32,431
so most of these are going to be percent template
moving down. So I'm just going to copy this

1777
02:46:32,431 --> 02:46:40,380
and paste it. Alright, this is looking good.
So far, let's run this code. So next to make

1778
02:46:40,380 --> 02:46:44,780
sure that this dictionary is actually formatted
properly, so it ran correctly, which is good.

1779
02:46:44,780 --> 02:46:50,860
Alright, so the next thing we need to do is
loop through every key in this dictionary

1780
02:46:50,860 --> 02:46:55,640
and apply the right format to that column.
So let's try that. So we're gonna say, for

1781
02:46:55,640 --> 02:47:02,050
column in column, underscore formats, dot
keys. And let's just print column to make

1782
02:47:02,050 --> 02:47:12,090
sure this is working, right, A, B, C, D, E,
F, G, H, i, j, k, l, that looks good. Alright,

1783
02:47:12,090 --> 02:47:18,490
the next thing we need to do is use the method
for XLS writer that actually applies a format

1784
02:47:18,490 --> 02:47:22,341
to a specific column. As we saw in the last
project, the way to do that is we need to

1785
02:47:22,341 --> 02:47:26,350
call the writer object and then from that
writer object, we need to access the sheets

1786
02:47:26,350 --> 02:47:31,840
attribute, which is a list of all the sheets
in the Excel file. And then we need to access

1787
02:47:31,840 --> 02:47:39,090
the momentum strategy tab from that list.
And then we need to call the set column method

1788
02:47:39,090 --> 02:47:45,080
on that, I was going to take three parameters,
let's put two commas in here to reflect that.

1789
02:47:45,080 --> 02:47:50,630
The first parameter is the format that we
want to apply. So the first parameter is the

1790
02:47:50,630 --> 02:47:53,670
column that we want to apply the format to.
So it will look something like this A through

1791
02:47:53,670 --> 02:47:59,729
A, the second parameter is the column width,
which we're going to say 18 pixels. Actually,

1792
02:47:59,729 --> 02:48:03,640
let's do something like 22. And then the last
is which column we're going to want to apply

1793
02:48:03,640 --> 02:48:08,040
to that. So we'll say string underscore format.
And then let's just test that this morning,

1794
02:48:08,040 --> 02:48:13,811
I will say, writer dot save. And then if we
run this, what happens, right, it's actually

1795
02:48:13,811 --> 02:48:19,620
similar to strategy string format is not Oh,
it's because string template. All right, now

1796
02:48:19,620 --> 02:48:26,720
let's go to our folder and see if this is
working right. starter files momentum strategy,

1797
02:48:26,720 --> 02:48:31,320
so is there which is good. If we open this
up, we can see that the data in here, we can

1798
02:48:31,320 --> 02:48:35,979
see that the first column has been formatted
properly, we're going to go format the headers

1799
02:48:35,979 --> 02:48:40,640
in the same way that we did in the last section,
so don't worry about that yet. Alright, so

1800
02:48:40,640 --> 02:48:45,590
now we need to change this set column method
such that it actually is dynamically applying

1801
02:48:45,590 --> 02:48:50,270
formats to each column in the data frame.
So first thing to do is change the column

1802
02:48:50,270 --> 02:48:59,880
like this. And the second thing to do is to
add a two. Here, we're going to access the

1803
02:48:59,880 --> 02:49:05,229
column format dictionary, we're gonna pass
in the column key. Alright, let's try that

1804
02:49:05,229 --> 02:49:10,380
what happens now columns is not defined. That's
because that should be column. Now if we go

1805
02:49:10,380 --> 02:49:16,680
to our Excel file, still not working. And
that is we saw this in the last project, too.

1806
02:49:16,680 --> 02:49:21,750
We need to go back up and re initialize our
writer object and go down to the bottom again.

1807
02:49:21,750 --> 02:49:30,830
Right, what is happening here, we have some
kind of bug on writer dot save. Why is that?

1808
02:49:30,830 --> 02:49:44,050
I'll save Oh, I see. Okay, so here in the
writer dot sheets, dot set column method.

1809
02:49:44,050 --> 02:49:50,280
This is actually a list and we need to actually
parse it to get the format that we want. That

1810
02:49:50,280 --> 02:49:54,750
format is in the second item of the list,
which is at index one. So we press one there,

1811
02:49:54,750 --> 02:50:02,590
and this should work properly and we can go
see our oops, ignore that. We can go see our

1812
02:50:02,590 --> 02:50:07,890
newly formatted Excel file. Alright, so the
format's are being applied to each column

1813
02:50:07,890 --> 02:50:12,340
properly, you can see that they're not actually
wide enough because the column names in this

1814
02:50:12,340 --> 02:50:16,710
project are longer than the column names in
the last project. So let's change that 22

1815
02:50:16,710 --> 02:50:25,590
to 25. And then the last thing we need to
do is actually check format the column headers.

1816
02:50:25,590 --> 02:50:29,300
And we saw in the last section that the easiest
way to do that is just overriding them using

1817
02:50:29,300 --> 02:50:33,392
the right methods. So the right method is
similar to the set color method, except instead

1818
02:50:33,392 --> 02:50:38,010
of taking in an entire column for the first
one, it takes just a cell from a column. So

1819
02:50:38,010 --> 02:50:42,590
we're going to do here is we're going to access
the column. And then once that's the first

1820
02:50:42,590 --> 02:50:46,380
cell of that column, here, we're going to
specify the column width. And then here, we

1821
02:50:46,380 --> 02:50:50,930
are going to do the exact same thing and apply
the format from the second entry of that list.

1822
02:50:50,930 --> 02:50:56,130
Alright, let's go back to the top of our formatting
the Excel format section, run through all

1823
02:50:56,130 --> 02:51:03,261
of this again, and with any luck, this should
be formatted exactly like we want. There we

1824
02:51:03,261 --> 02:51:08,180
go. Alright, so you can see that this is not
good, because what is going on in this top

1825
02:51:08,180 --> 02:51:17,301
row? Well, I see, this doesn't actually take
column with this takes the value that we want

1826
02:51:17,301 --> 02:51:22,450
to put in it. And that's just a mistake on
my part, a logical mistake. That should be

1827
02:51:22,450 --> 02:51:29,860
this list at index zero. So let's copy that
list, put it here and put index zero. We'll

1828
02:51:29,860 --> 02:51:35,171
move this writer dot save method, back down
to the last column, this Jupyter Notebook

1829
02:51:35,171 --> 02:51:38,920
or the last cell of distributor notebook,
rather than we'll move back up to where the

1830
02:51:38,920 --> 02:51:44,120
writer object was initialized and run it to
the bottom. Now, when we open up our momentum

1831
02:51:44,120 --> 02:51:50,140
strategy Excel file, we should see that the
entire notebook is done, we have ticker price

1832
02:51:50,140 --> 02:51:55,290
number of shares to buy one year price return,
one year return percentile, six month price,

1833
02:51:55,290 --> 02:52:00,290
return six months return percentile, three
month price, return three months return percentile,

1834
02:52:00,290 --> 02:52:05,140
one month, price, return, one month, return
percentile, and HTM score. Now, you can see

1835
02:52:05,140 --> 02:52:09,630
that all of these aren't actually formatted
like they should be. So all these percentile

1836
02:52:09,630 --> 02:52:16,021
scores are multiplied by, I guess 100 over
what their actual value should be. So let's

1837
02:52:16,021 --> 02:52:22,000
go back into a notebook and fix that. If we
scroll up here. We're gonna go all the way

1838
02:52:22,000 --> 02:52:29,990
back to where our percentile scores were originally
calculated. And that is right here, I think.

1839
02:52:29,990 --> 02:52:36,620
Yeah. So note, sorry, this is the HTML score,
we need to go up a little bit further. Right,

1840
02:52:36,620 --> 02:52:42,490
so this is where they originally calculated,
we're going to move to the end of this calculation,

1841
02:52:42,490 --> 02:52:50,170
and divide it by 100. And then, we're going
to go back to where we created our h qm DataFrame.

1842
02:52:50,170 --> 02:52:57,660
And run this entire notebook to the very end.
All right, so this should all run with no

1843
02:52:57,660 --> 02:53:06,572
problems. We're waiting on our input here,
so I'll do a million dollars again. And this

1844
02:53:06,572 --> 02:53:15,140
should run to the bottom with no problem.
Alright, let's check out our new Excel file

1845
02:53:15,140 --> 02:53:20,670
to see if those percentile scores were reduced
in magnitude like they should have been. Alright,

1846
02:53:20,670 --> 02:53:26,591
so we have one year price return and then
9.2. That looks good. Alright, so you can

1847
02:53:26,591 --> 02:53:33,890
see that this has been sorted by hmm score
properly, we go from 99.1, down to 81.9. And

1848
02:53:33,890 --> 02:53:39,410
just like that, we have a list of the 50 highest
momentum stocks in the s&p 500, along with

1849
02:53:39,410 --> 02:53:42,420
the number of shares that you should buy if
you want to create an equal weight basket

1850
02:53:42,420 --> 02:53:47,260
on those 50 stocks. So that concludes our
second project for this algorithmic trading

1851
02:53:47,260 --> 02:53:50,790
and Python course, I hope you enjoyed this
project. In the next section, we're going

1852
02:53:50,790 --> 02:53:55,510
to learn how to build a value investing strategy
that buys the 50 cheapest stocks in the s&p

1853
02:53:55,510 --> 02:54:00,040
500 based on a composite score of a number
of different value investing metrics. So I

1854
02:54:00,040 --> 02:54:04,580
will see you there in the next project, which
is going to be a value investing strategy.

1855
02:54:04,580 --> 02:54:08,141
Now, for anyone who's not familiar with value
investing, it just means trying to buy stocks

1856
02:54:08,141 --> 02:54:12,990
and other investments that are cheap relative
to our SL. For anyone who's not familiar with

1857
02:54:12,990 --> 02:54:17,180
value investing, it just means trying to buy
stocks and other investments that are cheap

1858
02:54:17,180 --> 02:54:21,410
relative to our assessment of their intrinsic
value. There's many different ways to try

1859
02:54:21,410 --> 02:54:25,190
to estimate the intrinsic value of a stock
or other investments. So what we're going

1860
02:54:25,190 --> 02:54:29,570
to do in this project is we're going to build
a simple value strategy that relies on one

1861
02:54:29,570 --> 02:54:35,020
metric. And then we're going to improve that
value strategy by creating a composite value

1862
02:54:35,020 --> 02:54:38,261
strategy that takes into account many different
metrics when trying to estimate intrinsic

1863
02:54:38,261 --> 02:54:43,230
value. So to start, let's navigate into I'm
in my terminal here in my home directory.

1864
02:54:43,230 --> 02:54:48,141
Let's navigate into our algorithmic trading
Python folder. And then let's launch our Jupyter

1865
02:54:48,141 --> 02:54:52,410
Notebook. Sorry, before we do that, we have
to launch our virtual environment. And then

1866
02:54:52,410 --> 02:54:58,311
we can launch our Jupyter Notebook with Python
dash m notebook. A Jupyter Notebook will open

1867
02:54:58,311 --> 02:55:03,140
up in your browser Then you're gonna want
to navigate into our starter Files folder

1868
02:55:03,140 --> 02:55:10,620
and open up the quantitative value strategy
ipnb notebook. Alright, so, like I said before

1869
02:55:10,620 --> 02:55:15,510
the value investing means investing in the
stocks that are cheapest relative to common

1870
02:55:15,510 --> 02:55:19,820
measures of business value like earnings or
assets. For this project, we're going to build

1871
02:55:19,820 --> 02:55:23,931
an investing strategy that selects the 50
stocks with the best value metrics. From there,

1872
02:55:23,931 --> 02:55:28,310
we will calculate recommended trades for equal
weight portfolio of these 50 stocks. So like

1873
02:55:28,310 --> 02:55:32,320
before, the first thing that we need to do
is import the open source Python libraries

1874
02:55:32,320 --> 02:55:36,050
that we'll be using throughout our Jupyter
Notebook. So it's going to be the same libraries

1875
02:55:36,050 --> 02:55:42,400
as we use in the last section. So import NumPy
as NP as a quick recap, NumPy is a numerical

1876
02:55:42,400 --> 02:55:47,000
computing library that you need to work with
pandas, and then we'll need to import pandas

1877
02:55:47,000 --> 02:55:54,770
as PD, then we'll need to import XLS x writer,
this is the module that we use to save our

1878
02:55:54,770 --> 02:55:58,600
pandas data frame as an Excel file at the
end of this Jupyter Notebook, we're going

1879
02:55:58,600 --> 02:56:04,370
to import the requests library which is used
for making HTTP requests. You'll recall from

1880
02:56:04,370 --> 02:56:09,561
our first project that the slogan for requests
is HTTP for humans, which I quite like. And

1881
02:56:09,561 --> 02:56:15,660
then we're also going to need to import the
stats module of Sai pi. Pi import stats. And

1882
02:56:15,660 --> 02:56:21,810
the last thing we're gonna need to import
is the math module. So let's run this code

1883
02:56:21,810 --> 02:56:29,229
cell to to import all of these libraries into
our Python script. Great, that's done. The

1884
02:56:29,229 --> 02:56:33,780
next thing we need to do is import our list
of stocks and our API token. So just like

1885
02:56:33,780 --> 02:56:38,479
before, we're going to import our list of
stocks into a panda's data frame called stocks.

1886
02:56:38,479 --> 02:56:42,521
And we're also going to import our is cloud
token from our secrets file. So let's do that.

1887
02:56:42,521 --> 02:56:49,360
First, we'll say stocks equals PD dot read
underscore, CSV. And then we're gonna type

1888
02:56:49,360 --> 02:56:54,060
in SP and hit tab to autocomplete the file
name. Let's just print this to make sure that

1889
02:56:54,060 --> 02:56:59,311
it is working like we intend. So this is a
list of all the stocks, and this is a panda's

1890
02:56:59,311 --> 02:57:02,790
data frame, you can get the pandas series
that's associated with the only column that

1891
02:57:02,790 --> 02:57:08,891
data frame by parsing out the ticker column.
We'll do that later. And the other thing we

1892
02:57:08,891 --> 02:57:14,560
need to do here is say from secrets, import,
and then if you just hit tab here, it'll give

1893
02:57:14,560 --> 02:57:19,030
you some options. What we want is this is
cloud API token. Great. So that is how we

1894
02:57:19,030 --> 02:57:22,180
import our list of stocks and API tokens.
And in the next session, we're gonna make

1895
02:57:22,180 --> 02:57:29,550
our first API call using our AI x cloud token.
Great. So like before, what we need to do

1896
02:57:29,550 --> 02:57:36,760
now is figure out which end point of the is
cloud API that we need to hit. So I said in

1897
02:57:36,760 --> 02:57:40,479
the introduction to this project, that we're
going to start by building a simple value

1898
02:57:40,479 --> 02:57:44,400
strategy that screens for stocks based on
a single value metric, and that value metric

1899
02:57:44,400 --> 02:57:48,680
is going to be the price to earnings ratio.
Now, for anyone who's not familiar with a

1900
02:57:48,680 --> 02:57:53,630
company's price earnings ratio, it's basically
you take their stock price, and you divide

1901
02:57:53,630 --> 02:57:58,250
it by how much earnings you expect them to
have over the next year. So as a basic example,

1902
02:57:58,250 --> 02:58:05,840
let's say we'll look at Apple again. So Apple's
current stock price is $508.06. Now, if you

1903
02:58:05,840 --> 02:58:12,070
wanted to calculate a price to earnings ratio
for Apple, we need to find an earnings estimate.

1904
02:58:12,070 --> 02:58:21,189
So we'll just type Apple earnings estimate.
And it looks like these are all quarterly

1905
02:58:21,189 --> 02:58:25,100
estimates. And we want an annual estimate.
So whenever you're calculating a price earnings

1906
02:58:25,100 --> 02:58:30,220
ratio, or any other kind of valuation metric,
you always use annual numbers in the denominator.

1907
02:58:30,220 --> 02:58:40,229
So looks like this chart from NASDAQ provides
some estimated earnings metrics. So yearly

1908
02:58:40,229 --> 02:58:45,090
earnings forecast, this is what we want. And
we will use the fiscal year ending in September

1909
02:58:45,090 --> 02:58:51,650
2021. It looks like they have consensus earnings
per share of $16 per share. And that means

1910
02:58:51,650 --> 02:58:56,010
that to calculate the price earnings ratio,
we just calculate the take the company's current

1911
02:58:56,010 --> 02:59:01,150
stock price and divided by 16. So what does
this give us 31. So that means Apple's price

1912
02:59:01,150 --> 02:59:05,670
earnings ratio is 31. That's some high level
background on what the price earnings ratio

1913
02:59:05,670 --> 02:59:10,940
is. Fortunately, I x cloud makes it very easy
to access price earnings ratios, because if

1914
02:59:10,940 --> 02:59:15,620
you go to their documentation, they actually
provide the price earnings ratio natively

1915
02:59:15,620 --> 02:59:21,880
here. So we'll just start by trying to control
f find it price to earnings. And it looks

1916
02:59:21,880 --> 02:59:27,640
like we have it right here. So P e ratio in
this API endpoint refers to the price earnings

1917
02:59:27,640 --> 02:59:33,950
ratio. Oh, I don't know what that was a link
in here somewhere. I clicked the epic timestamp

1918
02:59:33,950 --> 02:59:37,920
there. So anyways, P e ratio refers to the
price to earnings ratio for the company. Do

1919
02:59:37,920 --> 02:59:45,550
you know what endpoint is this? This is the
quote endpoint. Now this is good because one

1920
02:59:45,550 --> 02:59:49,460
of the other things that we'll need for this
screener is we're going to need the latest

1921
02:59:49,460 --> 02:59:52,960
stock price for the company. So you look in
the JSON response here. You'll notice that

1922
02:59:52,960 --> 02:59:59,230
they have latest price here. And they also
have down at the bottom p e ratio. So what

1923
02:59:59,230 --> 03:00:05,229
we're going to do is We're going to take this
API endpoint, we're going to copy it into

1924
03:00:05,229 --> 03:00:13,000
our Jupyter Notebook. And we are going to
go back to the sandbox mode here and get our

1925
03:00:13,000 --> 03:00:19,310
base URL for every API call that we're going
to make. So here is the sandbox base URL,

1926
03:00:19,310 --> 03:00:24,430
we're going to copy that, move it back here,
put it there. And you'll recall from the first

1927
03:00:24,430 --> 03:00:30,150
project that we actually have to add stable
here to show that Oh, whoops, was stable and

1928
03:00:30,150 --> 03:00:34,280
show that we want the latest stable version
of the API. And not any kind of bleeding edge

1929
03:00:34,280 --> 03:00:39,550
version of the API that might have beta features
that aren't fully tested yet. So this is going

1930
03:00:39,550 --> 03:00:45,141
to be kind of a sample API endpoint that we'll
use to get our price to earnings ratio, we're

1931
03:00:45,141 --> 03:00:52,320
going to call this API URL, and we're going
to make it a string. Now, we need to make

1932
03:00:52,320 --> 03:00:55,801
two small changes to this. First of all, we're
going to take this field off yet, because

1933
03:00:55,801 --> 03:00:59,360
we don't actually want to parse a single metric
out of this endpoint, we want to parse the

1934
03:00:59,360 --> 03:01:03,200
entire JSON response, we're going to leave
symbol there, but we're going to turn this

1935
03:01:03,200 --> 03:01:07,271
into an F string so that that symbol actually
becomes interpolated. Now, we need to make

1936
03:01:07,271 --> 03:01:13,141
a symbol variable here, and we're gonna say
the symbol is Apple. And the next thing we

1937
03:01:13,141 --> 03:01:19,450
need to do is create an actual API call using
the requests library. So to do that, we're

1938
03:01:19,450 --> 03:01:24,050
gonna say data equals requests dot get. And
then inside of this get method, we're going

1939
03:01:24,050 --> 03:01:29,250
to pass in this API underscore URL. And then
we are going to print out the status code

1940
03:01:29,250 --> 03:01:34,390
of this HTTP request. Now, we've talked about
this before, but status codes tell you whether

1941
03:01:34,390 --> 03:01:40,090
your HTTP request was successful or not. Successful
HTTP request will return a status code of

1942
03:01:40,090 --> 03:01:47,030
200. And most erroneous HTTP requests will
return a status code that's somewhere in the

1943
03:01:47,030 --> 03:01:53,850
400 range. So 500 is actually also an indicator.
So we're gonna do a print statement that prints

1944
03:01:53,850 --> 03:02:00,360
out data dot status underscore code. And if
this gives us 200, then we know that our first

1945
03:02:00,360 --> 03:02:05,810
API call was executed correctly. Alright,
so this gives us 400. And the reason why I've

1946
03:02:05,810 --> 03:02:10,610
done this actually before in this course,
but I forgot to add on our authentication

1947
03:02:10,610 --> 03:02:15,720
token. So to do that, we're just going to
interpolate in this question mark token equals

1948
03:02:15,720 --> 03:02:20,521
and then, inside these curly brackets, we're
going to add our AI x cloud API token. And

1949
03:02:20,521 --> 03:02:26,270
this gives us a status code of 200. Awesome.
Now, we'll transform this data variable into

1950
03:02:26,270 --> 03:02:31,650
a JSON object using the JSON method, which
accepts no parameters. And then we can print

1951
03:02:31,650 --> 03:02:35,960
out this JSON response to see what it actually
contains. Okay, so you can see that it has

1952
03:02:35,960 --> 03:02:42,210
a number of different data points available
in this HTTP response, including symbol company

1953
03:02:42,210 --> 03:02:46,410
name, primary exchange calculation price,
a whole bunch of other stuff, you can see

1954
03:02:46,410 --> 03:02:51,570
actually, since we're using sandbox mode,
this primary exchange quite owns, that's not

1955
03:02:51,570 --> 03:02:55,630
a real Stock Exchange, it looks like they
actually just took the company's real exchange,

1956
03:02:55,630 --> 03:03:01,970
which is NASDAQ, spelt like this, and SBA
Q, and then they scrambled it or it looks

1957
03:03:01,970 --> 03:03:05,229
like they scrambled it somehow. Anyway. So
that's kind of an interesting part of using

1958
03:03:05,229 --> 03:03:11,120
the the sandbox mode of the if cloud API.
So what we want to do here is this latest

1959
03:03:11,120 --> 03:03:16,460
price endpoint, and this P ratio endpoint
here. So we'll parse out both of those variables

1960
03:03:16,460 --> 03:03:22,200
in the next code cell. Okay, so the first
thing we want to do is calculate it with the

1961
03:03:22,200 --> 03:03:27,439
stock price. So we'll say price equals data.
And then this is just a Python dictionary,

1962
03:03:27,439 --> 03:03:32,120
you can actually verify that by just printing
out its type like this, this will give us

1963
03:03:32,120 --> 03:03:37,851
some debt. Yeah, it's a class of debt. So
we'll pick up that print statement. Since

1964
03:03:37,851 --> 03:03:44,460
it's a Python dictionary, you can you can
access the value stored in the dictionary,

1965
03:03:44,460 --> 03:03:48,160
bypassing the keys and using square brackets.
We've seen this earlier in this course. But

1966
03:03:48,160 --> 03:03:54,910
it's always good to have a good little refresher.
So the two things we want our latest price.

1967
03:03:54,910 --> 03:03:58,950
So we'll we'll assign that to the price variable.
And let's just print it to make sure it was

1968
03:03:58,950 --> 03:04:04,580
parsed out correctly. 513 89. That's awesome.
The other thing we want is price earnings

1969
03:04:04,580 --> 03:04:10,820
ratio. So we'll say P e ratio equals data.
And then we're going to parse out this P e

1970
03:04:10,820 --> 03:04:15,341
ratio string here. And just like we did with
price, we're going to print this out to make

1971
03:04:15,341 --> 03:04:22,011
sure that it is working properly. The ratio
39.6, you can see that this is a little bit

1972
03:04:22,011 --> 03:04:27,320
higher than the 31 pe that we calculated manually.
And that's probably because i x cloud is using

1973
03:04:27,320 --> 03:04:33,120
a different kind of earnings. One of the tricky
things about running any kind of value strategy

1974
03:04:33,120 --> 03:04:37,080
quantitatively like this is that when you're
using earnings or any kind of other fundamental

1975
03:04:37,080 --> 03:04:41,180
metric, there are numerous different ways
that it can be calculated. You can use earnings

1976
03:04:41,180 --> 03:04:45,950
estimates, which is what I did in my example,
you can also use trailing earnings, which

1977
03:04:45,950 --> 03:04:49,030
some people believe are more reliable because
they're actually reported earnings instead

1978
03:04:49,030 --> 03:04:53,891
of relying on someone's estimate. But if you
ever calculate a P e ratio, and you're confident

1979
03:04:53,891 --> 03:04:58,940
that your math is right, but it doesn't match
someone else's math, the reason why it's probably

1980
03:04:58,940 --> 03:05:02,950
because they're defining ratio slightly differently.
So when you're doing any kind of work like

1981
03:05:02,950 --> 03:05:07,420
this in the future, it's always good practice
to strictly define what you're doing. So if

1982
03:05:07,420 --> 03:05:11,180
you're using trailing earnings, say, I'm using
trailing earnings, and I'm calculating my

1983
03:05:11,180 --> 03:05:15,080
P e ratio, if you're using forward earnings,
you might want to call it a forward p e ratio

1984
03:05:15,080 --> 03:05:20,460
instead of just p e ratio so that it removes
that ambiguity. Alright, so like before, we

1985
03:05:20,460 --> 03:05:25,490
can now move on to executing a batch API call.
And just like I did in the momentum strategy

1986
03:05:25,490 --> 03:05:31,630
for this course, I've actually provided some
reusable code that we have used earlier on,

1987
03:05:31,630 --> 03:05:36,951
so that you don't actually have to kind of
redundantly write the same code over and over

1988
03:05:36,951 --> 03:05:39,960
again, although if you're up for the practice,
what you could do is just delete this entire

1989
03:05:39,960 --> 03:05:44,250
code cell and try to write our chunks function
and our symbol strings variable from scratch.

1990
03:05:44,250 --> 03:05:52,280
So for now, for the sake of brevity, I'm going
to just run this code cell and proceed with

1991
03:05:52,280 --> 03:05:56,729
executing our batch API call. So actually,
before I do that, I'll give you a quick quick

1992
03:05:56,729 --> 03:06:02,521
recap of what's going on here. So first off
this, this comment at the top just tells you

1993
03:06:02,521 --> 03:06:06,740
where I source this chunks function from.
Since I didn't write this myself, it's always

1994
03:06:06,740 --> 03:06:10,940
good to attribute a function to wherever you
received if it's someone else's work. So what

1995
03:06:10,940 --> 03:06:14,750
does this chunks function actually do? This
chunks function takes in a list, which is

1996
03:06:14,750 --> 03:06:21,340
this LST. And it also takes in this variable
n. And what it does is it you can see in the

1997
03:06:21,340 --> 03:06:26,320
doc string here that a yield successive any
size chunks from lists. And to be more specific,

1998
03:06:26,320 --> 03:06:32,610
if you have a list of 505, like is, which
is what we're going to pass in, it will return

1999
03:06:32,610 --> 03:06:39,150
five lists of n sorry, you pass in a list
of 505 and a value of n of 100, it will pass

2000
03:06:39,150 --> 03:06:46,030
you back a list that is five entries of length
101 entry of length five. So that's what that

2001
03:06:46,030 --> 03:06:51,920
is. Next step, we create a list using this
chunks variable that takes all of our stocks

2002
03:06:51,920 --> 03:06:58,961
and divides them into five lists of length
101, length of list five, and then we create

2003
03:06:58,961 --> 03:07:05,590
an empty symbol strings list. And then with
this for loop, we take every group of stocks

2004
03:07:05,590 --> 03:07:10,600
that's in the symbol groups variable, and
we create a comma separated string that has

2005
03:07:10,600 --> 03:07:13,950
all of the tickers from each list. And if
you want to see what those look like, we can

2006
03:07:13,950 --> 03:07:17,820
actually uncomment this print statement and
run this code down. So you can see, this is

2007
03:07:17,820 --> 03:07:21,550
one list. This is another list. This is the
next list. This is the end of the fourth,

2008
03:07:21,550 --> 03:07:25,570
this is the end of the fifth. And this is
the entire fifth list, which is shorter, because

2009
03:07:25,570 --> 03:07:30,960
it wasn't long enough to actually fill out
the length of 100 that was specified by the

2010
03:07:30,960 --> 03:07:35,100
function. Okay. And then the last thing that's
done in this code cell is we specify the columns

2011
03:07:35,100 --> 03:07:40,040
for our panda's data frame. So the columns
are ticker price, price earnings ratio, and

2012
03:07:40,040 --> 03:07:43,670
number of shares to buy. So I'm going to run
this again, with this print statement commented

2013
03:07:43,670 --> 03:07:49,230
out to remove that large print. Okay, we can
now move on to writing code from scratch.

2014
03:07:49,230 --> 03:07:53,880
So the first thing that we want to do is to
create a blank panda's data frame. And we

2015
03:07:53,880 --> 03:07:57,890
saw how to do that we're going to call it
final data frame. And we're going to assign

2016
03:07:57,890 --> 03:08:03,660
it a value of PD dot data frame. And within
this class instantiation, we're going to pass

2017
03:08:03,660 --> 03:08:09,210
in columns equals my underscore columns. Now,
we saw before that we could have just called

2018
03:08:09,210 --> 03:08:12,729
this columns, but then you have columns equals
columns, and that can be a bit unreadable.

2019
03:08:12,729 --> 03:08:16,540
So this is what we're going to do to make
sure that that data frame was created properly,

2020
03:08:16,540 --> 03:08:20,640
we're going to print it out. And as you can
see, it is an empty panda's data frame with

2021
03:08:20,640 --> 03:08:24,930
four columns. And the column names are the
four names that we specified in this list

2022
03:08:24,930 --> 03:08:30,260
in the previous code cell. So now that that's
done, what we need to do is we need to loop

2023
03:08:30,260 --> 03:08:34,930
over every symbol string in our symbol, strings,
object. And to do that, we're going to say

2024
03:08:34,930 --> 03:08:42,860
for symbol string in single strings. And then
we need to actually create another loop inside

2025
03:08:42,860 --> 03:08:50,860
of here, that loops over every ticker in that
symbol string. So we're gonna say, for symbol

2026
03:08:50,860 --> 03:08:56,820
and symbol, underscore string dot split. And
you'll recall from the last two projects that

2027
03:08:56,820 --> 03:09:01,561
if we call this split method, what it does
is it basically does the opposite of this

2028
03:09:01,561 --> 03:09:06,320
join method that we saw in the last code cell.
So this is where it's going to be. And then

2029
03:09:06,320 --> 03:09:09,910
we're just going to print out a symbol. And
this will allow us to make sure that we're

2030
03:09:09,910 --> 03:09:13,970
actually iterating over every symbol in our
universe. Great. So it goes all the way from

2031
03:09:13,970 --> 03:09:20,740
a and this should go to z because these are
in order. Yep, all the way down to z. So that

2032
03:09:20,740 --> 03:09:25,790
looks like it's working. Okay. Alright, so
within the first for loop, but outside of

2033
03:09:25,790 --> 03:09:29,979
the second for loop, we're going to create
a variable, we're going to call that variable

2034
03:09:29,979 --> 03:09:36,480
batch API calls URL. And what is this going
to be, it's going to be a URL that is a string,

2035
03:09:36,480 --> 03:09:43,180
and it's going to be an F string. And it's
going to query this endpoint that we use earlier,

2036
03:09:43,180 --> 03:09:47,930
this quote endpoint for every stock in our
universe. And it's going to do that in batch

2037
03:09:47,930 --> 03:09:52,740
API calls for 100 stocks at a time now, to
get the proper syntax. for that. We're going

2038
03:09:52,740 --> 03:09:58,141
to go back to the AI x cloud docs, and we're
going to search for batch API. Call. Another

2039
03:09:58,141 --> 03:10:03,760
week off with anything. So I'm just going
to search for batch. And here you can see

2040
03:10:03,760 --> 03:10:09,700
batch requests. Now, I'm going to scroll down
here to this example, which is what we copied

2041
03:10:09,700 --> 03:10:14,230
in the past, I'm going to copy the link address,
I'm going to go back to my Jupyter Notebook.

2042
03:10:14,230 --> 03:10:17,820
I'm going to paste that in here. And then
we have to make a few modifications. So the

2043
03:10:17,820 --> 03:10:21,900
first thing we want to change is the symbols.
And all we're going to do here is we're going

2044
03:10:21,900 --> 03:10:28,520
to actually change them into an interpolated
value. This interpolated value should be symbol

2045
03:10:28,520 --> 03:10:33,570
underscore string. Now, what is that symbol
string variable, it is the iterator of this

2046
03:10:33,570 --> 03:10:40,030
first for loop. So it will be if you uncomment
this and run this. This is one example of

2047
03:10:40,030 --> 03:10:46,479
such a simple string that you can interpolate
into that API called URL. So we'll comment

2048
03:10:46,479 --> 03:10:50,352
that out and run it again. Great. So there's
a few other changes that we have to make to

2049
03:10:50,352 --> 03:10:55,340
this batch API call URL. One of the first
things is that if you look at the types of

2050
03:10:55,340 --> 03:11:00,470
API endpoints that we're hitting here, we
have, quote, we have news and we have chart,

2051
03:11:00,470 --> 03:11:05,100
we actually only need the quote endpoint.
So let's take away all the other ones. Awesome.

2052
03:11:05,100 --> 03:11:12,930
And then there's two other parameters specified
here, range and last. And we don't need either

2053
03:11:12,930 --> 03:11:18,940
of those. So we can take them both off and
replace them with our token equals is called

2054
03:11:18,940 --> 03:11:24,240
URL. All right, so let's just run this to
make sure that that's formatted properly.

2055
03:11:24,240 --> 03:11:28,479
And instead of this print statement, we're
going to comment it out and just replace it

2056
03:11:28,479 --> 03:11:38,910
with a pass keyword. Oops, ignore that. Alright,
so we're going to replace this with a pass

2057
03:11:38,910 --> 03:11:46,820
keyword. Great. So that ran properly, which
indicates that the syntax is okay. Now, it's

2058
03:11:46,820 --> 03:11:51,430
time for us to actually, so we've created
our API call URL, but we haven't actually

2059
03:11:51,430 --> 03:11:55,280
executed the HTTP request yet. And that's
what we'll do next. So to do that, we're going

2060
03:11:55,280 --> 03:12:01,560
to use the requests library to execute a get
request. And we're going to store that response

2061
03:12:01,560 --> 03:12:08,720
in a variable called data. So data equals
requests. Press dot get, and we're going to

2062
03:12:08,720 --> 03:12:16,811
pass in batch API call URL. And then we're
going to call the JSON method on that, actually,

2063
03:12:16,811 --> 03:12:21,540
no, we're just going to leave it as is. And
we're going to print data dot status, underscore

2064
03:12:21,540 --> 03:12:25,860
code for each one. Now, since there's six
entries in our list, if everything's working

2065
03:12:25,860 --> 03:12:33,440
properly, then this should print 206 times
we get 403 for each one. Now, this is actually

2066
03:12:33,440 --> 03:12:39,550
interesting. So I mentioned earlier that 405
100 codes and when I say 400, to 500, codes,

2067
03:12:39,550 --> 03:12:45,430
I don't mean exactly 400. And exactly 500.
I mean, anything from 400, to 499. And anything

2068
03:12:45,430 --> 03:12:49,590
from 500 to 599. These are generally indicate
error. So let's go look exactly what type

2069
03:12:49,590 --> 03:12:56,760
of error This is. Um, so type HTTP, or three,
run a search. And Wikipedia is actually pretty

2070
03:12:56,760 --> 03:13:01,590
good resource for this. It says the HTTP four
three is an HTTP status code, meaning access

2071
03:13:01,590 --> 03:13:07,710
to the requested resources forbidden for some
reason. Now, this is a very, very specific

2072
03:13:07,710 --> 03:13:15,070
HTTP response, that usually means that you
have you're not entering the proper API token.

2073
03:13:15,070 --> 03:13:18,899
And I'll show you exactly why that is, I know
what they're looking because we didn't change

2074
03:13:18,899 --> 03:13:25,680
this cloud keyword to sandbox. If we do that
again, and run it, we should get six 200 codes.

2075
03:13:25,680 --> 03:13:31,420
Awesome. 123456. Great. So the next thing
we need to do is actually parse the data and

2076
03:13:31,420 --> 03:13:36,729
using an append method, add it to the final
data frame. So we've seen this before, what

2077
03:13:36,729 --> 03:13:40,450
we need to do is add that here, we'll take
away this print statement in the past keyword.

2078
03:13:40,450 --> 03:13:49,320
And then we'll say, final underscore data
frame, equals file underscore data frame dot

2079
03:13:49,320 --> 03:13:53,040
append. And then within this append method,
we need to create a panda's series. We've

2080
03:13:53,040 --> 03:13:57,860
seen this before. And within that kind of
series, we need to create a Python list. So

2081
03:13:57,860 --> 03:14:02,790
what goes inside this Python list we need?
Basically, one data point for every column,

2082
03:14:02,790 --> 03:14:06,910
we need ticker price price earnings ratio
and the number of shares to buy. So we'll

2083
03:14:06,910 --> 03:14:14,461
say symbol. That's our ticker, we'll say data.
And then we'll parse out the latest price

2084
03:14:14,461 --> 03:14:20,850
data point and then we'll say data and we'll
parse out the PE ratio data point. And then

2085
03:14:20,850 --> 03:14:27,710
for the number of shares to buy, we will parse
out nothing and just say and under n slash

2086
03:14:27,710 --> 03:14:31,689
a. Now for this panda series, we have to specify
what the indexes will say index equals my

2087
03:14:31,689 --> 03:14:36,340
columns. This tells the append method, which
columns of the panda's data frame need to

2088
03:14:36,340 --> 03:14:41,230
be considered when you're appending it each
time, so that's very important. And then we

2089
03:14:41,230 --> 03:14:49,990
also need to add nor underscore index. Alright,
so if we run this code sell now and then print

2090
03:14:49,990 --> 03:14:55,720
out our final data frame, we should get a
data frame that has 505 rows, and each row

2091
03:14:55,720 --> 03:15:00,500
corresponds to one stock with the four metrics
that we selected. So with any luck, it should

2092
03:15:00,500 --> 03:15:05,230
run six And we're getting response object
is not so scriptable. I'll show you what the

2093
03:15:05,230 --> 03:15:10,750
problem is here. When we ran our HTTP request,
we didn't do dot JSON and to actually turn

2094
03:15:10,750 --> 03:15:18,870
it into a Python dictionary. So if we run
this now that should be fixed. Latest price.

2095
03:15:18,870 --> 03:15:25,370
Oh, I grossly oversimplified the person here.
So since this is a batch API call, we actually

2096
03:15:25,370 --> 03:15:31,030
need to do multiple levels of parsing. The
first is symbol. The second is which input

2097
03:15:31,030 --> 03:15:38,210
we want to hit. So if we add that to both
of these parses, we should be okay. Alright,

2098
03:15:38,210 --> 03:15:47,050
so here's our data frame, it goes from index
zero to index 504, which indicates that all

2099
03:15:47,050 --> 03:15:52,439
505 stocks have been successfully added. And
it has four columns ticker price, price to

2100
03:15:52,439 --> 03:15:56,700
earnings ratio, and the number of shares to
buy. So now that that's done, we can move

2101
03:15:56,700 --> 03:16:02,931
on to removing glamor stocks. Alright, so
now we need to remove the glamour stocks from

2102
03:16:02,931 --> 03:16:07,820
our panda's data frame. And for anyone who's
not familiar with the term glamour stock,

2103
03:16:07,820 --> 03:16:13,140
it's basically the term that's used to describe
the opposite of a value stock. So if a stock

2104
03:16:13,140 --> 03:16:17,800
ranks very poorly on value metrics, then instead
of being called a non value sock or something

2105
03:16:17,800 --> 03:16:22,240
like that, it's just called the glamour stock.
Now, since the goal of this strategy is to

2106
03:16:22,240 --> 03:16:26,649
identify the 50 best value stocks from our
universe, our next step is to remove glamor

2107
03:16:26,649 --> 03:16:30,491
stocks from the DataFrame. And to do this
will kind of follow similar logic as we did

2108
03:16:30,491 --> 03:16:35,260
before, we're going to sort the panda's data
frame such that the stocks with the lowest

2109
03:16:35,260 --> 03:16:39,851
price earnings ratios are at the top, and
then we're going to remove all of the entries

2110
03:16:39,851 --> 03:16:45,130
from the data frame except for stocks that
have that fall below the top 50 in that ranking

2111
03:16:45,130 --> 03:16:48,070
scheme. So let's do that. The first thing
we need to do is start the panda's data frame.

2112
03:16:48,070 --> 03:16:55,550
And to do that, we will say, final data frame,
dot sort underscore values. Now, you'll recall

2113
03:16:55,550 --> 03:16:59,840
that this is the exact same method applied
to the panda's data frame that we use to store

2114
03:16:59,840 --> 03:17:04,410
values in the momentum strategy section of
this course. And then what we want to pass

2115
03:17:04,410 --> 03:17:09,310
in first is the column that we want to start
out and that is price to earnings ratio, I

2116
03:17:09,310 --> 03:17:12,899
just tried to do a tab autocomplete and it
didn't work. So what I'm going to do is just

2117
03:17:12,899 --> 03:17:16,880
go up here and copy this. That means I don't
have to worry about making sure I get the

2118
03:17:16,880 --> 03:17:22,891
capitalization rate everything. The next thing
we need to do is specify the ascending parameter.

2119
03:17:22,891 --> 03:17:26,870
Now we want it to be descending, which means
that sending is equal to false. And the last

2120
03:17:26,870 --> 03:17:31,460
thing we need to say is in place equals true.
This parameter tells Panis that instead of

2121
03:17:31,460 --> 03:17:35,630
just returning a modified data frame, we want
to modify the original data frame, let's print

2122
03:17:35,630 --> 03:17:40,500
out the final data frame object to see if
this worked correctly. So as you can see,

2123
03:17:40,500 --> 03:17:47,040
we have a price earnings ratio of 2400 at
the top and a price earnings ratio of not

2124
03:17:47,040 --> 03:17:51,810
the bottom, I actually did this correctly,
this should be true. Now we see that our lowest

2125
03:17:51,810 --> 03:17:57,150
values are at the top and our highest values
are at the bottom. Now one important thing

2126
03:17:57,150 --> 03:18:00,450
to note with this is that since ascending
defaults, having a true value, we can actually

2127
03:18:00,450 --> 03:18:05,350
remove this completely. And it'll give it
the same output. As you see. Another thing

2128
03:18:05,350 --> 03:18:09,680
that's worth mentioning is that all of the
stocks that have negative price to earnings

2129
03:18:09,680 --> 03:18:13,899
ratios. If you think about the mathematical
definition of the price earnings ratio, it's

2130
03:18:13,899 --> 03:18:18,180
price divided by earnings. So in order for
price to earnings ratio to have a negative

2131
03:18:18,180 --> 03:18:22,850
value than either price has to be negative
or earnings has to be negative. Now, stocks

2132
03:18:22,850 --> 03:18:27,010
can't actually have a negative price. So what
this means is that these stocks have negative

2133
03:18:27,010 --> 03:18:33,940
earnings, there is kind of a wide body of
evidence to say that you might not want to

2134
03:18:33,940 --> 03:18:37,649
invest in stocks that have negative earnings.
So in a real investment strategy, you may

2135
03:18:37,649 --> 03:18:42,030
want to remove all stocks that have negative
price earnings ratios. And one easy way to

2136
03:18:42,030 --> 03:18:49,370
do that would be something like this final
data frame such that final data frame at the

2137
03:18:49,370 --> 03:18:57,689
price to earnings ratio column is greater
than zero. Now what is this return should

2138
03:18:57,689 --> 03:19:01,500
return the final data frame with all of the
negative values removed. So we're going to

2139
03:19:01,500 --> 03:19:07,850
include this and to actually modify the original
data frame, we have to assign it, you'll notice

2140
03:19:07,850 --> 03:19:12,480
that if we print this, this gives us the final
data frame with negative values. So what we're

2141
03:19:12,480 --> 03:19:18,110
going to do is take this out, we're gonna
say final data frame is equal to that. And

2142
03:19:18,110 --> 03:19:25,140
then we need to return just the top 50 stocks
according to this order schema. We saw how

2143
03:19:25,140 --> 03:19:29,960
to do that in the momentum project of this
course. But it's pretty easy. You just say

2144
03:19:29,960 --> 03:19:35,410
final data frame is equal to final underscore
data frame. And then you want to access out

2145
03:19:35,410 --> 03:19:42,420
with square brackets colon 50. Now if we print
this, it should be a data frame that ranges

2146
03:19:42,420 --> 03:19:48,439
from zero to 50. Okay, so this looks good
to me. There's a couple things we can do to

2147
03:19:48,439 --> 03:19:54,000
make sure that this is working properly. We
can print its length, this should be 50. Awesome.

2148
03:19:54,000 --> 03:19:57,590
And then the last thing we want to do is reset
its index so that the index actually runs

2149
03:19:57,590 --> 03:20:03,590
from zero to 50. So we'll do we underscore
index in this give us. Alright, as you can

2150
03:20:03,590 --> 03:20:09,760
see, this now goes from zero to 49, which
means there's 50 entries in the panda's data

2151
03:20:09,760 --> 03:20:14,190
frame, the only other thing we need to do
is get rid of this new index column, we saw

2152
03:20:14,190 --> 03:20:18,470
one way to do it in the last section of this
course, I'm gonna show you a different way

2153
03:20:18,470 --> 03:20:23,370
now. First, we're, one thing I've read here
is going to stay in place equals true within

2154
03:20:23,370 --> 03:20:28,780
this. And that means that the reset index
method will actually modify the original data

2155
03:20:28,780 --> 03:20:33,350
frame. Now, if we print this out, again, we
should see the modified data frame. Awesome.

2156
03:20:33,350 --> 03:20:38,320
And since I ran this twice, we actually have
two separate reset indices. So let's go back

2157
03:20:38,320 --> 03:20:44,479
up here. And we'll rerun this, we run this
and we run this and we should just have one

2158
03:20:44,479 --> 03:20:49,480
duplicate index. Okay. What we want to do
now is we're going to call the draw method,

2159
03:20:49,480 --> 03:20:55,200
we're going to pass in the index column, we're
also going to pass in in place equals true

2160
03:20:55,200 --> 03:21:01,210
here, what does this give us? It gives us
a key error because index is not found in

2161
03:21:01,210 --> 03:21:08,851
axis. Okay? The drop method, by definition
automatically acts on rows not on columns.

2162
03:21:08,851 --> 03:21:14,780
So to change that, we have to say x equals
one. What is this give us cannot insert level

2163
03:21:14,780 --> 03:21:19,410
underscore zero, it exists, that's because
we already ran that cell. So if we run this

2164
03:21:19,410 --> 03:21:26,729
now what happens? Alright, everything looks
to appears to have worked properly. So we'll

2165
03:21:26,729 --> 03:21:32,979
print this out again to make sure it looks
good. Awesome. So now let's just do a quick

2166
03:21:32,979 --> 03:21:38,439
recap of what we learned in this section.
I explained briefly what a glamor stock is,

2167
03:21:38,439 --> 03:21:42,500
we sorted our final data frames such that
the stocks with the lowest price earnings

2168
03:21:42,500 --> 03:21:47,280
ratios were at the top of the data frame,
and we specified the in place equals true

2169
03:21:47,280 --> 03:21:51,490
parameters so that the original data frame
was actually modified. And it didn't just

2170
03:21:51,490 --> 03:21:57,320
return a modified data frame. So that's what
that line does. Next up, we, we sorted the

2171
03:21:57,320 --> 03:22:02,891
data frames such that all rows that have a
price to earnings ratio value below zero were

2172
03:22:02,891 --> 03:22:07,810
dropped from the data frame, then we trim
the data frame to only include the stocks

2173
03:22:07,810 --> 03:22:12,320
with the 50 lowest price earnings ratios,
we reset the index, and then we drop the new

2174
03:22:12,320 --> 03:22:18,030
index column that was created by way of this
reset index method. Now, one important thing

2175
03:22:18,030 --> 03:22:21,520
to note about this is that we could have actually
specified the drop parameter here to do the

2176
03:22:21,520 --> 03:22:25,150
same thing. That's what we did in the last
section. But the reason why I showed you this

2177
03:22:25,150 --> 03:22:28,851
method instead, is just to reinforce the idea
that whenever you're doing any kind of software

2178
03:22:28,851 --> 03:22:33,950
development, there's usually multiple different
ways to solve a given problem. So that's that,

2179
03:22:33,950 --> 03:22:38,100
Let's now move on to calculating the number
of shares that we need to buy. Just like we

2180
03:22:38,100 --> 03:22:42,840
did in the momentum strategy section of this
course, we're going to use the portfolio input

2181
03:22:42,840 --> 03:22:47,710
function to do this. And to make things easy
for you, I actually included the portfolio

2182
03:22:47,710 --> 03:22:54,229
input function there, I encourage you to try
to delete that formula and recreate it from

2183
03:22:54,229 --> 03:22:58,939
scratch, scratch, if you want the extra practice.
For now, I'm just going to run this. And then

2184
03:22:58,939 --> 03:23:03,490
I'm going to use the portfolio input function
to accept a portfolio size variable. So let's

2185
03:23:03,490 --> 03:23:09,210
do that. And I'm going to test here that the
try accept value error statement is working

2186
03:23:09,210 --> 03:23:14,939
by putting in a string, so I'm going to say
my portfolio is $1 million. And then if I

2187
03:23:14,939 --> 03:23:20,020
enter this, then it should print it. That's
not a number of try again. Awesome. Now I

2188
03:23:20,020 --> 03:23:28,860
can say $1 million, so that six zeros 123456.
Awesome. The next thing we need to do is calculate

2189
03:23:28,860 --> 03:23:37,460
the position size. So just like we did before,
position size can be calculated by dividing

2190
03:23:37,460 --> 03:23:42,990
the portfolio size by the number of shares
in the portfolio. So we're going to position

2191
03:23:42,990 --> 03:23:47,360
size divided by the length of our final data
frame. And you can take any column of this

2192
03:23:47,360 --> 03:23:52,260
data frame to find its length, I'm going to
use the index and there's no kind of right

2193
03:23:52,260 --> 03:23:56,270
or wrong answer here. I just the index is
what I typically use for this. So that's that,

2194
03:23:56,270 --> 03:24:03,020
and this position size should be $20,000,
I believe. Now here it says type error unsupported

2195
03:24:03,020 --> 03:24:07,120
operand type. That's because this portfolio
size, despite it actually being a number,

2196
03:24:07,120 --> 03:24:12,090
it's still formatted as a string, so we need
to wrap it in a float function. This gives

2197
03:24:12,090 --> 03:24:20,340
us $20,000. Awesome. Now we need to loop through
the every row in the panda's data frame, and

2198
03:24:20,340 --> 03:24:24,430
modify the value that's contained in the number
of shares to buy column. So to do that, we're

2199
03:24:24,430 --> 03:24:36,260
going to say for row in in final data frame
dot index, and then we are going to say, final

2200
03:24:36,260 --> 03:24:41,450
data frame dot LSE. This is the exact same
method that we used to modify this before.

2201
03:24:41,450 --> 03:24:48,300
We're going to do row and then number of shares
to buy. Then we're going to use the assignment

2202
03:24:48,300 --> 03:24:57,750
operator to say divide that stocks or sorry
to divide our position, size by that stocks

2203
03:24:57,750 --> 03:25:05,240
stock price. So We put pricing here. That
should be the trick. Now we'll print out our

2204
03:25:05,240 --> 03:25:10,121
final data frame to make sure that this is
operating correctly. This looks good. Let's

2205
03:25:10,121 --> 03:25:15,380
just compare two stocks here. So we have a
stock at $35 and a stock at $18. So this is

2206
03:25:15,380 --> 03:25:19,580
interesting, because this is roughly double
this. So this should be roughly double this,

2207
03:25:19,580 --> 03:25:24,271
and it kind of passes the eyeball test. So
that's good. Now, the only other thing we

2208
03:25:24,271 --> 03:25:29,490
need to add here is the floor function. So
as you'll recall from the last section of

2209
03:25:29,490 --> 03:25:35,750
or the last project of this course, you can
usually buy fractional shares at some brokers.

2210
03:25:35,750 --> 03:25:40,141
So if we wrap this in the floor function,
it will give us the closest lower integer

2211
03:25:40,141 --> 03:25:43,490
to the number of shares that are calculated.
So if we run this, we can see that those have

2212
03:25:43,490 --> 03:25:49,140
all been transformed to integers. Awesome.
We are now ready to move on to building a

2213
03:25:49,140 --> 03:25:54,940
better and more realistic value strategy.
All right, so it is now it's time for us to

2214
03:25:54,940 --> 03:26:01,180
build a better and more realistic value strategy.
Now, just like in the momentum project that

2215
03:26:01,180 --> 03:26:04,810
we built earlier in this course, what we're
going to do to make a better value strategy

2216
03:26:04,810 --> 03:26:10,210
is to build a strategy that takes into account
many different metrics. And the reason why

2217
03:26:10,210 --> 03:26:14,620
that makes the strategy better is because
every valuation metrics tend to have certain

2218
03:26:14,620 --> 03:26:19,810
flaws. For example, as we saw earlier in this
project, the price to earnings ratio doesn't

2219
03:26:19,810 --> 03:26:25,310
exactly work that well with stocks that have
negative earnings. Similarly, another popular

2220
03:26:25,310 --> 03:26:30,420
valuation metric is the price to book value
ratio. And that ratio doesn't work well with

2221
03:26:30,420 --> 03:26:34,920
stocks that perform a bunch of share buybacks.
So there's lots of different things to consider

2222
03:26:34,920 --> 03:26:40,090
for every valuation metric. And one common
way that investment managers reduce any of

2223
03:26:40,090 --> 03:26:45,979
the flaws, reduce the impact of any specific
valuation metrics flaws, is by creating value

2224
03:26:45,979 --> 03:26:50,530
strategies that take into account a compensated
value. So instead of just saying, we're going

2225
03:26:50,530 --> 03:26:55,479
to rank stocks on price to earnings ratio,
they rank percentiles for a bunch of different

2226
03:26:55,479 --> 03:26:59,570
valuation metrics, and then rank stocks according
to the average of those percentile scores.

2227
03:26:59,570 --> 03:27:04,710
So that's exactly what we're gonna do in this
section. Here are all the ratios we consider.

2228
03:27:04,710 --> 03:27:10,990
So price to earnings ratio, we already saw
that price to book ratio. Now, this is the

2229
03:27:10,990 --> 03:27:16,340
company's stock price, the company's stock
price divided by its shareholders equity per

2230
03:27:16,340 --> 03:27:22,050
share, the price to sales ratio, this is the
company's stock price divided by its revenue

2231
03:27:22,050 --> 03:27:28,330
per share enterprise value divided by EBITDA.
Now, that is a more complicated valuation

2232
03:27:28,330 --> 03:27:32,229
metric, even R stands for earnings before
interest, taxes, depreciation, amortization,

2233
03:27:32,229 --> 03:27:38,490
enterprise value is basically the number that
you would have to pay to buy out the company

2234
03:27:38,490 --> 03:27:41,670
in full. So that doesn't just mean buying
it all at a stock, you would have to also

2235
03:27:41,670 --> 03:27:46,400
buy it all of his debt and any minority shareholdings
that exists. So that's what enterprise value

2236
03:27:46,400 --> 03:27:51,190
is. And then another column valuation metric
is enterprise value divided by gross profit.

2237
03:27:51,190 --> 03:27:57,910
So all of these five valuation metrics, we're
going to now pull in from the i x cloud API.

2238
03:27:57,910 --> 03:28:02,391
Now to do that, we're going to start by just
making a single API call. And then we will

2239
03:28:02,391 --> 03:28:07,170
loop through that same API call for a bunch
of different stocks that are listed in our

2240
03:28:07,170 --> 03:28:10,600
stock data structure to build a panda's data
frame that contains all the data. So to start,

2241
03:28:10,600 --> 03:28:18,660
we'll just do this for one symbol, and that
symbol is going to be apple. And then we're

2242
03:28:18,660 --> 03:28:24,270
going to do a batch API call here. And unlike
before, we're not going to use a batch API

2243
03:28:24,270 --> 03:28:30,270
call because we want to query the i x cloud
API for multiple symbols. But instead, we

2244
03:28:30,270 --> 03:28:35,450
have to do use a batch API call because we're
querying the API for multiple endpoints. So

2245
03:28:35,450 --> 03:28:40,570
since the different valuation measures listed
here are all so different, they're not all

2246
03:28:40,570 --> 03:28:45,720
actually going to be stored in the same endpoint.
So we need to find where they are in the iOS

2247
03:28:45,720 --> 03:28:50,510
prod API, and then add those endpoints to
a batch API call URL. So let's start by just

2248
03:28:50,510 --> 03:28:56,950
creating the variable batch API call URL.
And just like before, this is going to be

2249
03:28:56,950 --> 03:29:04,711
an F string. Now let's to make this easy,
we're just going to base this off of the batch

2250
03:29:04,711 --> 03:29:08,370
API calls that we executed earlier in this
project. So let's scroll up and find that.

2251
03:29:08,370 --> 03:29:15,880
Alright, so here is where it is, I am going
to highlight all of this and copy it to my

2252
03:29:15,880 --> 03:29:21,070
clipboard, I'm going to scroll back down to
where we were just working and paste this

2253
03:29:21,070 --> 03:29:26,960
in. Okay, now, we have to make a few changes
here. The first is that we need to replace

2254
03:29:26,960 --> 03:29:33,350
this symbol string with just symbol. And then
let's actually execute an API call against

2255
03:29:33,350 --> 03:29:38,110
this to make sure that it's working properly.
So we've seen this many times by now. But

2256
03:29:38,110 --> 03:29:43,011
we're going to do data equals and then to
define the variable we're going to say requests

2257
03:29:43,011 --> 03:29:51,100
dot get, and then we're going to pass in that
batch API call URL, not the data URL, batch,

2258
03:29:51,100 --> 03:29:57,170
API call URL. And then let's do print data
dot status underscore code. And if this returns

2259
03:29:57,170 --> 03:30:02,721
200, then we know it's working correctly.
That is all Okay, so let's go through all

2260
03:30:02,721 --> 03:30:07,710
of these metrics one by one, I'm actually
going to copy these, and paste them down here

2261
03:30:07,710 --> 03:30:16,630
and comment them all out. Oops, sorry not
to do. There we go. And then underneath each

2262
03:30:16,630 --> 03:30:27,290
of these comments, we're actually going to
parse that value from the IRS cloud API. So

2263
03:30:27,290 --> 03:30:30,950
the first thing we need to do is get the price
earnings ratio. And we actually saw how to

2264
03:30:30,950 --> 03:30:37,220
do this in the last section of this tutorial.
So if you go back up here, we are going to

2265
03:30:37,220 --> 03:30:44,540
go to where we copied this original batch
API call URL. And we are just going to grab

2266
03:30:44,540 --> 03:30:50,830
this parse here. So it's data and then symbol,
and then quote, and then PE ratio. So let's

2267
03:30:50,830 --> 03:30:56,070
copy that and scroll back down to where we
were just working, which is right here. And

2268
03:30:56,070 --> 03:31:05,439
if we print this, this should give us what
we need. Okay, now we're getting this error

2269
03:31:05,439 --> 03:31:10,939
response object is not subscript well, and
that's because I haven't called the JSON method

2270
03:31:10,939 --> 03:31:15,240
on our API call. So we're going to add that
here. And then we're going to remove this

2271
03:31:15,240 --> 03:31:20,090
data status code, because that's now going
to return an error. Let's run this code cell

2272
03:31:20,090 --> 03:31:26,430
again. Great. So this tells us that Apple
has a current price earnings ratio of 38.84,

2273
03:31:26,430 --> 03:31:37,190
according to the i x cloud API. Let's now
assign this variable to it for this value

2274
03:31:37,190 --> 03:31:43,730
to a variable called PE ratio. And we're going
to do similar things down here. So PB ratio

2275
03:31:43,730 --> 03:31:48,261
is going to be pairs to book ratio. And for
now, we're just going to assign that a value

2276
03:31:48,261 --> 03:31:53,040
of not a number. So this is a not a number
data structure that's stored within the NumPy

2277
03:31:53,040 --> 03:31:56,830
library. If you've never seen that before,
in order to do a P, or sorry, p s ratio, same

2278
03:31:56,830 --> 03:32:04,450
thing, np dot n a n. And then down here, we're
going to do Evie to either that same thing,

2279
03:32:04,450 --> 03:32:15,000
np.na n. And then we're going to do Evie to
gross profit, Evie to gross profit equals

2280
03:32:15,000 --> 03:32:19,840
np.mn. Okay, we've now filled these all with
placeholder values of NP dot and n. Let's

2281
03:32:19,840 --> 03:32:27,100
now go into the IRS cloud docs, and figure
out where these data points are contained

2282
03:32:27,100 --> 03:32:32,200
within the i x cloud API. So just like before,
all I did for this was I Google is cloud docs.

2283
03:32:32,200 --> 03:32:39,141
And it's the first non add, hit clicking.
Alright, so now I'm going to do a Ctrl F search

2284
03:32:39,141 --> 03:32:47,210
for PB. and with any luck, this will show
us where the price to book ratio is held.

2285
03:32:47,210 --> 03:32:52,700
There were seven hits, I just searched through
all of them. I didn't, it wasn't any of them.

2286
03:32:52,700 --> 03:32:59,860
So now I'm going to track the price to book
it only gets two hits. And both of those hits

2287
03:32:59,860 --> 03:33:06,050
are this value score, which looks like it's
its own composite metric here. So let's try

2288
03:33:06,050 --> 03:33:13,979
price to book with hyphens. There we go price
to book, what endpoint is this. So this is

2289
03:33:13,979 --> 03:33:18,610
the advanced stats endpoint. And to add that
to our batch API call URL, I'm just going

2290
03:33:18,610 --> 03:33:26,540
to copy it. And I'm going to add it here right
after the quote. So comma advanced stats.

2291
03:33:26,540 --> 03:33:33,641
So now we are going to print our data object
and see what we have to parse out. So do that.

2292
03:33:33,641 --> 03:33:37,620
Alright, so we're gonna have to do multiple
levels of parsing here, we're going to print

2293
03:33:37,620 --> 03:33:48,660
data, Apple. And then within that, we are
going to parse out the advanced stats endpoint.

2294
03:33:48,660 --> 03:33:54,680
Alright, so now when we run this code sale,
this will show us what's contained inside

2295
03:33:54,680 --> 03:34:00,670
the advanced tests endpoint, we want PB ratio.
So I'm going to do a Ctrl F for PB here and

2296
03:34:00,670 --> 03:34:06,680
see if it highlights anything. I don't see
it there. So I'm going to do a Ctrl F for

2297
03:34:06,680 --> 03:34:12,620
book. And I see it right there. So price to
book. Now we can copy this in and parse it

2298
03:34:12,620 --> 03:34:18,450
out. Alright, so this tells us that Apple
has a current price to book ratio of 23.8.

2299
03:34:18,450 --> 03:34:27,360
I'm going to copy this and assign it to our
variable of PB underscore ratio. Then what

2300
03:34:27,360 --> 03:34:33,020
I'm going to do is I'm going to remove the
final section of parsing from this line, I'm

2301
03:34:33,020 --> 03:34:36,620
going to print out the JSON object again,
and I'm going to try to find the price to

2302
03:34:36,620 --> 03:34:43,550
sales ratio. So just like before, I will start
by saying PS. There is one hit within this

2303
03:34:43,550 --> 03:34:47,860
data structure, but it's TTM ups. If you've
never seen that before, all that stands for

2304
03:34:47,860 --> 03:34:54,780
is trailing 12 months earnings per share.
And that's no and that's not what we want.

2305
03:34:54,780 --> 03:34:59,970
So I'm going to do a Ctrl F search again for
sales. And you can see right here, we have

2306
03:34:59,970 --> 03:35:04,260
price to sales ratio. Awesome. So I'm going
to do is I'm going to copy this price to book

2307
03:35:04,260 --> 03:35:10,930
ratio data point and instead of price to book,
I'm going to change this to price to sales.

2308
03:35:10,930 --> 03:35:16,300
And then I'm going to print the PS ratio so
that we can see what value we get. So this

2309
03:35:16,300 --> 03:35:22,590
tells us at the bottom here, that Apple has
a current price to sales ratio of $8.20, or

2310
03:35:22,590 --> 03:35:28,550
sorry, 8.28. So I can delete that. Now we
have to parse out enterprise value to EBITDA,

2311
03:35:28,550 --> 03:35:33,140
and enterprise value to gross profit. Now,
both of these are a little more complex, but

2312
03:35:33,140 --> 03:35:38,149
we can still make it work. The reason they're
more complex is because the V to EBIT ratio

2313
03:35:38,149 --> 03:35:44,490
and the EB to gross profit ratio, they aren't
actually provided explicitly by the IAS cloud

2314
03:35:44,490 --> 03:35:49,090
API. Instead, we're going to have to pull
in their constituent metrics. So enterprise

2315
03:35:49,090 --> 03:35:54,830
value, and Eva, or enterprise value and gross
profit respectively. And then we're going

2316
03:35:54,830 --> 03:35:59,590
to have to do the division ourselves. So to
start, let's try and find enterprise value,

2317
03:35:59,590 --> 03:36:05,120
we'll create a variable called enterprise
value. And to start we'll assign that a value

2318
03:36:05,120 --> 03:36:10,320
of np.na n. And then we're going to want to
do a Ctrl F search within this endpoint for

2319
03:36:10,320 --> 03:36:17,400
enterprise. And, interestingly enough, the
ice cloud API does provide one of the enterprise

2320
03:36:17,400 --> 03:36:20,020
multiples, but its enterprise value to revenue,
which is not one of the ones we're going to

2321
03:36:20,020 --> 03:36:24,660
use. So instead, we're going to pull in this
enterprise value. And point, we're going to

2322
03:36:24,660 --> 03:36:30,250
grab this for price to sales, and we're going
to copy it down to the enterprise value variable,

2323
03:36:30,250 --> 03:36:37,060
and then replace this with enterprise value.
And then let's print it now since Apple is

2324
03:36:37,060 --> 03:36:40,450
a very large company, this enterprise value
should be huge. Yeah, it looks like it's more

2325
03:36:40,450 --> 03:36:45,229
than 2 trillion if I'm just eyeballing it
there. Actually, let's divide that by trying

2326
03:36:45,229 --> 03:36:53,130
to see if I'm right one, and then we should
be nine zeros 12345678. Sorry, not nine zeros,

2327
03:36:53,130 --> 03:36:59,141
12 zeros. So in three more 123. And it looks
like it's around $2.2 trillion of enterprise

2328
03:36:59,141 --> 03:37:04,070
value for Apple right now, which is pretty
crazy. Alright, so we have our enterprise

2329
03:37:04,070 --> 03:37:09,610
value. Now we need our EDA, let's do a Ctrl
F search for Eva, and see if it pops up in

2330
03:37:09,610 --> 03:37:14,010
this endpoint. You can see right there that
it is pretty easy to access, what we'll do

2331
03:37:14,010 --> 03:37:19,390
is we'll just copy this, paste it there, or
change the variable name to Eva, and then

2332
03:37:19,390 --> 03:37:24,010
change the parsing to Eva as well. It's all
capitals, so make sure you capitalize this

2333
03:37:24,010 --> 03:37:28,280
as you're working through it. And then for
our Evie to EBIT ratio, what we're just going

2334
03:37:28,280 --> 03:37:37,160
to do is say enterprise underscore value divided
by and that ran correctly, what we need to

2335
03:37:37,160 --> 03:37:42,670
do now is printed to see what value we're
actually storing Evie to EBIT. So this tells

2336
03:37:42,670 --> 03:37:48,320
us that Apple has a current Evie to EBIT ratio
of 28.2. Awesome. So using this information,

2337
03:37:48,320 --> 03:37:54,490
we can now proceed to calculating our Evie
to gross profit, we already have our enterprise

2338
03:37:54,490 --> 03:37:59,670
value, and it's sort of a variable up here.
So what we need to do now is create a variable

2339
03:37:59,670 --> 03:38:05,680
called gross profit and parse out the gross
profit number from this from this JSON object.

2340
03:38:05,680 --> 03:38:11,590
So to do that, I'm going to do a Ctrl F search
for gross. And you can see the gross profit

2341
03:38:11,590 --> 03:38:16,860
metric is right there. So what I'm going to
do is copy the parsing that we did for our

2342
03:38:16,860 --> 03:38:21,360
EBIT variable earlier in this Kotel, I'm going
to paste it here. And then I'm going to replace

2343
03:38:21,360 --> 03:38:27,060
the image parsing with a gross profit parsing.
Now if we print out gross profit, what does

2344
03:38:27,060 --> 03:38:34,301
it give us? This shows you that Apple had
gross profit of I'm going to say that's 10

2345
03:38:34,301 --> 03:38:38,320
billion, I'm not really sure, just by looking
at it, there's no commas, which makes it a

2346
03:38:38,320 --> 03:38:42,320
little harder to read. Anyways, the numbers
being pulled out successfully, that's the

2347
03:38:42,320 --> 03:38:50,410
main thing. So now what we're going to do
is say Evie, to gross profit is equal to enterprise

2348
03:38:50,410 --> 03:38:57,140
value, divided by gross profit. And then we
will print this on the next line print, Evie

2349
03:38:57,140 --> 03:39:01,050
to gross profit. And I'm actually gonna run
this code set again with that statement. So

2350
03:39:01,050 --> 03:39:06,990
this shows us that Apple has an end to gross
profit ratio of 22.6. Okay, so we've now done

2351
03:39:06,990 --> 03:39:11,290
all of the parsing and calculations that we
need to get all of our value metrics for one

2352
03:39:11,290 --> 03:39:15,689
stock. Now it's time for us to generalize
this logic and build a panda's data frame

2353
03:39:15,689 --> 03:39:21,180
that stores all of this information. So we'll
do that next. Now, you'll see in the header

2354
03:39:21,180 --> 03:39:25,700
for this code sale that he says you'll notice
that I use the abbreviation RV often and that's

2355
03:39:25,700 --> 03:39:29,520
what we're going to use for robust value,
which is kind of the name I'm going to use

2356
03:39:29,520 --> 03:39:34,240
for this investment strategy. It's kind of
the equivalent to high quality momentum that

2357
03:39:34,240 --> 03:39:39,479
we use in the last project. So as before,
the first thing we need to do is say RV underscore

2358
03:39:39,479 --> 03:39:42,979
columns. And then we need to create a Python
list that defines all of the columns that

2359
03:39:42,979 --> 03:39:47,630
we're going to use in our panda's data frame.
So the first thing will be ticker that's the

2360
03:39:47,630 --> 03:39:52,859
stock ticker of the company we're looking
at. The next thing will be price and that

2361
03:39:52,859 --> 03:39:59,149
is the stock price of the company we're looking
at. The next thing is number of shares to

2362
03:39:59,149 --> 03:40:04,780
buy Just like in our first two projects that
tells our trader team how many shares of the

2363
03:40:04,780 --> 03:40:09,250
specific security to buy when they're rebalancing.
And now we're going to start working through

2364
03:40:09,250 --> 03:40:16,080
all of our valuation metrics. So more specifically,
we're going to say, price to earnings ratio.

2365
03:40:16,080 --> 03:40:22,840
And then we're going to say a percentile score
for price earnings ratio. So we'll call that

2366
03:40:22,840 --> 03:40:29,870
P e percentile. And then we're going to we
need a column for our price to book ratio,

2367
03:40:29,870 --> 03:40:33,860
so price to book ratio. And then we need a
column for the percentile score of price to

2368
03:40:33,860 --> 03:40:41,880
book so PB percentile. And then we need a
column for our price to sales ratio. So that's

2369
03:40:41,880 --> 03:40:50,590
the price to sales ratio. And then we need
price to actually we'll say p s percentiles,

2370
03:40:50,590 --> 03:40:55,811
and that matches the abbreviation that we
use for our first two percentile scores. And

2371
03:40:55,811 --> 03:41:00,900
then we need enterprise value divided by Earnings
Before Interest taxes, depreciation amortization.

2372
03:41:00,900 --> 03:41:04,960
So So for that, we're just to bring it right
from the get go because it's quite long. And

2373
03:41:04,960 --> 03:41:10,640
we will say, Evie, to EBIT, da. And then on
the next line, we will do a percentile score

2374
03:41:10,640 --> 03:41:16,650
for that metric. So Evie to EBIT. percentile.
And then we need our Evie to gross profit.

2375
03:41:16,650 --> 03:41:24,750
So we'll say Eb to GP and then Eb two, Eb
to gross profit percentile. The last thing

2376
03:41:24,750 --> 03:41:31,110
we need to do is calculate our robots value
score. So we'll do that right from the get

2377
03:41:31,110 --> 03:41:33,630
go, this time, our RB score, awesome, I'm
gonna run this code sale just to make sure

2378
03:41:33,630 --> 03:41:37,280
that the syntax here is all working, that
is awesome, we can now move on to creating

2379
03:41:37,280 --> 03:41:41,970
an empty panda's data frame. So we'll call
this data frame RV data frame. And that stands

2380
03:41:41,970 --> 03:41:47,609
for robust value data frame. And to associate
it we're gonna say, PD data frame. And then

2381
03:41:47,609 --> 03:41:52,979
inside of this class call, we're going to
say columns equals RV underscore columns.

2382
03:41:52,979 --> 03:41:58,630
And what does that look like? It doesn't look
like anything because I didn't check it out

2383
03:41:58,630 --> 03:42:03,840
yet. So let's add RV DataFrame on the last
line. And as you can see, this has all of

2384
03:42:03,840 --> 03:42:10,790
the columns that we specified, and we are
ready to start creating our loop. Now, we

2385
03:42:10,790 --> 03:42:15,590
have already created our symbol strings object
earlier in this project. So if you scroll

2386
03:42:15,590 --> 03:42:22,860
up here, a little further, what am I looking
for? Here is so this code cell was already

2387
03:42:22,860 --> 03:42:27,241
provided when you guys open this up. And this
is created simple strings that we can loop

2388
03:42:27,241 --> 03:42:30,859
through when creating our data frame. So we
don't have to do that, again, because those

2389
03:42:30,859 --> 03:42:35,149
variable values are already stored in this
Jupyter Notebook. So we're ready to create

2390
03:42:35,149 --> 03:42:42,859
the loop. All we need to do now is say, for
symbol string in symbol strings, and to make

2391
03:42:42,859 --> 03:42:48,870
sure this is looping correctly, let's just
print out the single string. Awesome, that

2392
03:42:48,870 --> 03:42:54,240
looks good. And then within this loop, we
have to create our batch API call. And we're

2393
03:42:54,240 --> 03:42:57,730
gonna do that in the same way that we did
before, we're first gonna create the URL.

2394
03:42:57,730 --> 03:43:02,740
And then once the URL has been created, we're
going to use our requests library to actually

2395
03:43:02,740 --> 03:43:12,010
execute the HTTP request. So we'll call the
URL batch API call URL. And then we already

2396
03:43:12,010 --> 03:43:17,770
created this URL a few cells earlier. So we
can just go up to here and copy this with

2397
03:43:17,770 --> 03:43:24,181
a few minor changes. So the minor changes
I was referring to are that we have to replace

2398
03:43:24,181 --> 03:43:30,280
this symbol with symbol string, and that it
should be good to go. To make sure this is

2399
03:43:30,280 --> 03:43:39,620
working properly. I'm just going to print
the batch API call URL. Let's see what happens.

2400
03:43:39,620 --> 03:43:45,860
Awesome. You can test easily whether any of
these is working by just clicking on and what

2401
03:43:45,860 --> 03:43:50,590
that will do is in a separate browser window,
it will open up the JSON object that you'll

2402
03:43:50,590 --> 03:43:55,450
be pulling in. So let's see, awesome in a
browser window like this, this is pretty useless,

2403
03:43:55,450 --> 03:43:59,160
because you can't really manipulate it. But
that's a quick easy way to tell that your

2404
03:43:59,160 --> 03:44:03,721
API calls working right. Now let's execute
our HTTP request. So we're gonna do that in

2405
03:44:03,721 --> 03:44:10,390
the exact same way that we did before data
is equal to requests dot get. And then inside

2406
03:44:10,390 --> 03:44:20,880
that get method pass in batch. API, call the
URL. And then we're going to print out data

2407
03:44:20,880 --> 03:44:28,090
dot status code. And since we already clicked
on the URL to open up the JSON object in a

2408
03:44:28,090 --> 03:44:31,540
separate tab a few moments ago, we know that
these API calls are working. But printing

2409
03:44:31,540 --> 03:44:35,570
the status code is another way you can check
it. So if these API calls are functioning

2410
03:44:35,570 --> 03:44:40,770
as we want them to, this should print out
HTTP code of 200 for each API call. So let's

2411
03:44:40,770 --> 03:44:48,101
see. 123456 and it should be six. So that
is awesome. All right. So now we're ready

2412
03:44:48,101 --> 03:44:52,020
to start parsing our data frame. And to do
that, the first thing you need to do is add

2413
03:44:52,020 --> 03:44:58,150
the JSON method to the request dot get method
and what this does is it turns this object

2414
03:44:58,150 --> 03:45:02,979
which is a request response object in To a
JSON for us to manipulate. Now, if you print

2415
03:45:02,979 --> 03:45:07,570
out the data for each one will be a bunch
of big JSON objects. And this is what we need

2416
03:45:07,570 --> 03:45:11,910
to start manipulating. So now that we're in
here, we need to loop through every ticker

2417
03:45:11,910 --> 03:45:16,670
within our symbol string, and append the data
for that ticker to our empty panda's data

2418
03:45:16,670 --> 03:45:20,930
frame. To do that, we need an inner loop.
And that inner loop will look like this. We'll

2419
03:45:20,930 --> 03:45:27,771
say for symbol in symbol, underscore string
dot split. And then we're going to split on

2420
03:45:27,771 --> 03:45:31,160
the column character just like we did in the
other two projects. To make sure this is working

2421
03:45:31,160 --> 03:45:38,070
properly, let's print out our symbol. Awesome.
So you can see we're going through all of

2422
03:45:38,070 --> 03:45:42,710
the symbols in our stocks, panda's data frame
that we created at the very start of this

2423
03:45:42,710 --> 03:45:47,410
Jupyter Notebook. And we're printing them
out in alphabetical order. Okay, so now that

2424
03:45:47,410 --> 03:45:52,880
that's done, we can start using the append
method to add data to our empty panda's data

2425
03:45:52,880 --> 03:45:58,770
frame. And to do that, what we're gonna say
is RV data frame is equal to RV underscore

2426
03:45:58,770 --> 03:46:04,350
data frame dot append. Now we're gonna use
same, we're gonna use similar logic inside

2427
03:46:04,350 --> 03:46:07,380
of this head method as we've used earlier
in this course. So when you attend a series,

2428
03:46:07,380 --> 03:46:13,000
and then inside of that panda's series, we
need a Python list. And we also need to specify

2429
03:46:13,000 --> 03:46:21,771
index is equal to RV columns. Now, in case
you're not remembering what this does, this

2430
03:46:21,771 --> 03:46:26,990
index equals RV columns specifies which columns
of the empty panda's data frame, each item

2431
03:46:26,990 --> 03:46:32,359
of this pandas series should be appended to,
and then inside of the pandas series, we want

2432
03:46:32,359 --> 03:46:38,800
to add the ignore index equals true. Now,
I haven't really done a super job explaining

2433
03:46:38,800 --> 03:46:43,780
this. But to be very specific, what this does
is it means that every row that you add to

2434
03:46:43,780 --> 03:46:48,351
the panda's data frame will have its index
column automatically calculated for you. So

2435
03:46:48,351 --> 03:46:53,110
the first row will have index zero, the second
row will have index one, the third row will

2436
03:46:53,110 --> 03:46:58,100
have index to the 50th row will have index
49, and so on. So that's what this ignore

2437
03:46:58,100 --> 03:47:04,280
index does. Now, within this panda series,
we need to parse out all of these data points.

2438
03:47:04,280 --> 03:47:07,649
So like I did in the last project, what I'm
going to do here is I'm actually just going

2439
03:47:07,649 --> 03:47:12,641
to copy these in. And since it's a comma separated
list, we can just replace each element of

2440
03:47:12,641 --> 03:47:16,649
this list with the data that we want to parse
out. So we'll do that one by one ticker, we

2441
03:47:16,649 --> 03:47:22,600
want to replace with symbol. And remember
that symbol is the incrementer of the inner

2442
03:47:22,600 --> 03:47:26,310
for loop that we're building here. For price,
we want to parse it with price. And we saw

2443
03:47:26,310 --> 03:47:31,359
how to do that up here. That's actually not
true, we didn't see how to do that there.

2444
03:47:31,359 --> 03:47:39,550
But what we can do is go back up to our earlier
project where we did this for for just a screener

2445
03:47:39,550 --> 03:47:44,550
that only factors in price earnings ratio,
we can copy this parsing that we use here.

2446
03:47:44,550 --> 03:47:54,370
So we'll do that and scroll back down here.
And then we want to replace this price with

2447
03:47:54,370 --> 03:48:00,000
that awesome. Now number of shares to buy
just like in the in the other projects that

2448
03:48:00,000 --> 03:48:06,120
we worked on in this course were replaced
with a placeholder value and a price earnings

2449
03:48:06,120 --> 03:48:10,609
ratio we actually parsed in the last code
cell along with all of the other valuation

2450
03:48:10,609 --> 03:48:15,740
metrics that we need. So what we can do here
is just say, copy that and add it where the

2451
03:48:15,740 --> 03:48:19,950
price earnings ratio is. And then we come
to the section where we need price to earnings

2452
03:48:19,950 --> 03:48:25,640
ratio percentile and all of the percentile
scores in this pandas DataFrame, just like

2453
03:48:25,640 --> 03:48:31,080
in the ones that we worked with earlier in
this course, we're going to replace them with

2454
03:48:31,080 --> 03:48:33,640
a place where the value of na, because in
order to calculate percentiles, you need the

2455
03:48:33,640 --> 03:48:38,750
panda's data frame to be fully populated first.
So we will calculate these a little later

2456
03:48:38,750 --> 03:48:51,280
on in this project. For now, we're going to
replace them all with an A. And one more.

2457
03:48:51,280 --> 03:48:56,830
And for that matter, this robust value score
in the last column also needs here. So let's

2458
03:48:56,830 --> 03:49:02,990
do that now to Alright, the next thing we
need is our price to book ratio. And just

2459
03:49:02,990 --> 03:49:06,950
like the price to earnings ratio, we had parsed
that out in the last Cosell. So I'm going

2460
03:49:06,950 --> 03:49:12,721
to copy that I'm going to add that here. Oh,
sorry, not there, down here. I knew something

2461
03:49:12,721 --> 03:49:17,690
was gonna look great. So add that there, we
are going to do the same thing with our price

2462
03:49:17,690 --> 03:49:29,641
to sales ratio. So that's right here. All
right now for Evie to even up an Eevee to

2463
03:49:29,641 --> 03:49:37,450
gross profit. We actually have to do some
special logic here because there are metrics

2464
03:49:37,450 --> 03:49:41,280
that are using both of those calculations
that aren't available for every stock. So

2465
03:49:41,280 --> 03:49:47,380
here's how we handle that. The first thing
we need to do is pull in our enterprise value,

2466
03:49:47,380 --> 03:49:52,970
or even in our gross profit metrics. And we're
going to do that inside of this append method.

2467
03:49:52,970 --> 03:50:08,460
So there's enterprise value. Here's the eba.
And here is gross profit. Awesome. And then

2468
03:50:08,460 --> 03:50:13,210
in here, for now, I'm not going to do the
special logic that I just referred to referred

2469
03:50:13,210 --> 03:50:20,521
to earlier, because I want to show you what
happens if you go into pptp. Oh, and this

2470
03:50:20,521 --> 03:50:28,500
isn't easy as it should be enter price value.
And then here would be enterprise value divided

2471
03:50:28,500 --> 03:50:36,700
by gross profit. All right, let's run this
and see what happens. So far, so good 72.

2472
03:50:36,700 --> 03:50:42,231
And then that we get a key error for a Pl.
And that's because all of those applets it

2473
03:50:42,231 --> 03:50:51,979
says need to be replaced with symbol. Let's
do that. Try that. Great. We have another

2474
03:50:51,979 --> 03:50:57,649
key err, because there's more instances of
Apple up here. That is embarrassing. Like

2475
03:50:57,649 --> 03:51:07,580
I said earlier in this course, I'm not going
to edit this out, because I want you to see

2476
03:51:07,580 --> 03:51:13,130
how I debug stuff in real time, it might be
useful to see the debugging process of a different

2477
03:51:13,130 --> 03:51:17,570
developer. Okay, what happens now, here's
what we're getting. So it says unsupported

2478
03:51:17,570 --> 03:51:22,530
operand type for division, integer and non
type. And that's referring to this line right

2479
03:51:22,530 --> 03:51:29,439
here. Okay, what's going on, let's crank out
our enterprise value. So we have a value for

2480
03:51:29,439 --> 03:51:37,021
enterprise value. Now let's print it or EBITDA.
None, now, that is the source of the error.

2481
03:51:37,021 --> 03:51:44,210
So to fix this, we need to find some sort
of workaround to fill this value, even when

2482
03:51:44,210 --> 03:51:49,890
there's a none type for one of the metrics
that it contains. Now, there's lots of different

2483
03:51:49,890 --> 03:51:54,400
ways that you can handle this. But what we're
going to do is this, I'll show you so we saw

2484
03:51:54,400 --> 03:52:00,410
when building our portfolio input function
in earlier projects of this course, that tricep

2485
03:52:00,410 --> 03:52:04,890
statements can be used to handle exceptions.
So that's what we're going to use, we're gonna

2486
03:52:04,890 --> 03:52:19,770
use try this. And if that doesn't work, we're
going to make an accept statement that handles

2487
03:52:19,770 --> 03:52:23,560
specifically the type of error one carrying,
which is a type error. And then we're going

2488
03:52:23,560 --> 03:52:33,600
to say np.na n now, because this is in an
append statement, we actually can't put it

2489
03:52:33,600 --> 03:52:35,820
there. Instead, we're going to create an EV
to EBITDA ratio, and put this outside of the

2490
03:52:35,820 --> 03:52:44,260
append state. And I'll show you more about
what that looks like in a second correctly.

2491
03:52:44,260 --> 03:52:49,500
Okay, so this is going to be putting aside
the append statement right here after we create

2492
03:52:49,500 --> 03:52:55,600
all these. And since the indenting, is in
a loop, I have to tab that in. And then we

2493
03:52:55,600 --> 03:53:05,689
will replace this with sorry, Evie, to Eva.
Now, okay, what this does is it tries to calculate

2494
03:53:05,689 --> 03:53:11,470
a vd beta using this. And if that fails because
of a type error, then it will fill it in with

2495
03:53:11,470 --> 03:53:15,630
NP dot and n. Now, that's not good, because
na N stands for not a number, and how are

2496
03:53:15,630 --> 03:53:20,170
you supposed to source logs on value metrics
that aren't numbers? Well, we're going to

2497
03:53:20,170 --> 03:53:23,170
see later on in this section, or later on
in this project, I should say that there's

2498
03:53:23,170 --> 03:53:27,939
a number of different ways that you can handle
missing data in the pandas library to fill

2499
03:53:27,939 --> 03:53:34,520
in the values that aren't there with reasonable
values by performing calculations on the other

2500
03:53:34,520 --> 03:53:38,860
values in the data set. So I will see more
about that later. But the main idea to remember

2501
03:53:38,860 --> 03:53:43,040
now is that even though we're filling our
panda's data frame with null values, now,

2502
03:53:43,040 --> 03:53:46,740
those aren't going to stay there for our final
calculations, because we're going to replace

2503
03:53:46,740 --> 03:53:53,280
them with something more meaningful later.
Okay, the next thing we need to do is we haven't

2504
03:53:53,280 --> 03:53:57,650
seen it yet. But this type error happens with
the gross profit metric as well because some

2505
03:53:57,650 --> 03:54:01,820
companies don't actually report gross profit
depending on how, what their operations look

2506
03:54:01,820 --> 03:54:08,340
like and those sorts of things. So what we're
gonna do is create a similar Eb to gross profit

2507
03:54:08,340 --> 03:54:19,729
metric here and use the exact same type error
Exception Handling to to handle this, okay,

2508
03:54:19,729 --> 03:54:23,540
so Eb to gross profits, enterprise value divided
by gross profit, this looks good. The only

2509
03:54:23,540 --> 03:54:28,859
other thing we need to do is take this variable
and replace the actual divisor in the income

2510
03:54:28,859 --> 03:54:31,690
statement. Okay, now I'm going to delete this
other code cell that we were working with

2511
03:54:31,690 --> 03:54:42,200
and run it again to see if it works. So far,
so good. Awesome, so that code cell ran with

2512
03:54:42,200 --> 03:54:49,260
no problem let's print our data frame now
see what it looks like. Awesome. So we have

2513
03:54:49,260 --> 03:54:56,330
ticker stock price number of shares to buy
price to earnings ratio, p percentile price

2514
03:54:56,330 --> 03:55:00,160
to book ratio, PB percentile, price to sales
ratio.

2515
03:55:00,160 --> 03:55:08,280
O p s percentile EV to EBITDA percentile up
to GP percentile and the army score. Everything

2516
03:55:08,280 --> 03:55:12,120
looks like it was added properly here. So
we can now move on to dealing with missing

2517
03:55:12,120 --> 03:55:20,710
data in our data frame. Now, our data frame
contains missing values, because we use that

2518
03:55:20,710 --> 03:55:28,859
try accept logic in the last section to fill
in missing values. Whenever the cloud API

2519
03:55:28,859 --> 03:55:31,840
provided a nun response for a metric that
we were using. That's basically what this

2520
03:55:31,840 --> 03:55:35,520
says it says our data frame contains some
missing data because all the metrics we require

2521
03:55:35,520 --> 03:55:39,560
are not available through the API that we're
using. So to see where this missing data is,

2522
03:55:39,560 --> 03:55:46,780
what you can do is use the pandas is no method.
So this is kind of the statement you execute

2523
03:55:46,780 --> 03:55:52,090
to see all call or sorry, all the rows that
have missing data, and then you say, RV data

2524
03:55:52,090 --> 03:55:57,729
frame, and then in square brackets, you would
say RV data frame is no. And then on that

2525
03:55:57,729 --> 03:56:05,460
isn't all you want to say any and then axis
equals one. Okay, so to break this down, we're

2526
03:56:05,460 --> 03:56:09,689
taking our RV data frame, and then we are
filtering in the square brackets to say any

2527
03:56:09,689 --> 03:56:15,190
part of RV data frame where the is no method
is true. And then on that we want to apply

2528
03:56:15,190 --> 03:56:20,850
it to any columns. And this axis equals one
tells us columns, not rows. So when we run

2529
03:56:20,850 --> 03:56:26,820
this, this is going to return a modified version
of our panda's data frame that only contains

2530
03:56:26,820 --> 03:56:33,441
rows where there's missing data. All right,
so as you can see, there is quite a bit of

2531
03:56:33,441 --> 03:56:38,760
missing data. And you can actually see how
much there is by calling the length of this

2532
03:56:38,760 --> 03:56:44,520
index. So there's 55 rows that have some sort
of missing data in the panda's data frame,

2533
03:56:44,520 --> 03:56:51,400
which is about 10% of the entire data set.
So let's look at this again. As you can see,

2534
03:56:51,400 --> 03:56:56,400
all not all of the indices of the panda's
data frame exists. So it starts at 1718 2026.

2535
03:56:56,400 --> 03:57:01,950
There's lots of missing rows, because all
the missing rows have no missing data. So

2536
03:57:01,950 --> 03:57:06,510
let's take a look at this first row, which
covers the stock Aflac, which is an insurance

2537
03:57:06,510 --> 03:57:14,670
company, there is a non value here for price
to sales ratio, there is a nun value. Actually,

2538
03:57:14,670 --> 03:57:18,620
that's the only non value for that column.
Now, if you look, in other columns, like this

2539
03:57:18,620 --> 03:57:24,450
column, there's a non value for price to earnings
ratio. And overall, these non values aren't

2540
03:57:24,450 --> 03:57:28,070
super problematic, because in the next section,
we're going to see how to deal with it. So

2541
03:57:28,070 --> 03:57:31,280
this says dealing with that dealing with missing
data is an important topic in data science.

2542
03:57:31,280 --> 03:57:36,210
And there's two main approaches, you can either
drop the missing data using the drop na method,

2543
03:57:36,210 --> 03:57:43,280
or you can replace the missing data with a
fill in a method. So the following NF, it's

2544
03:57:43,280 --> 03:57:46,900
pretty interesting, because you can actually
pass information that allows it to fill in

2545
03:57:46,900 --> 03:57:53,990
missing data with summary data from that same
column. So as one example, if we have missing

2546
03:57:53,990 --> 03:57:58,280
data in our price to earnings ratio column,
we can fill it in with the average value of

2547
03:57:58,280 --> 03:58:01,910
all price earnings ratios for all the other
stocks in the data set. So that's exactly

2548
03:58:01,910 --> 03:58:06,350
what we're going to do, we're going to replace
missing data with the average non null data

2549
03:58:06,350 --> 03:58:10,470
point from that column. So here's the code.
To do this, we need to create a for loop that

2550
03:58:10,470 --> 03:58:16,090
loops over all of the columns in our panda's
data frame. So we'll say for column and RV

2551
03:58:16,090 --> 03:58:21,910
underscore data frame dot columns. And then
let's just print this out to see what is happening.

2552
03:58:21,910 --> 03:58:28,120
Great. As you can see, this is successfully
looping over our pandas data frames. And then

2553
03:58:28,120 --> 03:58:33,340
what we want to say is our V underscore data
frame, dot fill, and a Now if you've never

2554
03:58:33,340 --> 03:58:39,720
used this before, one easy way to see which
parameters it accepts is most into the the

2555
03:58:39,720 --> 03:58:44,250
parentheses of the method and then hit Shift
Tab. And this will pop up a little bit of

2556
03:58:44,250 --> 03:58:48,590
documentation. So what we're going to do is
we're going to say fill in the missing values

2557
03:58:48,590 --> 03:58:55,140
with the average value from that column. So
to get the average value, we're going to say,

2558
03:58:55,140 --> 03:59:03,390
fill in a and then we're going to say, RV
underscore data frame, we're going to select

2559
03:59:03,390 --> 03:59:06,439
that specific column from the data frame.
And then we're going to call the mean method

2560
03:59:06,439 --> 03:59:10,830
on dot mean. And one other thing I forgot
to add here is that we don't want to apply

2561
03:59:10,830 --> 03:59:15,420
this to the entire data frame, we want to
apply to this specific column on that data

2562
03:59:15,420 --> 03:59:19,610
frame. Now, the reason why you have to add
this is because if you didn't, for the first

2563
03:59:19,610 --> 03:59:23,720
iteration of this loop, when it loops through
the ticker column, it would fill the entire

2564
03:59:23,720 --> 03:59:27,609
data frame with the average value of the ticker
column, which is not what we want. So if we

2565
03:59:27,609 --> 03:59:38,240
run this, we get a value error and says cannot
convert string to float. Now, the reason why

2566
03:59:38,240 --> 03:59:44,410
this is is because you can't actually, so
what this is doing is it's trying to calculate

2567
03:59:44,410 --> 03:59:48,320
a mean for the ticker column, which is obviously
impossible. So we actually need to create

2568
03:59:48,320 --> 03:59:55,229
a subset of our columns. And to do that, the
easiest way is probably to just print out

2569
03:59:55,229 --> 04:00:02,630
our columns, early data columns. We will grab
in And then we need to modify our for loop

2570
04:00:02,630 --> 04:00:06,790
so that it only loops over certain columns
of the panda's data frame. So we will put

2571
04:00:06,790 --> 04:00:13,390
that there. And then does this still work
with it being multi line, it does awesome.

2572
04:00:13,390 --> 04:00:22,060
So we want to take out all of our non numerical
columns. So that would be all the percentiles

2573
04:00:22,060 --> 04:00:33,780
it would be PB percentile, p s percentile,
EV to EBITDA percentile. ebgp percentile,

2574
04:00:33,780 --> 04:00:39,530
and are the percentile. And I'm actually going
to take out this Price column too, because

2575
04:00:39,530 --> 04:00:45,790
there's not going to be any missing price
data. Alright, so if we run this, this should

2576
04:00:45,790 --> 04:00:52,490
look a little better. I'm actually going to
put these all in one line just for readability.

2577
04:00:52,490 --> 04:01:00,109
There we go. Alright, what happens when I
run this? Awesome. Now, if we run our same

2578
04:01:00,109 --> 04:01:05,660
command from earlier, to identify missing
data in our data frame? If we have done this

2579
04:01:05,660 --> 04:01:11,900
properly, this should return an empty data
frame because there shouldn't be any null

2580
04:01:11,900 --> 04:01:17,370
values anymore. And there still is why is
that? This price to sales ratio still has

2581
04:01:17,370 --> 04:01:23,950
quite a bit of null values. Why is that? Oh,
I see. So within this fill in a method, you

2582
04:01:23,950 --> 04:01:32,720
actually have to pass the in place equals
true. And this says, Don't just return the

2583
04:01:32,720 --> 04:01:37,200
modified column, modify the original column
instead. So we'll do that. And then when we

2584
04:01:37,200 --> 04:01:41,729
run this, we get an empty panda's data frame,
which shows us that we have successfully dealt

2585
04:01:41,729 --> 04:01:45,170
with all the missing data in the original
data frame. So that's kind of a high level

2586
04:01:45,170 --> 04:01:50,540
introduction of how to deal with missing data
in pandas. There's lots of more information

2587
04:01:50,540 --> 04:01:54,630
you could learn about this. And dealing with
missing data is a full topic in and of itself.

2588
04:01:54,630 --> 04:01:59,610
So this is just a high level introduction,
we can now move on to calculating value percentiles.

2589
04:01:59,610 --> 04:02:05,550
Alright, so what we need to do now is we need
to calculate value score percentiles for every

2590
04:02:05,550 --> 04:02:09,560
stock in our universe. More specifically,
we need to calculate percentile scores for

2591
04:02:09,560 --> 04:02:14,700
the following metrics, price to earnings ratio,
price to book ratio, price to sales ratio,

2592
04:02:14,700 --> 04:02:20,960
Evie to EBIT and Evie to gross profit. Now,
unlike before, we can't use the start of every

2593
04:02:20,960 --> 04:02:28,061
string as a way to interpolate in that string.
Because in the last project, we had the same

2594
04:02:28,061 --> 04:02:32,290
two words, at the start of every momentum
metric, like an example would be, we had one

2595
04:02:32,290 --> 04:02:37,720
year price momentum and one year, return percentile.
So we can't do that anymore, because we use

2596
04:02:37,720 --> 04:02:43,990
some abbreviations. So if you look here, you
can't use price to earnings ratio to find

2597
04:02:43,990 --> 04:02:47,481
the price earnings ratio percentile column
because there's an abbreviation. So I did

2598
04:02:47,481 --> 04:02:52,640
that intentionally so that you can see a different
way of approaching this problem. What we're

2599
04:02:52,640 --> 04:02:57,660
going to do instead is I just copied the column
names to my clipboard like this. And we are

2600
04:02:57,660 --> 04:03:03,600
going to turn this into a dictionary, we're
going to call this dictionary metrics. And

2601
04:03:03,600 --> 04:03:07,750
here's what we're going to do. So we need
to wrap this entire thing in curly brackets.

2602
04:03:07,750 --> 04:03:14,990
And for every metric column, that column name
is going to be a key for the dictionary. And

2603
04:03:14,990 --> 04:03:19,030
that percentile column is going to be the
value of the dictionary like that. So if we

2604
04:03:19,030 --> 04:03:29,240
do that same operation on a few different
lines, this will fill it up pretty quickly.

2605
04:03:29,240 --> 04:03:38,771
All right, let's put these on our own lines
like that. Okay, so basically, what this does,

2606
04:03:38,771 --> 04:03:42,260
I'm gonna run this code cell to make sure
it's formatted properly. And the way we're

2607
04:03:42,260 --> 04:03:48,350
going to use this dictionary is we're going
to pass in a, a metric, and it will return

2608
04:03:48,350 --> 04:03:55,900
back the name of the corresponding percentile
row. So to calculate our percentile scores,

2609
04:03:55,900 --> 04:04:01,130
we are going to loop through every metric
in this metrics dictionary. So here's how

2610
04:04:01,130 --> 04:04:07,990
we'll do that we'll say for metric in metrics,
dot fees. And then within here, we need to

2611
04:04:07,990 --> 04:04:14,010
calculate percentile scores. And we need to
do that for every row. So we need to create

2612
04:04:14,010 --> 04:04:20,820
an inner loop that says for row in RV underscore
data frame, index, and then here's what we're

2613
04:04:20,820 --> 04:04:25,470
gonna do. We're going to print the row now
this should print how many metrics are there

2614
04:04:25,470 --> 04:04:34,540
five, five times this should print zero to
504. So we have 12345. Awesome. Okay, now

2615
04:04:34,540 --> 04:04:45,340
here we need to use the pandas LLC method
to access the percentile score. columns. Now

2616
04:04:45,340 --> 04:04:51,149
here's how we'll do that we'll say RV underscore
data frame, dot LLC. And then the first entry

2617
04:04:51,149 --> 04:04:55,750
of this LSE method will be in a row and the
second entry will be the column name. And

2618
04:04:55,750 --> 04:05:01,710
that will be metric. No sorry, that won't
be metric that will be metrics have metric.

2619
04:05:01,710 --> 04:05:09,620
And this funny looking dictionary access statement
is basically pulling in a percentile column.

2620
04:05:09,620 --> 04:05:12,570
To make sure that that's working properly,
let's just print this. And what this should

2621
04:05:12,570 --> 04:05:16,830
do is just print a whole bunch of anaise.
Awesome. So this shows that we're accessing

2622
04:05:16,830 --> 04:05:23,399
all of the different percentile columns. And
we want to do here is use the percentile of

2623
04:05:23,399 --> 04:05:31,100
score to calculate a percentile. So to do
that, we'll say that is equal to stats dot

2624
04:05:31,100 --> 04:05:35,840
percentile score. And then within this, we're
gonna have two items. So this will be the

2625
04:05:35,840 --> 04:05:44,980
entire column. And this will be the value
of that row at the column. So to get the entire

2626
04:05:44,980 --> 04:05:52,950
column, we're just going to say, RV and just
look at the thing. And then we're gonna pass

2627
04:05:52,950 --> 04:05:59,490
in the name of the column, so that will be
metric. And then over here, we need an over

2628
04:05:59,490 --> 04:06:03,859
here, we want to get the value of the row
at that column. To do that, we're going to

2629
04:06:03,859 --> 04:06:12,210
say, RV underscore data frame, LLC. And instead
of saying, the metrics dictionary, at that

2630
04:06:12,210 --> 04:06:19,811
metric, we're just gonna say the metric. So
let's run this and then print our panda's

2631
04:06:19,811 --> 04:06:33,000
data frame to see what that looks like. Great.
So here, we have all the percentile scores.

2632
04:06:33,000 --> 04:06:41,580
Now, you can see this appears to be right,
because here we have a low Evie to GP and

2633
04:06:41,580 --> 04:06:47,700
has a low percentile. Here's a high Evie to
GP with a higher percentile. And you can see

2634
04:06:47,700 --> 04:06:53,080
the same logic for all of these now, just
like before, this Python line is very long,

2635
04:06:53,080 --> 04:06:57,460
and it's actually all fit on one line. So
I'll show you how you can easily make that

2636
04:06:57,460 --> 04:07:04,320
a little cleaner. we'll import the function
specific resources from sci fi dot stats,

2637
04:07:04,320 --> 04:07:15,540
import, percentile of score as score. And
then we can replace this with just score.

2638
04:07:15,540 --> 04:07:20,600
And actually, since we use a different dictionary
method, this now fits on one line is much

2639
04:07:20,600 --> 04:07:26,170
more readable. If you run it, they'll give
the same output. Great. So that's how we calculated

2640
04:07:26,170 --> 04:07:30,810
our percentile scores. As a quick recap of
what is done in this code cell, we imported

2641
04:07:30,810 --> 04:07:35,810
the percentile of score function from the
Sai pi dot stats module, and we named it score.

2642
04:07:35,810 --> 04:07:40,840
And then we created a dictionary of metrics
where every key in the dictionary is one of

2643
04:07:40,840 --> 04:07:46,050
the valuation metrics that we're using an
every value of the dictionary is the corresponding

2644
04:07:46,050 --> 04:07:51,110
percentile column of our panda's data frame.
And then we created a double nested for loop,

2645
04:07:51,110 --> 04:07:56,820
where the first for loop loops over every
metric in our metric dictionary, and the second

2646
04:07:56,820 --> 04:08:02,350
for loop loops over every row in our panda's
data frame. And then, within both of those

2647
04:08:02,350 --> 04:08:08,510
four loops, we have an operation here that
calculates the percentile score of every evaluation

2648
04:08:08,510 --> 04:08:13,960
metric and assigns that value to the corresponding
percentile score column. And at the very end,

2649
04:08:13,960 --> 04:08:19,500
we just printed out our past data frame. Now
we can move on to calculating our lead score.

2650
04:08:19,500 --> 04:08:25,410
So just like before, we're going to use the
mean function from the built in Python stats

2651
04:08:25,410 --> 04:08:30,790
module. So we'll say from stats, import name,
and then we're just going to calculate the

2652
04:08:30,790 --> 04:08:38,310
mean of five and 10. Make sure that this is
working properly. We say no module name stats,

2653
04:08:38,310 --> 04:08:43,880
that's because I should have said statistics
Great. So the mean of five and 10 is indeed

2654
04:08:43,880 --> 04:08:48,230
7.5. So that seems to be working properly.
Now what we need to do is we need to loop

2655
04:08:48,230 --> 04:08:57,530
through every row of our panda's data frame,
and calculate the the avar calculate the RV

2656
04:08:57,530 --> 04:09:02,900
score for that row. So to start, we'll just
say for throw in RV storage data frame index.

2657
04:09:02,900 --> 04:09:12,240
And let's just print that row. So this should
print a bunch of numbers from zero to 504.

2658
04:09:12,240 --> 04:09:20,740
So it goes zero all the way to 504. That is
excellent. Now, we need to access this row

2659
04:09:20,740 --> 04:09:24,250
of the panda's data frame and like before,
we can do that with the LSC method. So what

2660
04:09:24,250 --> 04:09:30,550
I'll do is I'll just copy this, paste it here,
and I'll change which column we're accessing

2661
04:09:30,550 --> 04:09:40,490
to RV score. And to make sure this is working
properly, let's just print this. Alright,

2662
04:09:40,490 --> 04:09:49,310
that looks good. Now what we need to do is
access all of the different percentile scores

2663
04:09:49,310 --> 04:09:54,819
from our pandas DataFrame and calculate their
mean. So on this side, we'll say mean and

2664
04:09:54,819 --> 04:10:00,350
then since this will be a fairly long line,
I'm actually going to variables for all these.

2665
04:10:00,350 --> 04:10:21,149
It's a P e ratio, PB ratio, PS ratio, Evie
to EBIT ratio, and Eb to gross profit. Now

2666
04:10:21,149 --> 04:10:28,271
I need to grab the LSC method from up here.
Actually, I just thought a better way to do

2667
04:10:28,271 --> 04:10:31,130
this, what we're going to do is we're going
to delete this, we're going to create a empty

2668
04:10:31,130 --> 04:10:41,280
pandas list, and we're going to call that
value percentiles. And we want to grab this

2669
04:10:41,280 --> 04:10:49,870
same for loop here. So for metric metrics
duckies. And we are going to say value underscore

2670
04:10:49,870 --> 04:11:00,200
percentiles, dot append. And then we are going
to grab the value from the corresponding percentile.

2671
04:11:00,200 --> 04:11:13,520
Awesome. We want netwrix indexing metric.
Alright, we are going to now just do this

2672
04:11:13,520 --> 04:11:19,050
over one iteration of the loop to make sure
it works properly. And before we do that,

2673
04:11:19,050 --> 04:11:27,060
we actually have in here to calculate the
mean of this value percentiles. Yes. And inside

2674
04:11:27,060 --> 04:11:42,110
the loop, we are going to correct the RV DataFrame.
Awesome. Now, one other thing we can do to

2675
04:11:42,110 --> 04:11:49,130
test this actually is printed out value percentiles.
Alright, so to make sure this is working properly,

2676
04:11:49,130 --> 04:11:53,170
all we have to do is compare this to this,
you can see the same, we have to compare this

2677
04:11:53,170 --> 04:11:57,020
to this, you can see that the same, we have
to compare this to this and you can see that

2678
04:11:57,020 --> 04:12:02,800
they're the same. And we have to compare this
to this, and this to this. Awesome, so that

2679
04:12:02,800 --> 04:12:11,490
is working properly. And what we can do now
is delete these print statements. Make this

2680
04:12:11,490 --> 04:12:15,689
loop iterate over the entire panda's data
frame. And then inside the loop, we can print

2681
04:12:15,689 --> 04:12:21,050
the RV underscore data frame. Awesome, you
can see all of our percentile scores were

2682
04:12:21,050 --> 04:12:27,970
correctly calculated. And now we can move
on to calculating. Now we can move on to selecting

2683
04:12:27,970 --> 04:12:33,330
the 50 best value stocks. Great. So as before,
we can use the panda sword value method to

2684
04:12:33,330 --> 04:12:38,330
identify the 50 best stocks in our universe
according to the RV score column. So to do

2685
04:12:38,330 --> 04:12:46,600
that, we access our RV data frame, we call
the store values method on it. And then in

2686
04:12:46,600 --> 04:12:49,040
here, we have to pass in a few things we have
to pass in the column we want to sell it on.

2687
04:12:49,040 --> 04:12:55,950
And then we have to specify the ascending
method. And we want this ascending to be true

2688
04:12:55,950 --> 04:13:03,130
because we want the lowest valuation metrics
at the top. And then we have to specify in

2689
04:13:03,130 --> 04:13:07,950
place once that's done, we can print our panda's
data frame outside of this or values given

2690
04:13:07,950 --> 04:13:15,851
like this to see what modifications have been
made. All right, so now you can see the cheapest

2691
04:13:15,851 --> 04:13:19,630
stocks according to a basket of different
valuation metrics. We have Kohl's we have

2692
04:13:19,630 --> 04:13:25,689
FTI. I'm not actually sure what company that
is, but we can find it pretty easily FTI stock

2693
04:13:25,689 --> 04:13:32,240
and it's technic FMP. It looks like they're
a global oil and gas company. It makes sense

2694
04:13:32,240 --> 04:13:36,990
that they're cheap right now because oil prices
are so low Asia HFC is hollyfrontier Corp.

2695
04:13:36,990 --> 04:13:44,840
They are also an oil and gas company. And
Al is an airline. They are priced very cheaply

2696
04:13:44,840 --> 04:13:48,760
right now because the entire travel industry
has experienced significant headwinds due

2697
04:13:48,760 --> 04:13:55,979
to the covid 19 pandemic. And HP I believe
is Hewlett Packard. I note Yeah, Hewlett Packard

2698
04:13:55,979 --> 04:14:01,030
enterprises and they make printers and those
sorts of things. They've kind of always traded

2699
04:14:01,030 --> 04:14:05,370
a pretty cheap valuation. So that's that.
On the other end of the spectrum, you can

2700
04:14:05,370 --> 04:14:11,061
see what stocks are trading at extremely high
valuations. So dx cm, I believe is dex calm.

2701
04:14:11,061 --> 04:14:16,490
They make continuous glucose monitoring. Yep,
they make continuous glucose monitoring systems

2702
04:14:16,490 --> 04:14:25,479
for diabetes management. Now I'm not sure
what stock that is, but we can find out now.

2703
04:14:25,479 --> 04:14:29,200
This is ServiceNow and they're an American
software company. Every software company in

2704
04:14:29,200 --> 04:14:33,720
the world is trading at pretty high multiples
right now that we have AMD they make CPUs

2705
04:14:33,720 --> 04:14:39,510
and other sorts of computer hardware just
like Nvidia and then pa yc i think is paychecks

2706
04:14:39,510 --> 04:14:46,311
which is a it is paychecks they are a payment
processing company. Not pay comm although

2707
04:14:46,311 --> 04:14:50,540
they're in the same business. It's an American
online payroll and human resource technology

2708
04:14:50,540 --> 04:14:56,501
provider based in Oklahoma City. Okay, so
that's done. What we need to do now is we

2709
04:14:56,501 --> 04:15:03,280
need to drop all of the stocks that are after
50th index. So to do that, we will say RV

2710
04:15:03,280 --> 04:15:11,069
underscore data frame is equal to RV underscore
data frame at index zero to index 50. And

2711
04:15:11,069 --> 04:15:17,710
I actually didn't print that. So what we can
do now our data frame. Great. So this looks

2712
04:15:17,710 --> 04:15:22,149
like it's been truncated to only contain the
50 cheapest stocks in our universe to make

2713
04:15:22,149 --> 04:15:26,543
sure that there's like 50, what we can say
is we want to calculate the length of the

2714
04:15:26,543 --> 04:15:32,760
index of the data frame. And that is 50. Awesome.
The only other thing we need to do is we need

2715
04:15:32,760 --> 04:15:36,670
to filter or sorry, not filter, we need to
reset the index of a panda's data frame. And

2716
04:15:36,670 --> 04:15:41,350
we saw before that we do reset underscore
index. And then we want to pass drop equals

2717
04:15:41,350 --> 04:15:46,420
true into it to avoid duplicating the existing
index of the panda's data frame. And then

2718
04:15:46,420 --> 04:15:51,600
we also want to pass in, in places where it's
true. And like all the other instances, including

2719
04:15:51,600 --> 04:15:56,830
right here, what this in place equals true
parameter does is it means we're gonna actually

2720
04:15:56,830 --> 04:16:03,710
modify the original panda's data frame instead
of just returning a modified version temporarily.

2721
04:16:03,710 --> 04:16:08,970
So we already have our data frame and see
what this looks like. Awesome. So now our

2722
04:16:08,970 --> 04:16:15,520
index goes from zero, I should finish up 49.
Yep. And these are the 50 cheapest stocks

2723
04:16:15,520 --> 04:16:20,350
in our universe. So now that we've selected
the 50 best value stocks, we can move on to

2724
04:16:20,350 --> 04:16:24,859
calculating the number of shares to buy. Now,
earlier in this Jupyter Notebook, we defined

2725
04:16:24,859 --> 04:16:29,410
a portfolio input function that will allow
us to easily create our portfolio size. So

2726
04:16:29,410 --> 04:16:34,750
to do that, we will say portfolio underscore
size, we will run this by itself, and then

2727
04:16:34,750 --> 04:16:41,590
we will enter a string object does not call
it a poll. Why is that? That's because we

2728
04:16:41,590 --> 04:16:45,880
need to pass in portfolio input in our portfolio
size. All right, now we want to enter the

2729
04:16:45,880 --> 04:16:49,319
value of our portfolio. So that's going to
be a million dollars. So one and then six

2730
04:16:49,319 --> 04:16:54,740
zeros 123123. Actually, let's spice things
up a bit and do something different. So we'll

2731
04:16:54,740 --> 04:17:01,960
do two and a half million to two, five, and
then five zeros. 12345. Awesome. Now let's

2732
04:17:01,960 --> 04:17:08,860
print our portfolio, size object or variable
i should say, can make sure that it's stored

2733
04:17:08,860 --> 04:17:13,540
correctly. Awesome. Now we need to calculate
our position size. And we've done this twice

2734
04:17:13,540 --> 04:17:18,939
now first in our equal weight s&p 500 strategy
and then in our momentum strategy. So you

2735
04:17:18,939 --> 04:17:22,130
should be good to do this on your own, I would
encourage you to pause this video and try

2736
04:17:22,130 --> 04:17:25,930
to do it by yourself. But if you want to follow
along, you can. So to do this, we will say

2737
04:17:25,930 --> 04:17:34,069
position, size is equal to and then the numerator
of this division is going to be the portfolio

2738
04:17:34,069 --> 04:17:37,860
size variable that we just created. And the
denominator is going to be the length of our

2739
04:17:37,860 --> 04:17:41,990
panda's data frame. So I've mentioned this
in earlier videos, but I prefer to just do

2740
04:17:41,990 --> 04:17:47,050
the length of the RVM store data frame index,
and then we can print our position size. Now,

2741
04:17:47,050 --> 04:17:55,240
what does this give us an unsupported operand
type for string and integer. That's because

2742
04:17:55,240 --> 04:18:00,600
I actually ran into this problem in the momentum
project as well, we need to force this to

2743
04:18:00,600 --> 04:18:09,319
be a float. Now what is this giving us $50,000.
And if you think about it, our portfolio is

2744
04:18:09,319 --> 04:18:14,670
two and a half million dollars. And there's
505 stocks in our sorry, 50 stocks in our

2745
04:18:14,670 --> 04:18:19,070
universe. So if we want to make sure that
this is right, we can just test using the

2746
04:18:19,070 --> 04:18:26,240
double equality operator, whether the position
size is equal to two and a half million divided

2747
04:18:26,240 --> 04:18:31,740
by 50. And if this returns true, then we know
that the calculation has been done properly.

2748
04:18:31,740 --> 04:18:36,590
Awesome. Now, we need to figure out how many
shares of each stock we need to buy to reach

2749
04:18:36,590 --> 04:18:41,950
a position size of $50,000 in each stock.
So to do that, just like before, we're going

2750
04:18:41,950 --> 04:18:48,840
to create a for loop that loops through every
row of our panda's data frame. So we'll say

2751
04:18:48,840 --> 04:18:53,030
for row in our VM, so data frame index, and
make sure that's living properly, we'll just

2752
04:18:53,030 --> 04:18:57,450
print them that should go from zero 49. And
it does, which is awesome. And then we will

2753
04:18:57,450 --> 04:19:00,840
say RV underscore DataFrame, LLC. And in here,
the first thing that we need to put in is

2754
04:19:00,840 --> 04:19:06,190
the row, the second thing we need to put in
is the number of shares the by column. And

2755
04:19:06,190 --> 04:19:14,410
to make sure that's working properly, let's
just print it out. The reason I always test

2756
04:19:14,410 --> 04:19:19,640
these LLC methods is because sometimes if
you type the column title wrong, it won't

2757
04:19:19,640 --> 04:19:23,440
work. And it looks like that's exactly what
happened here. So let's see what happened.

2758
04:19:23,440 --> 04:19:26,930
We have number of shares to buy. And to see
what the difference is I'm going to scroll

2759
04:19:26,930 --> 04:19:36,910
up to where we originally defined that column
title, and I'm going to paste it beside it.

2760
04:19:36,910 --> 04:19:40,399
So that's way up here. And so we have number
of shares to buy number of shares to buy.

2761
04:19:40,399 --> 04:19:44,700
They look the same to me. Maybe that's not
actually what the error was. Let's go back

2762
04:19:44,700 --> 04:20:01,230
down and actually read the error message that
could help during handling of the above session,

2763
04:20:01,230 --> 04:20:10,120
okay, key error Okay, let's print out our
column names to see what's going on. Number

2764
04:20:10,120 --> 04:20:15,750
of, Oh, my soul, it is it is just a typo,
I didn't put an S on share. So that's the

2765
04:20:15,750 --> 04:20:19,240
problem. And now this prints out all the entries
in our number of shares to buy column. Of

2766
04:20:19,240 --> 04:20:24,990
course, that's not what we want, we need to
actually change the value of those cells in

2767
04:20:24,990 --> 04:20:30,430
the panda's data frame. So to do that, we'll
use the assignment operator, the equal sign,

2768
04:20:30,430 --> 04:20:38,830
and then we need to do a division. So what
goes on the top, it's our position size. And

2769
04:20:38,830 --> 04:20:41,450
then in the numerator, we need to figure out
our stock price. So to do that, we will use

2770
04:20:41,450 --> 04:20:50,920
another LLC and paste it there, we will replace
the column with price. And that should be

2771
04:20:50,920 --> 04:20:54,170
all we need to calculate the number of chairs
we need to buy. So now that that's done, let's

2772
04:20:54,170 --> 04:21:00,250
print out our V data frame and run this code.
So great. So we can see here that for calls,

2773
04:21:00,250 --> 04:21:06,710
it says by 2000 shares for FDI, it says by
6500 shares. And you'll notice that since

2774
04:21:06,710 --> 04:21:12,670
we use the bigger portfolio size, these numbers
are just broadly larger than when we use the

2775
04:21:12,670 --> 04:21:17,500
$1 million portfolio size, which makes sense.
You can also quickly sanity check this by

2776
04:21:17,500 --> 04:21:21,930
looking at this stock, it has a lower stock
price than this stock. And because of that,

2777
04:21:21,930 --> 04:21:25,979
you need to buy many more shares of that stock
to reach the required position size. So everything

2778
04:21:25,979 --> 04:21:32,020
looks to be good here. The only other thing
we need to modify is to say math dot floor.

2779
04:21:32,020 --> 04:21:36,250
And what this does is it rounds every entry
in that number of shares to by column down

2780
04:21:36,250 --> 04:21:39,920
to the nearest integer, for all the reasons
that we described in the first two projects

2781
04:21:39,920 --> 04:21:46,520
of this course. So that is done, we can now
move on to formatting our Excel output. Great.

2782
04:21:46,520 --> 04:21:50,979
So just like before, the first thing we need
to do is create our writer object. And to

2783
04:21:50,979 --> 04:21:56,640
do that, we will say writer is equal to PD
dot Excel writer. And then in here, we have

2784
04:21:56,640 --> 04:22:00,550
to pass in a few things. The first thing we
have to pass in is the name of the Excel file

2785
04:22:00,550 --> 04:22:07,359
that we want to create, which is value underscore
strategy dot XLS x x x x x s LS. And then

2786
04:22:07,359 --> 04:22:13,350
the next thing we need to pass in is the engine,
the engine that we use here, just like before,

2787
04:22:13,350 --> 04:22:18,380
is XLS x writer. Now to make sure this is
working properly, you can just do the render

2788
04:22:18,380 --> 04:22:23,750
dot save method that we have learned about
earlier. And then if you go into the folder

2789
04:22:23,750 --> 04:22:28,370
that we're working in starter files, you should
see the file here, and it should just be empty.

2790
04:22:28,370 --> 04:22:32,620
So here it is. And if you click on it, it's
just an empty XML document, which is awesome,

2791
04:22:32,620 --> 04:22:37,860
because we haven't done any work on it yet.
So what we need to do now is we can delete

2792
04:22:37,860 --> 04:22:44,040
this save method from that code. So now we
need to access our RV data frame. And we use

2793
04:22:44,040 --> 04:22:53,660
the to excel method to pass in the name of
to pass in a panda's data frame to the Excel

2794
04:22:53,660 --> 04:23:02,690
file that we're working with. Now this takes
three things, you have to say Reiter, and

2795
04:23:02,690 --> 04:23:08,830
then you have to say she underscore name is
equal to the value strategy. And then you

2796
04:23:08,830 --> 04:23:16,420
have to pass in index equals false. And this
just means that the index here will get passed

2797
04:23:16,420 --> 04:23:21,740
into the panda's data frame. So we'll do all
that. That creates our fantasy frame. The

2798
04:23:21,740 --> 04:23:26,390
next section is that we need to create the
format's that we'll need for our XLS x file.

2799
04:23:26,390 --> 04:23:31,490
And you'll recall from our first project that
we've already have lots of practice with creating

2800
04:23:31,490 --> 04:23:35,931
these formats. And since we've already done
this, we're just going to run this code cell

2801
04:23:35,931 --> 04:23:40,149
and then continue through this tutorial. So
the next thing we need to do is actually apply

2802
04:23:40,149 --> 04:23:44,010
these formats to each of our columns. And
to do that, we're going to start by creating

2803
04:23:44,010 --> 04:23:48,440
a dictionary and then we will loop through
that dictionary afterwards. So let's go up

2804
04:23:48,440 --> 04:23:54,640
here to where we first created the columns
of our panda's data frame. And from there,

2805
04:23:54,640 --> 04:24:00,450
we will paste them in and create a dictionary.
So here's all of our columns, we will scroll

2806
04:24:00,450 --> 04:24:05,141
to the bottom to paste those in here, we'll
get the indexing set up properly. And then

2807
04:24:05,141 --> 04:24:17,720
we will say column formats equals. And there
is I'm going to add this to its own line,

2808
04:24:17,720 --> 04:24:24,340
and then I'm going to put this ticker on a
new line. And then I'm going to get the indenting.

2809
04:24:24,340 --> 04:24:29,359
Awesome, that looks a bit better. What we
need to do now is actually format this like

2810
04:24:29,359 --> 04:24:35,490
a dictionary. So I'm going to use the multi
cursor functionality of this Jupyter Notebook

2811
04:24:35,490 --> 04:24:42,240
to add my cursor to every one of these. And
then I'm going to add some boilerplate each

2812
04:24:42,240 --> 04:24:47,140
of these lines. So the first thing we're gonna
do is specify a column. I'm going to put a

2813
04:24:47,140 --> 04:24:51,470
on each line and then we'll fix it afterwards.
Then we need to put the semi colon which define

2814
04:24:51,470 --> 04:24:57,710
basically is the defining characteristic of
a Python dictionary. And then we're going

2815
04:24:57,710 --> 04:25:02,400
to create a Python list and to do that, we're
going to move everything At the end of each

2816
04:25:02,400 --> 04:25:10,830
line, there we go, we're back one and then
add the closing list character. The other

2817
04:25:10,830 --> 04:25:17,340
thing we're going to do is move back another
one, and add in a comma, and then string underscore

2818
04:25:17,340 --> 04:25:26,240
format. Now, this worked well for every every
line except for a few. So it's always good

2819
04:25:26,240 --> 04:25:30,490
to go through and just sanity check these,
that one needed a bit of work and this one

2820
04:25:30,490 --> 04:25:37,260
here, something wrong with it, that used to
go there, and we can delete that. Okay, I'm

2821
04:25:37,260 --> 04:25:42,100
going to just run this code to see if this
is formatted properly. It's not string format

2822
04:25:42,100 --> 04:25:47,630
is not defined. Okay, that's because it's
called string template, that is not good.

2823
04:25:47,630 --> 04:25:54,630
What I'm going to do is do a Find and Replace.
So I haven't showed you guys this yet. But

2824
04:25:54,630 --> 04:25:58,750
it's an interesting feature added up real
quick, if you hit Edit here, and then scroll

2825
04:25:58,750 --> 04:26:02,640
down to find replace, what I'm going to do
is I'm going to search for string underscore

2826
04:26:02,640 --> 04:26:08,640
format, and replace all of those with string
underscore template. Boom, that fixes that

2827
04:26:08,640 --> 04:26:14,940
problem. Now, if I run this code, show code
cell, we should be good to go. And we are

2828
04:26:14,940 --> 04:26:19,740
so that is awesome. What I need to do now
is change the column letters for each of these.

2829
04:26:19,740 --> 04:26:32,310
So I hope you guys all know your alphabet
will go A, B, C, D, E, F, G, H, J, and R.

2830
04:26:32,310 --> 04:26:40,229
All right, now we can actually move on to
formatting our our Excel file. So what we'll

2831
04:26:40,229 --> 04:26:51,880
do to start is we will say for column in column
underscore format stuff. So what this does

2832
04:26:51,880 --> 04:26:56,680
is it loops through all of the column letters
that are keys of this dictionary, and make

2833
04:26:56,680 --> 04:27:00,530
sure that's working properly. Let's just print
out all the column letters, it loops from

2834
04:27:00,530 --> 04:27:05,151
a through n, and the dictionary goes from
a through n. So that is good. Now what we

2835
04:27:05,151 --> 04:27:09,721
need to do is we need to call writer dot sheets.
And then we need to access the sheet that

2836
04:27:09,721 --> 04:27:15,850
we named our panda's data frame, and that
is value strategy. So we will copy that, we

2837
04:27:15,850 --> 04:27:19,990
will move back down here and we will paste
that in there. And then we would call the

2838
04:27:19,990 --> 04:27:24,340
set column method. And you'll recall that
this takes a few different parameters, it

2839
04:27:24,340 --> 04:27:28,260
takes the columns and that will look like
that it takes the column width, so we'll use

2840
04:27:28,260 --> 04:27:34,050
25 pixels. And then it takes the format that
will look something like this string underscore

2841
04:27:34,050 --> 04:27:38,900
template. Now, I'm going to run this loop.
And you'll notice that the statement that

2842
04:27:38,900 --> 04:27:43,300
is being run with each loop doesn't actually
change with response to the loop so that this

2843
04:27:43,300 --> 04:27:48,700
is just going to make sure that this is working
properly for column A. And then once that's

2844
04:27:48,700 --> 04:27:49,700
done, we can go into about changing the values
for each iteration of the loop. I'm also going

2845
04:27:49,700 --> 04:27:58,190
to call the writer dot save method to save
it. And we can now look in our working directory

2846
04:27:58,190 --> 04:28:04,530
to see if this has formatted column A successfully
and it has, so we can now move on to interpolate

2847
04:28:04,530 --> 04:28:12,400
values into this. So here we want to use column.
And we need to change this to an F strings

2848
04:28:12,400 --> 04:28:16,710
that actually interpolate properly, we need
to use column there. And then here, we need

2849
04:28:16,710 --> 04:28:25,610
to access the second item of this list. So
to do that, we will say I can't quite scroll

2850
04:28:25,610 --> 04:28:32,801
this up enough to get it away from my webcam
there. That should be okay. So here we want

2851
04:28:32,801 --> 04:28:41,380
to say column underscore formats at column.
So this gives us the list and then we want

2852
04:28:41,380 --> 04:28:45,610
the second item of that list. So we'll try
that and now we'll see what our data frame

2853
04:28:45,610 --> 04:28:50,900
looks like. Actually, to do that, we need
to go back up here and run all this awesome,

2854
04:28:50,900 --> 04:28:55,220
grow working directory, open this up. And
they've all been formatted with the string

2855
04:28:55,220 --> 04:28:59,370
format. So that is good. What we need to do
now is we need to go up here and actually

2856
04:28:59,370 --> 04:29:03,431
change the format that's being applied to
each one. So we have string template, dollar

2857
04:29:03,431 --> 04:29:07,090
template, integer template, flow template
and percent template. And this float template

2858
04:29:07,090 --> 04:29:13,479
here actually did wrong this should be 0.0.
We're on that. And then we'll go through here

2859
04:29:13,479 --> 04:29:22,090
and change its format according to what should
be dollar this should be an integer. This

2860
04:29:22,090 --> 04:29:31,340
should be a float. P percentile should be
a percent. price to book ratio should be a

2861
04:29:31,340 --> 04:29:37,880
float. price to book ratio percentile should
be a percent, price to sales ratio should

2862
04:29:37,880 --> 04:29:46,431
be a float. So sales ratio percentile should
be a percent indash should be a float. Even

2863
04:29:46,431 --> 04:29:56,790
a percentile should be a percent. You need
to gt should be a float. Maybe a GP percentile

2864
04:29:56,790 --> 04:30:02,870
should be a percent and robust value score
should also be a percentage because it is

2865
04:30:02,870 --> 04:30:07,741
an average of all the different percentiles
in our panda's data frame. So we'll run all

2866
04:30:07,741 --> 04:30:14,990
this again and see what this looks like. Awesome.
So we have ticker, which is a string price,

2867
04:30:14,990 --> 04:30:19,110
which is $1 number of shares to buy, which
is an integer price to earnings ratio, which

2868
04:30:19,110 --> 04:30:25,210
is a float p percentile. Everything looks
to be good here. Great. So the only other

2869
04:30:25,210 --> 04:30:29,020
thing that needs change about this is that
we need to format our columns. And we also

2870
04:30:29,020 --> 04:30:33,410
need to change our percentiles, because just
like in the momentum project, they are two

2871
04:30:33,410 --> 04:30:37,359
orders of magnitude bigger than what they
should be. So we'll fix the percentile score

2872
04:30:37,359 --> 04:30:43,061
calculations first, that's pretty easy, all
I need to do is scroll up to here, find the

2873
04:30:43,061 --> 04:30:52,569
loop where we calculated our percentile scores
calculated by percentiles. So if we divide

2874
04:30:52,569 --> 04:31:04,790
this by 100, and that should fix the problem.
So we can do this, run a bunch of code cells,

2875
04:31:04,790 --> 04:31:09,391
do a two and a half million dollar portfolio
again, and then we're back down to the format

2876
04:31:09,391 --> 04:31:13,290
error. So I'm actually gonna go through all
of this and save it again, just to make sure

2877
04:31:13,290 --> 04:31:18,069
that that was done properly. If we open this
up, and we go here, we can now see that the

2878
04:31:18,069 --> 04:31:23,410
percentiles all range from zero to 100, as
desired. Awesome. The next thing we need to

2879
04:31:23,410 --> 04:31:32,359
do is actually format our column headers.
So to do that, we will say, writer dot sheets,

2880
04:31:32,359 --> 04:31:33,650
and then passing values strategy, select these
sheets that we want to format, and then we

2881
04:31:33,650 --> 04:31:36,040
call the right method. Now, you'll recall
that the right method takes a few different

2882
04:31:36,040 --> 04:31:41,740
things and takes the cell we want to write.
So this will be for each row, or sorry, for

2883
04:31:41,740 --> 04:31:50,180
each column, it will be the the first cell
of that column, so we'll say, column, and

2884
04:31:50,180 --> 04:31:56,540
then one. So that's the first cell of that
column. The second thing we need is the actual

2885
04:31:56,540 --> 04:32:00,100
value that we want to write into that cell.
So that will be the first entry of each of

2886
04:32:00,100 --> 04:32:04,810
these lists just like before, so we paste
that in and use index zero. And then the last

2887
04:32:04,810 --> 04:32:10,480
thing that it takes is the format that you
want to apply to that cell so that just like

2888
04:32:10,480 --> 04:32:14,310
the set column method that we use here is
going to be the second entry of that list.

2889
04:32:14,310 --> 04:32:18,240
So we will pass it index one. Alright, so
that should be all the formatting. What I'm

2890
04:32:18,240 --> 04:32:21,880
going to do next is just move this writer
dot save down to here, I'm going to delete

2891
04:32:21,880 --> 04:32:27,510
all of these empty cells. And then I'm going
to scroll back up to where we created our

2892
04:32:27,510 --> 04:32:33,189
Excel file. I'm going to run all the code,
and you should be good to go. So this started

2893
04:32:33,189 --> 04:32:36,569
here, so I'm going to click that and then
do Shift Enter until I reached the end of

2894
04:32:36,569 --> 04:32:42,130
the Jupyter Notebook. And here's our final
spreadsheet. So as you can see, all the formats

2895
04:32:42,130 --> 04:32:47,020
have been applied successfully. And you have
now created a quantitative value investing

2896
04:32:47,020 --> 04:32:52,240
strategy that identifies the 50 cheapest stocks
in the s&p 500 using a basket of different

2897
04:32:52,240 --> 04:32:58,020
valuation metrics. And that concludes our
third project. So kudos to you for making

2898
04:32:58,020 --> 04:33:01,990
it all the way through this algorithmic trading
and Python course.
